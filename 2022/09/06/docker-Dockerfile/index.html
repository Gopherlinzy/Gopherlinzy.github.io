

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="孙禄毅">
  <meta name="keywords" content="">
  
    <meta name="description" content="前言 学习本文需要一些了解Docker的概念以及一些名词。  一、Docker概述1、Docker简介Docker 镜像是通过读取Dockerfile来构建镜像文件的。Dockerfile是一个文本文档，它包含用户可以在命令行上调用的所有命令来组装镜像，每条指令都是独立运行的，并会创建一个新的镜像层 。使用docker build 命令用户用户可以创建一个自动构建，该构建可以连续执行几个命令行指令">
<meta property="og:type" content="article">
<meta property="og:title" content="Dockerfile概述与用法">
<meta property="og:url" content="https://gopherlinzy.github.io/2022/09/06/docker-Dockerfile/index.html">
<meta property="og:site_name" content="linzy">
<meta property="og:description" content="前言 学习本文需要一些了解Docker的概念以及一些名词。  一、Docker概述1、Docker简介Docker 镜像是通过读取Dockerfile来构建镜像文件的。Dockerfile是一个文本文档，它包含用户可以在命令行上调用的所有命令来组装镜像，每条指令都是独立运行的，并会创建一个新的镜像层 。使用docker build 命令用户用户可以创建一个自动构建，该构建可以连续执行几个命令行指令">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gopherlinzy.github.io/img/docker.jpg">
<meta property="article:published_time" content="2022-09-06T02:40:26.000Z">
<meta property="article:modified_time" content="2022-09-06T02:56:22.783Z">
<meta property="article:author" content="孙禄毅">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="Docker">
<meta property="article:tag" content="go">
<meta property="article:tag" content="容器">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="云原生">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gopherlinzy.github.io/img/docker.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Dockerfile概述与用法 - linzy</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"gopherlinzy.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":true,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>LinzyBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/pkg8.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Dockerfile概述与用法"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-06 10:40" pubdate>
          2022年9月6日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          138 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Dockerfile概述与用法</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：9 个月前
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>学习本文需要一些了解Docker的概念以及一些名词。</p>
</blockquote>
<h1 id="一、Docker概述"><a href="#一、Docker概述" class="headerlink" title="一、Docker概述"></a>一、Docker概述</h1><h2 id="1、Docker简介"><a href="#1、Docker简介" class="headerlink" title="1、Docker简介"></a>1、Docker简介</h2><p><code>Docker 镜像是通过读取Dockerfile来构建镜像文件的</code>。Dockerfile是一个文本文档，它包含用户可以在命令行上调用的所有命令来组装镜像，<code>每条指令都是独立运行的，并会创建一个新的镜像层 </code>。使用docker build 命令用户用户可以创建一个自动构建，该构建可以连续执行几个命令行指令。</p>
<h2 id="2、为什么要用Dockerfile？"><a href="#2、为什么要用Dockerfile？" class="headerlink" title="2、为什么要用Dockerfile？"></a>2、为什么要用Dockerfile？</h2><p>为什么要用Dockerfile？这个问题的本身其实是说为什么我们要自定义镜像，明明Docker Hub上有这么多镜像可以用，我们还要自己费心思做镜像。</p>
<p><img src="/img/docker_Dockerfile/docker1.png"></p>
<p><img src="/img/docker_Dockerfile/docker2.png"></p>
<blockquote>
<p>主要原因：Docker Hub上许多官方镜像只是基础包，很多功能都没有，需要我们自己对官方镜像做扩展，以打包成我们生产应用的镜像。<br>参考我的第一篇文章Docker入门篇：《<a target="_blank" rel="noopener" href="https://linzyblog.netlify.app/2022/08/15/docker-begin/">Docker的入门与安装</a>》</p>
</blockquote>
<h1 id="二、docker-build工作原理"><a href="#二、docker-build工作原理" class="headerlink" title="二、docker build工作原理"></a>二、docker build工作原理</h1><h2 id="1、镜像构建过程"><a href="#1、镜像构建过程" class="headerlink" title="1、镜像构建过程"></a>1、镜像构建过程</h2><p>docker build命令从 Dockerfile 和 context 构建一个镜像。构建的 context 是位于指定位置PATH或URL的一组文件。PATH是本地文件系统上的一个目录。URL是Git存储库位置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build [OPTIONS] PATH | URL | -<br></code></pre></td></tr></table></figure>
<p>完整的镜像架构图：<br><img src="/img/docker_Dockerfile/docker3.png"><br><code>构建context是递归处理的。每条指令都是独立运行的，并会创建一个新的镜像层。 </code></p>
<p>例子中docker build后面使用(.)表示当前目录，作为指定context的路径:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build .</span><br><br>Send build context to Docker daemon 6.51MB<br>...<br></code></pre></td></tr></table></figure>
<p><code>构建由 Docker 守护程序运行，而不是由 CLI 运行</code>。构建过程所做的第一件事是将整个 context（递归）发送到守护进程。</p>
<h2 id="2、context-上下文"><a href="#2、context-上下文" class="headerlink" title="2、context(上下文)"></a>2、context(上下文)</h2><p><code>Docker使用客户端-服务器架构</code>。Docker客户端 与 Docker守护进程 通信，守护进程 负责构建、运行和分发Docker容器。Docker客户端 和 守护进程 可以运行在同一个系统上，或者将 Docker客户端 连接到远程的Docker守护进程。<code>Docker客户端 和 守护进程 通过UNIX套接字或网络接口使用REST API进行通信</code>。另一个 Docker客户端 是Docker Compose，它允许使用由一组容器组成的应用程序。</p>
<p> Docker客户端(Docker) 是许多Docker用户与Docker交互的主要方式。使用docker 命令时，则是通过docker API 与 Docker守护进程进行<strong>交互</strong>，从而完成各种功能，Docker客户端 可以与多个 守护进程 通信。因此，<code>虽然表面上我们是在本机执行各种 docker 功能，但实际上，客户端会将这些命令发送到 Docker守护进程 执行它们</code>。也因为这种 C&#x2F;S 设计，让我们操作远程服务器的 Docker守护进程 变得轻而易举。</p>
<p>当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker守护进程构建的。</p>
<blockquote>
<p>那么在这种客户端&#x2F;服务端的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了<code>context(上下文)</code>的概念。当构建的时候，用户会指定构建镜像<code>context(上下文)</code>的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker守护进程。这样Docker守护进程收到这个<code>context(上下文)</code>包后，展开就会获得构建镜像所需的一切文件。</p>
</blockquote>
<p><img src="/img/docker_Dockerfile/docker4.png"><br>如果要在构建上下文中使用文件，Dockerfile引用指令中指定的文件，例如COPY指令。<code>要提高构建的性能，可以通过在context目录中添加.dockerignore文件来排除文件和目录。</code></p>
<p>传统上，Dockerfile位于上下文的根目录中。实际上，Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，在docker build中使用-f标志来指向文件系统中的任何位置的Dockerfile。</p>
<p><code>一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</code></p>
<blockquote>
<p>注意：不要将根目录<code>/</code>用作PATH构建上下文，因为它会导致构建将硬盘驱动器的全部内容传输到 Docker 守护程序。</p>
</blockquote>
<h1 id="三、Dockerfile指令"><a href="#三、Dockerfile指令" class="headerlink" title="三、Dockerfile指令"></a>三、Dockerfile指令</h1><h2 id="1、约定"><a href="#1、约定" class="headerlink" title="1、约定"></a>1、约定</h2><ol>
<li><code>指令必须大写</code>，以便更容易地将它们与参数区分开来。</li>
<li><code>Dockerfile必须以FROM指令开始</code> 。</li>
<li>以# 开头视为注释。</li>
</ol>
<h2 id="2、FROM"><a href="#2、FROM" class="headerlink" title="2、FROM"></a>2、FROM</h2><ul>
<li>作用：指定基础镜像，Dockerfile必须以FROM指令开始。</li>
<li>格式：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>(1)	FROM [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]<br>(2)	FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]<br>(3)	FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]<br><br>解释：<br>	[--platform=&lt; platform &gt;]：如果引用多平台镜像，可选 --platform 标志可用于指定镜像的平台。<br>	[AS &lt;name&gt;]：通过向FROM指令添加AS name，可以为新的构建阶段指定一个名称。<br><br>注：<br>   tag或digest是可选的，如果不使用这两个值时，会使用latest版本的基础镜像<br>   <br>示例：<br>	FROM centos<br></code></pre></td></tr></table></figure>

<ul>
<li>说明：</li>
</ul>
<p><code>Docker Hub中的大部分镜像都是从基础镜像 FROM scratch构建的，在基础镜像之上构建软件和配置</code>。FROM指令初始化一个新的构建阶段，并为后续指令设置基本镜像。因此，一个有效的Dockerfile必须以一个FROM指令开始。</p>
<p>镜像可以是任何有效的镜像—从Docker Hub提取镜像尤其容易。</p>
<h2 id="3、RUN"><a href="#3、RUN" class="headerlink" title="3、RUN"></a>3、RUN</h2><ul>
<li>作用：构建镜像时需要执行的命令</li>
<li>格式：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>shell形式(命令运行在shell中，Linux默认为/bin/sh -c, Windows默认为cmd /S /C)<br>(1)	RUN &lt;command&gt;<br>	<br>exec形式(exec形式可以避免shell字符串混杂，并使用不包含指定的shell可执行文件的基本镜像运行命令)<br>(2)	RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]<br><br>注：<br>	RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。<br><br>示例：<br>	RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]<br>    RUN apk update<br>    RUN [&quot;/etc/execfile&quot;, &quot;arg1&quot;, &quot;arg1&quot;]<br></code></pre></td></tr></table></figure>

<ul>
<li>说明：</li>
</ul>
<p>镜像构建的时候需要运行的命令，有两种命令执行方式。RUN指令将在当前镜像之上的新层中执行任何命令并提交结果。生成的提交镜像将用于Dockerfile。</p>
<blockquote>
<p>注意：在下一次构建期间，<code>RUN</code>指令的缓存不会自动失效。像<code>RUN apt-get distupgrade -y</code>这样的指令的缓存将在下一次构建期间被重用。RUN指令的缓存可以通过使用<code>--no-cache</code>标志来失效，例如<code>docker build——no-cache</code>。</p>
</blockquote>
<h2 id="4、CMD"><a href="#4、CMD" class="headerlink" title="4、CMD"></a>4、CMD</h2><ul>
<li>作用：在构建镜像之后调用，容器启动时调用命令</li>
<li>格式：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>(1)	CMD [&quot;executable&quot;，&quot;param1&quot;，&quot;param2&quot;] (exec形式，这是首选形式)<br>(2)	CMD [&quot;param1&quot;，&quot;param2&quot;](作为ENTRYPOINT的默认参数)<br>(3)	CMD command param1 param2(shell形式)<br>	<br>注：<br>	Dockerfile中只能有一个CMD指令。如果列出多个CMD，则只有最后一个CMD生效。<br><br>示例：<br>	FROM ubuntu<br>	CMD echo &quot;This is a test.&quot; | wc -<br><br>	FROM ubuntu<br>	CMD [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]<br></code></pre></td></tr></table></figure>

<ul>
<li>说明：</li>
</ul>
<p>CMD的主要目的是<code>为容器提供默认的执行命令。</code>包括可执行文件，也可以省略可执行文件，在这种情况下，您必须同时指定一个ENTRYPOINT指令。</p>
<blockquote>
<p>注意：<br><code>CMD</code>不同于<code>RUN</code>，<code>CMD</code>在构建时不执行任何操作，<code>CMD</code>是容器启动时执行的指令，<code>RUN</code>是镜像构建时执行的指令。</p>
</blockquote>
<h2 id="5、ENTRYPOINT"><a href="#5、ENTRYPOINT" class="headerlink" title="5、ENTRYPOINT"></a>5、ENTRYPOINT</h2><ul>
<li>作用：在构建镜像之后调用，容器启动时调用命令</li>
<li>格式：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>(1)	ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;](exec形式，这是首选形式)<br>(2)	ENTRYPOINT command param1 param2(shell形式)<br><br>注：<br>	指定 ENTRYPOINT 指令为 exec 模式时，命令行上指定的参数会作为参数添加到 ENTRYPOINT 指定命令的参数列表中。<br><br>示例：<br>	FROM ubuntu<br>	ENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]<br>	CMD [&quot;-c&quot;]<br></code></pre></td></tr></table></figure>

<ul>
<li>说明：</li>
</ul>
<p>ENTRYOINT与CMD作用一样，都是在容器运行时执行命令，两者都是重要的指令。</p>
<blockquote>
<p>注意：<br><code>ENTRYPOINT</code>与<code>CMD</code>非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给CMD。<br><code>Dockerfile中只允许有一个ENTRYPOINT命令</code>，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令。<br>通常情况下，	ENTRYPOINT 与CMD一起使用，ENTRYPOINT 写默认命令，当需要参数时候 使用CMD传参。</p>
</blockquote>
<h2 id="6、CMD-vs-ENTRYPOINT"><a href="#6、CMD-vs-ENTRYPOINT" class="headerlink" title="6、CMD vs ENTRYPOINT"></a>6、CMD vs ENTRYPOINT</h2><p>《<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#entrypoint">Docker官方文档</a>》<br>《<a target="_blank" rel="noopener" href="https://blog.csdn.net/hhd1988/article/details/109223849?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166234481916782244857786%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166234481916782244857786&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-109223849-null-null.142%5Ev46%5Epc_rank_34_default_3&utm_term=ENTRYPOINT&spm=1018.2226.3001.4187">Dockerfile 的 CMD 与 ENTRYPOINT 傻傻分不清楚</a>》<br>《<a target="_blank" rel="noopener" href="http://www.johnzaccone.io/entrypoint-vs-cmd-back-to-basics/">ENTRYPOINT vs CMD: Back to Basics</a>》</p>
<h2 id="7、LABEL"><a href="#7、LABEL" class="headerlink" title="7、LABEL"></a>7、LABEL</h2><ul>
<li>作用：LABEL指令向镜像添加元数据。</li>
<li>格式：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>	LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...<br><br>注：<br>	一个镜像可以有多个标签，可以在一行中指定多个标签。<br><br>示例：<br>一条指令中指定多个标签：<br>(1)	LABEL multi.label1=&quot;value1&quot; multi.label2=&quot;value2&quot; other=&quot;value3&quot;<br>(2)	LABEL multi.label1=&quot;value1&quot; \<br>      multi.label2=&quot;value2&quot; \<br>      other=&quot;value3&quot;<br><br></code></pre></td></tr></table></figure>
<ul>
<li>说明：</li>
</ul>
<p>LABEL指令向镜像添加元数据。LABEL是一个<code>键-值对</code>。要在LABEL值中包含空格，请在命令行解析中那样使用引号和反斜杠。</p>
<blockquote>
<p>注意：<br>基础或父镜像（FROM行中的镜像）中包含的标签由你的镜像继承。如果标签已存在但具有不同的值，则<code>最近应用的值将覆盖任何先前设置的值</code>。</p>
</blockquote>
<h2 id="8、MAINTAINER-已弃用"><a href="#8、MAINTAINER-已弃用" class="headerlink" title="8、MAINTAINER (已弃用)"></a>8、MAINTAINER (已弃用)</h2><ul>
<li>作用：MAINTAINER指令设置生成的镜像的作者信息。</li>
<li>格式：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>	MAINTAINER &lt;name&gt;<br>	<br>示例：<br>    MAINTAINER linzy<br>    MAINTAINER xxx@qq.com<br>    MAINTAINER linzy &lt;xxx@qq.com&gt;<br></code></pre></td></tr></table></figure>

<h2 id="9、EXPOSE"><a href="#9、EXPOSE" class="headerlink" title="9、EXPOSE"></a>9、EXPOSE</h2><ul>
<li>作用：EXPOSE指令告诉Docker容器在运行时<code>监听指定的网口</code>。</li>
<li>格式：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>	EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]<br><br>注：<br>	EXPOSE指令实际上并不发布端口。它在构建镜像的人和运行容器的人之间充当一种文档，说明哪些端口将被发布。<br>	要在运行容器时真正发布端口，需要在docker run运行容器时通过-p来发布这些端口，或通过-P参数来发布EXPOSE导出的所有端口。<br>	<br>示例：<br>	EXPOSE 8080<br>	<br>同时在 TCP 和 UDP 上公开：<br>	EXPOSE 80/tcp<br>	EXPOSE 80/udp	<br></code></pre></td></tr></table></figure>

<ul>
<li>说明：</li>
</ul>
<p>EXPOSE指令告诉Docker容器在运行时监听指定的网口。可以指定端口侦听的协议类型是TCP还是UDP，<code>如果不指定协议类型，默认为TCP</code>。</p>
<blockquote>
<p>注意：<br>如果没有发布端口，后期也可以通过-p 8080:80方式映射端口，但是不能通过-P形式映射</p>
</blockquote>
<h2 id="10、ENV"><a href="#10、ENV" class="headerlink" title="10、ENV"></a>10、ENV</h2><ul>
<li>作用：ENV指令将设置环境变量。</li>
<li>格式：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>	ENV &lt;key&gt; &lt;value&gt;  <br><span class="hljs-meta prompt_">	#</span><span class="language-bash">&lt;key&gt;之后的所有内容均会被视为其&lt;value&gt;的组成部分，因此，一次只能设置一个变量。</span><br>    ENV &lt;key&gt;=&lt;value&gt; ...  <br>    #可以设置多个变量，每个变量为一个&quot;&lt;key&gt;=&lt;value&gt;&quot;的键值对。<br><br>注：<br>	如果&lt;key&gt;中包含空格，可以使用\来进行转义，也可以通过&quot;&quot;来进行标示；另外，反斜线也可以用于续行。<br>示例：<br>	ENV MY_NAME=&quot;linzy&quot;<br>	ENV MY_DOG=Wang\ Cai<br>	ENV MY_CAT=Mei\ Lao\ Ban<br></code></pre></td></tr></table></figure>

<ul>
<li>说明：</li>
</ul>
<p><code>ENV</code>当容器从生成的图像运行时，使用ENV设置的环境变量将一直存在。你可以使用 <code>docker inspect</code>查看这些值，并使用 <code>docker run --env &lt; key &gt;=&lt; value &gt;</code> 更改它们。</p>
<blockquote>
<p>注意：<br><code>ENV</code>指令还允许使用另一种语法<code>ENV &lt; key &gt; &lt; value &gt;</code>，省略<code>=</code>，例如：<br>ENV MY_VAR my-value</p>
</blockquote>
<h2 id="11、ADD"><a href="#11、ADD" class="headerlink" title="11、ADD"></a>11、ADD</h2><ul>
<li>作用：将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget。</li>
<li>格式：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>(1)	ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;<br>(2)	ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]<br><br>注：<br>	该--chown功能仅在用于构建 Linux 容器的 Dockerfile 上受支持，不适用于 Windows 容器。由于用户和组所有权概念不能在 Linux 和 Windows 之间转换，因此使用/etc/passwd并/etc/group用于将用户和组名转换为 ID 会限制此功能仅适用于基于 Linux 操作系统的容器。<br><br>示例：<br>	ADD hom* /mydir/ # 添加所有以“hom”开头的文件<br>	ADD hom?.txt /mydir/ # ?替换为任何单个字符，例如“home.txt”。<br>	ADD test.txt relativeDir/ # 使用相对路径，将“test.txt”添加到&lt;WORKDIR&gt;/relativeDir/<br>	ADD test.txt /absoluteDir/ # 使用绝对路径，将“test.txt”添加到/absoluteDir/<br></code></pre></td></tr></table></figure>

<ul>
<li>说明：</li>
</ul>
<p>该<code>ADD</code>指令从<code>&lt;src&gt;</code>路径复制新文件、目录或远程文件 URL，并将它们添加到镜像的文件系统中<code>&lt;dest&gt;</code>。<code>&lt;src&gt;</code>可以指定多个资源，但如果它们是文件或目录，则它们的路径被解释为相对于构建context(上下文)的源。</p>
<blockquote>
<p><strong>ADD遵守以下规则</strong>：</p>
<ol>
<li><code>&lt;src&gt;</code>路径必须在构建的上下文中；你不能<code>ADD ../something /something</code>，因为<code>docker build</code>的第一步是将上下文目录（和子目录）发送到 docker 守护进程。</li>
<li>如果<code>&lt;src&gt;</code>是一个URL，且<code>&lt;dest&gt;</code>不是以斜杠结尾，则从该URL下载文件并复制到<code>&lt;dest&gt;</code>。</li>
<li>如果<code>&lt;src&gt;</code>是一个URL，且<code>&lt;dest&gt;</code>是以斜杠结尾，则从 URL 推断文件名并将文件下载到 <code>&lt;dest&gt;/&lt;filename&gt;</code>.。例如：<code>ADD http://example.com/foobar /</code>将创建文件<code>/foobar</code>。 URL 必须有一个重要的路径，以便在这种情况下可以找到适当的文件名（<code>http://example.com</code> 将不起作用）。</li>
<li>如果<code>&lt;src&gt;</code>是目录，则复制目录的全部内容，包括文件系统元数据。</li>
<li>如果<code>&lt;src&gt;</code>是可识别压缩格式（identity、gzip、bzip2 或 xz）的本地tar 存档，则将其解压缩为目录。<code>来自远程URL 的资源不会被解压缩</code>。当一个目录被复制或解包时，它的行为与 相同<code>tar -x</code>。<br> - 文件是否被识别为可识别的压缩格式完全取决于文件的内容，而不是文件的名称。例如，如果一个空文件恰好以此结尾，<code>.tar.gz</code>则不会被识别为压缩文件，也不会生成任何类型的解压缩错误消息，而是将文件简单地复制到目标位置。</li>
<li>如果<code>&lt;src&gt;</code>是任何其他类型的文件，它将与它的元数据一起被单独复制。在这种情况下，如果<code>&lt;dest&gt;</code>以斜杠结尾&#x2F;，它将被视为一个目录，其内容<code>&lt;src&gt;</code>将写入<code>&lt;dest&gt;/base(&lt;src&gt;)</code>。</li>
<li><code>&lt;src&gt;</code>直接指定了多个资源，或者使用了通配符，则<code>&lt;dest&gt;</code>必须是目录，并且必须以斜杠结尾<code>/</code>。</li>
<li>如果<code>&lt;dest&gt;</code>不以斜杠结尾，它将被认为是一个普通文件，其<code>&lt;src&gt;</code>的内容将写入<code>&lt;dest&gt;</code>。</li>
<li>如果<code>&lt;dest&gt;</code>不存在，它会连同其路径中所有缺失的目录一起创建。</li>
</ol>
</blockquote>
<h2 id="12、COPY"><a href="#12、COPY" class="headerlink" title="12、COPY"></a>12、COPY</h2><ul>
<li>作用：将本地文件添加到容器中，但是是不会自动解压文件，也不能访问网络资源。</li>
<li>格式：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>(1)	COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;<br>(2)	COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]<br><br>注：<br>	该--chown功能仅在用于构建 Linux 容器的 Dockerfile 上受支持，不适用于 Windows 容器。<br><br>示例：<br>	COPY hom* /mydir/ # 添加所有以“hom”开头的文件<br>	COPY hom?.txt /mydir/ # ?替换为任何单个字符，例如“home.txt”<br>	COPY test.txt relativeDir/ # 使用相对路径，并将“test.txt”添加到&lt;WORKDIR&gt;/relativeDir/<br>	COPY test.txt /absoluteDir/ # 使用绝对路径，并将“test.txt”添加到/absoluteDir/<br></code></pre></td></tr></table></figure>

<ul>
<li>说明：</li>
</ul>
<p>COPY指令从路径复制新文件或目录<code>&lt;src&gt;</code> 并将它们添加到容器的文件系统中<code>&lt;dest&gt;</code>。<code>&lt;src&gt;</code>可以指定多个资源，但文件和目录的路径将被解释为相对于构建上下文的源。</p>
<blockquote>
<p><strong>COPY遵守以下规则</strong>：</p>
<ol>
<li><code>&lt;src&gt;</code>路径必须在构建的上下文中；你不能<code>ADD ../something /something</code>，因为<code>docker build</code>的第一步是将上下文目录（和子目录）发送到 docker 守护进程。</li>
<li>如果<code>&lt;src&gt;</code>是目录，则复制目录的全部内容，包括文件系统元数据。</li>
<li>如果<code>&lt;src&gt;</code>是任何其他类型的文件，它将与它的元数据一起被单独复制。在这种情况下，如果<code>&lt;dest&gt;</code>以斜杠结尾&#x2F;，它将被视为一个目录，其内容<code>&lt;src&gt;</code>将写入<code>&lt;dest&gt;/base(&lt;src&gt;)</code>。</li>
<li><code>&lt;src&gt;</code>直接指定了多个资源，或者使用了通配符，则<code>&lt;dest&gt;</code>必须是目录，并且必须以斜杠结尾<code>/</code>。</li>
<li>如果<code>&lt;dest&gt;</code>不以斜杠结尾，它将被认为是一个普通文件，其<code>&lt;src&gt;</code>的内容将写入<code>&lt;dest&gt;</code>。</li>
<li>如果<code>&lt;dest&gt;</code>不存在，它会连同其路径中所有缺失的目录一起创建。</li>
</ol>
</blockquote>
<h2 id="13、VOLUME"><a href="#13、VOLUME" class="headerlink" title="13、VOLUME"></a>13、VOLUME</h2><ul>
<li>作用：用于指定持久化目录（指定此目录可以被挂载出去）</li>
<li>格式：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>	VOLUME [&quot;/data&quot;]<br><br>注：<br>	卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：<br>	1.卷可以容器间共享和重用<br>	2.容器并不一定要和其它容器共享卷<br>	3.修改卷后会立即生效<br>	4.对卷的修改不会对镜像产生影响<br>	5.卷会一直存在，直到没有容器在使用它<br>	6.卷可以在 Linux 和 Windows 容器上运行。<br>	<br>示例：<br>	VOLUME [&quot;/data&quot;]<br>    VOLUME [&quot;/var/mysql&quot;, &quot;/var/log/mysql&quot;, &quot;/etc/mysql&quot;]<br>    <br>	FROM ubuntu<br>	RUN mkdir /myvol<br>	RUN echo &quot;hello world&quot; &gt; /myvol/greeting<br>	VOLUME /myvol<br></code></pre></td></tr></table></figure>

<ul>
<li>说明：</li>
</ul>
<p>VOLUME指令创建具有指定名称的挂载点，并将其标记为保存来自本机主机或其他容器的外部挂载卷。<br>参考<a target="_blank" rel="noopener" href="https://linzyblog.netlify.app/2022/08/31/docker-volumes/">《Docker卷(volumes)》</a></p>
<blockquote>
<p><strong>关于指定卷的注意事项：</strong></p>
<ol>
<li><code>基于 Windows 的容器上的卷</code>：使用基于 Windows 的容器时，容器内卷的目标必须是以下之一：<br> - 不存在或为空的目录<br> - C盘以外的驱动器</li>
<li><code>从 Dockerfile 中更改卷</code>：如果任何构建步骤在声明卷后更改了卷中的数据，则这些更改将被丢弃。</li>
<li><code>JSON 格式</code>：列表被解析为 JSON 数组。必须用双引号 ( “) 而不是单引号 ( ‘) 将单词括起来。</li>
<li><code>主机目录在容器运行时声明</code>：主机目录（挂载点）本质上是依赖于主机的。这是为了保持镜像的可移植性，因为不能保证给定的主机目录在所有主机上都可用。由于这个原因，你不能从Dockerfile内挂载主机目录。<code>VOLUME</code>指令不支持指定<code>host-dir</code>参数。<code>在创建或运行容器时，必须指定挂载点</code>。</li>
</ol>
</blockquote>
<h2 id="14、USER"><a href="#14、USER" class="headerlink" title="14、USER"></a>14、USER</h2><ul>
<li>作用：设置用户名（或 UID）和可选的用户组（或 GID）。</li>
<li>格式：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>(1)	USER &lt;user&gt;[:&lt;group&gt;]<br>(2)	USER &lt;UID&gt;[:&lt;GID&gt;]<br><br>注：<br>	使用USER指定用户后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT都将使用该用户。<br>　　镜像构建完成后，通过docker run运行容器时，可以通过-u参数来覆盖所指定的用户。<br><br>示例：<br>	USER linzy<br></code></pre></td></tr></table></figure>

<ul>
<li>说明：</li>
</ul>
<p>指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。使用USER指定用户时，可以使用用户名、UID或GID，或是两者的组合。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户。</p>
<blockquote>
<p>注意：<br>在 Windows 上，如果用户不是内置帐户，则必须先创建用户。这可以通过net user作为 Dockerfile 的一部分调用的命令来完成。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM microsoft/windowsservercore<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Create Windows user <span class="hljs-keyword">in</span> the container</span><br>RUN net user /add linzy<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Set it <span class="hljs-keyword">for</span> subsequent commands</span><br>USER linzy<br></code></pre></td></tr></table></figure>

<h2 id="15、WORKDIR"><a href="#15、WORKDIR" class="headerlink" title="15、WORKDIR"></a>15、WORKDIR</h2><ul>
<li>作用：设置工作目录。</li>
<li>格式：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>	WORKDIR /path/to/workdir<br><br>注：<br>	通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行。<br>	在使用docker run运行容器时，可以通过-w参数覆盖构建时所设置的工作目录。<br><br>示例：<br>	WORKDIR /a  (这时工作目录为/a)<br>    WORKDIR b  (这时工作目录为/a/b)<br>    WORKDIR c  (这时工作目录为/a/b/c)<br>	RUN pwd # 最终pwd命令的输出Dockerfile将是/a/b/c.<br></code></pre></td></tr></table></figure>
<ul>
<li>说明：</li>
</ul>
<p><code>WORKDIR</code>设置工作目录，类似于cd命令。设置工作目录后，Dockerfile中其后的命令<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>、<code>ADD</code>、<code>COPY</code>等命令都会在该目录下执行。如果不存在，即使它没有在任何后续指令中使用，它也会被创建。</p>
<blockquote>
<p>注意：<br>Dockerfile里<code>WORKDIR</code>指令使用之前设置的环境变量 <code>ENV</code>，例如：</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ENV DIRPATH=/path<br>WORKDIR <span class="hljs-variable">$DIRPATH</span>/<span class="hljs-variable">$DIRNAME</span><br>RUN <span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>最终<code>pwd</code>命令的输出Dockerfile将是 <code>/path/$DIRNAME</code>。<br>如果未指定，默认工作目录为<code>/</code>。在实践中，如果你不是从头开始构建Dockerfile, <code>WORKDIR</code>可能由你正在使用的基础镜像设置。<br>因此，为了避免在未知目录中进行意外操作，<code>最好是显式设置WORKDIR</code>。</p>
</blockquote>
<h2 id="16、ARG"><a href="#16、ARG" class="headerlink" title="16、ARG"></a>16、ARG</h2><ul>
<li>作用：用于指定传递给构建运行时的变量(给Dockerfile传参)，相当于构建镜像时可以在外部为里面传参</li>
<li>格式：</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell">格式：<br>	ARG &lt;name&gt;[=&lt;<span class="hljs-type">default</span> <span class="hljs-type">value</span>&gt;]<br><br>注：<br>	<span class="hljs-literal">--build-arg</span> &lt;varname&gt;=&lt;value&gt; 将变量传递给构建器。如果用户指定了未在Dockerfile中定义的构建参数，那么构建将输出一个警告。<br><br>示例：<br>	FROM busybox<br>	ARG user1<br>	ARG buildno<br>	<span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure>

<ul>
<li>说明：</li>
</ul>
<p><code>ARG</code>指令定义了一个变量，用户可以在构建时通过使用 标志的<code>docker build</code>命令将其传递给构建器。</p>
<blockquote>
<p>注意：<br><code>不建议使用构建时变量来传递 github 密钥、用户凭据等机密信息</code>。使用该<code>docker history</code>命令的映像的任何用户都可以看到构建时变量值。</p>
</blockquote>
<h3 id="1）默认值"><a href="#1）默认值" class="headerlink" title="1）默认值"></a>1）默认值</h3><p><code>ARG</code>指令可以设置默认值：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">FROM busybox<br>ARG user1=someuser<br>ARG buildno=<span class="hljs-number">1</span><br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure>
<p>如果<code>ARG</code>指令具有默认值并且在构建时没有传递任何值，则构建器将使用默认值。</p>
<h3 id="2）使用-ARG-变量"><a href="#2）使用-ARG-变量" class="headerlink" title="2）使用 ARG 变量"></a>2）使用 ARG 变量</h3><p>可以使用<code>ARG</code>或<code>ENV</code>指令指定<code>RUN</code>指令可用的变量。使用<code>ENV</code>指令定义的环境变量总是覆盖同名的<code>ARG</code>指令。</p>
<p>带有<code>ENV</code> 和 <code>ARG</code>指令的 <code>Dockerfile</code> 例子：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">FROM ubuntu<br>ARG CONT_IMG_VER<br>ENV CONT_IMG_VER=v1.<span class="hljs-number">0.0</span><br>RUN <span class="hljs-built_in">echo</span> <span class="hljs-variable">$CONT_IMG_VER</span><br></code></pre></td></tr></table></figure>
<p>镜像是用这个命令构建的：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker build <span class="hljs-literal">--build-arg</span> CONT_IMG_VER=v2.<span class="hljs-number">0.1</span> .<br></code></pre></td></tr></table></figure>

<p><code>RUN</code>指令使用v1.0.0而不是<code>ARG</code>用户传递的设置。</p>
<h2 id="17、ONBUILD"><a href="#17、ONBUILD" class="headerlink" title="17、ONBUILD"></a>17、ONBUILD</h2><ul>
<li>作用：向镜像添加了一条触发指令。</li>
<li>格式：</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">格式：<br>	ONBUILD &lt;INSTRUCTION&gt;<br><br>注：<br>	任何构建指令都可以注册为触发器。<br><br>示例：<br>	ONBUILD ADD . /app/src<br>	ONBUILD RUN /usr/local/bin/python<span class="hljs-literal">-build</span> <span class="hljs-literal">--dir</span> /app/src<br></code></pre></td></tr></table></figure>

<ul>
<li>说明：</li>
</ul>
<p>ONBUILD指令向镜像添加了一条触发指令。</p>
<p>NNBUID后面跟指令，当该镜像被用作另一个构建的基础镜像时，触发器将在其构建的上下文中执行。<code>就好像它是FROM 在指令之后立即插入的一样Dockerfile。</code></p>
<p>如果你正在构建一个镜像，该镜像将用作构建其他镜像的基础，例如可以特定于用户的配置定制的应用程序构建环境或守护进程。</p>
<blockquote>
<p>注意：<br><code>ONBUILD</code>指令可能不会触发<code>FROM</code>或<code>MAINTAINER</code>指令。</p>
</blockquote>
<h2 id="18、Dockerfile常用指令"><a href="#18、Dockerfile常用指令" class="headerlink" title="18、Dockerfile常用指令"></a>18、Dockerfile常用指令</h2><p><img src="/img/docker_Dockerfile/docker5.png"></p>
<table>
<thead>
<tr>
<th>指令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td align="left">构建新镜像使用的基础镜像</td>
</tr>
<tr>
<td>MAINTAINER（已弃用）</td>
<td align="left">构建镜像的作者或邮件地址</td>
</tr>
<tr>
<td>RUN</td>
<td align="left">构建镜像时执行命令</td>
</tr>
<tr>
<td>COPY</td>
<td align="left">拷贝文件或目录到镜像中</td>
</tr>
<tr>
<td>ENV</td>
<td align="left">设置环境变量</td>
</tr>
<tr>
<td>USER</td>
<td align="left">为RUN、CMD和ENTRYPOINT等执行命令指定运行用户</td>
</tr>
<tr>
<td>EXPOSE</td>
<td align="left">声明容器运行的服务端口</td>
</tr>
<tr>
<td>WORKDIR</td>
<td align="left">为RUN、CMD、ENTRYPOINT、COPY和ADD设置工作目录</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td align="left">运行容器时执行，如果由多个ENTRYPOINT指令，最后一个生效，可以追加命令</td>
</tr>
<tr>
<td>CMD</td>
<td align="left">运行容器时执行，如果由多个CMD 指令，最后一个生效，可被替代</td>
</tr>
<tr>
<td>LABEL</td>
<td align="left">设置镜像的标签</td>
</tr>
<tr>
<td>VOLUME</td>
<td align="left">设置容器的挂载卷</td>
</tr>
<tr>
<td>ARG</td>
<td align="left">指令定义了一个变量</td>
</tr>
<tr>
<td>ONBUILD</td>
<td align="left">向镜像添加了一条触发指令</td>
</tr>
</tbody></table>
<h1 id="四、构建自己的镜像"><a href="#四、构建自己的镜像" class="headerlink" title="四、构建自己的镜像"></a>四、构建自己的镜像</h1><h2 id="1、构建镜像步骤"><a href="#1、构建镜像步骤" class="headerlink" title="1、构建镜像步骤"></a>1、构建镜像步骤</h2><p>构建镜像步骤：</p>
<ol>
<li>编写一个<code>Dockerfile</code> 文件</li>
<li>通过 <code>docker build</code> 命令构建成一个镜像</li>
<li><code>docker run</code> 命令运行镜像</li>
<li><code>docker push</code> 命令发布镜像到<code>Docker Hub</code></li>
</ol>
<blockquote>
<p>注意：</p>
<ul>
<li>如果有多个<code>RUN</code>,自上而下依次运行，每次运行都会形成新的层，建议&amp;&amp; 放入一行运行</li>
<li>如果有多个<code>CMD</code>,只有最后一个运行</li>
<li>如果有多个<code>ENTRYPOINT</code> ，只有最后一个运行</li>
<li>如果<code>CMD</code>和<code>ENTRYPOINT</code>共存，只有<code>ENTRYPOINT</code> 运行，且最后的<code>CMD</code>会当做<code>ENTRYPOINT</code> 的参数</li>
</ul>
</blockquote>
<h2 id="2、编写Dockerfile文件"><a href="#2、编写Dockerfile文件" class="headerlink" title="2、编写Dockerfile文件"></a>2、编写Dockerfile文件</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 基础镜像</span><br>FROM centos<br><br><span class="hljs-comment">#MAINTAINER 维护者信息</span><br>MAINTAINER linzy&lt;<span class="hljs-number">2350621012</span>@qq.com&gt;<br><br><span class="hljs-comment">#ENV 设置环境变量</span><br>ENV MYPATH /usr/local<br><br><span class="hljs-comment">#WORKDIR 相当于cd</span><br>WORKDIR <span class="hljs-variable">$MYPATH</span><br><br><span class="hljs-comment">#RUN 执行命令</span><br>RUN yum <span class="hljs-literal">-y</span> install vim <br>RUM yum <span class="hljs-literal">-y</span> install net<span class="hljs-literal">-tools</span><br><br><span class="hljs-comment">#EXPOSE 映射端口</span><br>EXPOSE <span class="hljs-number">80</span><br><br><span class="hljs-comment">#CMD 运行命令</span><br>CMD <span class="hljs-built_in">echo</span> <span class="hljs-variable">$MYPATH</span><br>CMD <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----end----&quot;</span><br>CMD /bin/bash<br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>逐行解释该<code>Dockerfile</code>文件的指令：</p>
<ol>
<li><code>FROM centos</code> ：该image文件继承官方的centos，他会先在你本地寻找centos镜像</li>
<li><code>ENV MYPATH /usr/local</code>：设置环境变量MYPATH</li>
<li><code>WORKDIR $MYPATH</code>：直接使用上面设置的环境变量，指定&#x2F;usr&#x2F;local为工作目录</li>
<li><code>RUN yum -y install vim &amp;&amp; RUM yum -y install net-tools</code>：在&#x2F;usr&#x2F;local目录下，运行yum -y install vim和yum -y install net-tools命令安装工具，注意安装后的所有依赖和工具都会打包到image文件中</li>
<li><code>EXPOSE 80</code>·：将容器80端口暴露出来，允许外部连接这个端口</li>
<li><code>CMD</code>：指定容器启动的时候运行命令<br> - CMD echo $MYPATH：输出MYPATH环境变量<br> - CMD echo “—–end—-“：输出—–end—-<br> - CMD &#x2F;bin&#x2F;bash：进入&#x2F;bin&#x2F;bash命令行</li>
</ol>
</blockquote>
<h2 id="3、执行build命令构建镜像"><a href="#3、执行build命令构建镜像" class="headerlink" title="3、执行build命令构建镜像"></a>3、执行build命令构建镜像</h2><p>执行build命令生成image文件。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker build <span class="hljs-literal">-t</span> mycentos:<span class="hljs-number">1.0</span> .<br></code></pre></td></tr></table></figure>

<p><img src="/img/docker_Dockerfile/docker6.png"><br>如果出现<code>Error: Failed to download metadata for repo &#39;appstream&#39;: Cannot prepare internal mirrorlist: No URLs in mirrorlist</code> 错误，不要惊慌！</p>
<p>报错信息的意思是：<code>从仓库 ‘appstream’ 下载元数据失败：由于镜像列表中没有 URL，不能准备内部镜像列表。</code></p>
<blockquote>
<p>错误原因：</p>
<ol>
<li>可能的情况便是网络连接问题。检查是否可以连接外部网络，可以使用 <code>ping baidu.com</code> 查看是否有丢包情况。如果丢包，则进一步检查网络连接是否正常；如果没有丢包，继续阅读下文</li>
<li>第二种情况，便是 CentOS 已经停止维护的问题。2020 年 12 月 8 号，CentOS 官方宣布了停止维护 CentOS Linux 的计划，并推出了 CentOS Stream 项目，CentOS Linux 8 作为 RHEL 8 的复刻版本，生命周期缩短，于 2021 年 12 月 31 日停止更新并停止维护（EOL）。</li>
</ol>
</blockquote>
<h3 id="解决Error-Failed-to-download-metadata-for-repo-39-appstream-39-Cannot-prepare-internal-mirrorlist-No-URLs-in-mirrorlist错误"><a href="#解决Error-Failed-to-download-metadata-for-repo-39-appstream-39-Cannot-prepare-internal-mirrorlist-No-URLs-in-mirrorlist错误" class="headerlink" title="解决Error: Failed to download metadata for repo &#39;appstream&#39;: Cannot prepare internal mirrorlist: No URLs in mirrorlist错误"></a>解决<code>Error: Failed to download metadata for repo &#39;appstream&#39;: Cannot prepare internal mirrorlist: No URLs in mirrorlist</code>错误</h3><blockquote>
<p>因为我们的<code>Dockerfile</code>的基础镜像是可以基于本地的镜像，所以我们只需要修改本地的<code>centos</code>镜像，再用我们的<code>commit</code>指令生成新的镜像用来当我们<code>Dockerfile</code>的基础镜像<br><code>commit指令</code>参考文章《<a target="_blank" rel="noopener" href="https://linzyblog.netlify.app/2022/08/31/docker-images/">Docker镜像概述和分层原理</a>》</p>
</blockquote>
<ol>
<li>运行centos镜像，并进入交互界面</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker run <span class="hljs-literal">-it</span> <span class="hljs-literal">-P</span> centos<br></code></pre></td></tr></table></figure>
<p><img src="/img/docker_Dockerfile/docker7.png"></p>
<ol start="2">
<li>进入到 yum 的 repos 目录</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">cd</span> /etc/yum.repos.d/<br></code></pre></td></tr></table></figure>
<ol start="3">
<li>修改 centos 文件内容</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">sed <span class="hljs-literal">-i</span> <span class="hljs-string">&#x27;s/mirrorlist/#mirrorlist/g&#x27;</span> /etc/yum.repos.d/CentOS-*<br>sed <span class="hljs-literal">-i</span> <span class="hljs-string">&#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27;</span> /etc/yum.repos.d/CentOS-*<br></code></pre></td></tr></table></figure>
<ol start="4">
<li>生成缓存更新（第一次更新，速度稍微有点慢，耐心等待两分钟左右）</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">yum makecache<br></code></pre></td></tr></table></figure>
<p><img src="/img/docker_Dockerfile/docker8.png"></p>
<ol start="5">
<li>运行 yum update (更新的东西很多，大约五分钟)</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">yum update <span class="hljs-literal">-y</span><br></code></pre></td></tr></table></figure>
<p><img src="/img/docker_Dockerfile/docker9.png"><br><img src="/img/docker_Dockerfile/docker10.png"><br>出现Complete的就是成功了</p>
<ol start="6">
<li>使用<code>docker commit</code> 将容器保存为新的镜像</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker commit c638ed426e64  mycentos:<span class="hljs-number">0.1</span><br></code></pre></td></tr></table></figure>

<p><img src="/img/docker_Dockerfile/docker12.png"></p>
<ol start="7">
<li>修改一下我们的Dockerfile里的FROM基础镜像这块</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 基础镜像 修改为mycentos:0.1</span><br>FROM mycentos:<span class="hljs-number">0.1</span><br><br><span class="hljs-comment">#MAINTAINER 维护者信息</span><br>MAINTAINER linzy&lt;<span class="hljs-number">2350621012</span>@qq.com&gt;<br><br><span class="hljs-comment">#ENV 设置环境变量</span><br>ENV MYPATH /usr/local<br><br><span class="hljs-comment">#WORKDIR 相当于cd</span><br>WORKDIR <span class="hljs-variable">$MYPATH</span><br><br><span class="hljs-comment">#RUN 执行命令</span><br>RUN yum <span class="hljs-literal">-y</span> install vim <br>RUN yum <span class="hljs-literal">-y</span> install net<span class="hljs-literal">-tools</span><br><br><span class="hljs-comment">#EXPOSE 映射端口</span><br>EXPOSE <span class="hljs-number">80</span><br><br><span class="hljs-comment">#CMD 运行命令</span><br>CMD <span class="hljs-built_in">echo</span> <span class="hljs-variable">$MYPATH</span><br>CMD <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----end----&quot;</span><br>CMD /bin/bash<br></code></pre></td></tr></table></figure>

<ol start="8">
<li>重新执行<code>build</code>命令</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker build <span class="hljs-literal">-t</span> mycentos:<span class="hljs-number">1.0</span> .<br></code></pre></td></tr></table></figure>
<p><img src="/img/docker_Dockerfile/docker13.png"><br><img src="/img/docker_Dockerfile/docker14.png"><br>构建centos镜像成功！</p>
<h2 id="4、测试运行"><a href="#4、测试运行" class="headerlink" title="4、测试运行"></a>4、测试运行</h2><h3 id="1）使用-docker-history-镜像id-查看镜像构建过程"><a href="#1）使用-docker-history-镜像id-查看镜像构建过程" class="headerlink" title="1）使用 docker history 镜像id 查看镜像构建过程"></a>1）使用 <code>docker history</code> 镜像id 查看镜像构建过程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">E:\dockerfile&gt;docker <span class="hljs-built_in">history</span>  2b92daa4f916<br>IMAGE          CREATED          CREATED BY                                      SIZE      COMMENT<br>2b92daa4f916   29 minutes ago   CMD [<span class="hljs-string">&quot;/bin/sh&quot;</span> <span class="hljs-string">&quot;-c&quot;</span> <span class="hljs-string">&quot;/bin/bash&quot;</span>]                0B        buildkit.dockerfile.v0<br>&lt;missing&gt;      29 minutes ago   CMD [<span class="hljs-string">&quot;/bin/sh&quot;</span> <span class="hljs-string">&quot;-c&quot;</span> <span class="hljs-string">&quot;echo \&quot;-----end----\&quot;&quot;</span>]    0B        buildkit.dockerfile.v0<br>&lt;missing&gt;      29 minutes ago   CMD [<span class="hljs-string">&quot;/bin/sh&quot;</span> <span class="hljs-string">&quot;-c&quot;</span> <span class="hljs-string">&quot;echo <span class="hljs-variable">$MYPATH</span>&quot;</span>]             0B        buildkit.dockerfile.v0<br>&lt;missing&gt;      29 minutes ago   EXPOSE map[80/tcp:&#123;&#125;]                           0B        buildkit.dockerfile.v0<br>&lt;missing&gt;      29 minutes ago   RUN /bin/sh -c yum -y install net-tools <span class="hljs-comment"># bu…   28.7MB    buildkit.dockerfile.v0</span><br>&lt;missing&gt;      29 minutes ago   RUN /bin/sh -c yum -y install vim <span class="hljs-comment"># buildkit    67.2MB    buildkit.dockerfile.v0</span><br>&lt;missing&gt;      29 minutes ago   WORKDIR /usr/local                              0B        buildkit.dockerfile.v0<br>&lt;missing&gt;      29 minutes ago   ENV MYPATH=/usr/local                           0B        buildkit.dockerfile.v0<br>&lt;missing&gt;      29 minutes ago   MAINTAINER linzy&lt;2350621012@qq.com&gt;             0B        buildkit.dockerfile.v0<br>&lt;missing&gt;      32 minutes ago   /bin/bash                                       302MB<br>&lt;missing&gt;      11 months ago    /bin/sh -c <span class="hljs-comment">#(nop)  CMD [&quot;/bin/bash&quot;]            0B</span><br>&lt;missing&gt;      11 months ago    /bin/sh -c <span class="hljs-comment">#(nop)  LABEL org.label-schema.sc…   0B</span><br>&lt;missing&gt;      11 months ago    /bin/sh -c <span class="hljs-comment">#(nop) ADD file:805cb5e15fb6e0bb0…   231MB</span><br></code></pre></td></tr></table></figure>

<h3 id="2）运行容器，看看是否能够执行ifconfig-及vim命令"><a href="#2）运行容器，看看是否能够执行ifconfig-及vim命令" class="headerlink" title="2）运行容器，看看是否能够执行ifconfig 及vim命令"></a>2）运行容器，看看是否能够执行<code>ifconfig</code> 及<code>vim</code>命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">E:\dockerfile&gt;docker run -it mycentos:1.0<br>[root@392bed5a0bcd <span class="hljs-built_in">local</span>]<span class="hljs-comment"># pwd</span><br>/usr/local<br>[root@392bed5a0bcd <span class="hljs-built_in">local</span>]<span class="hljs-comment"># ifconfig</span><br>eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255<br>        ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)<br>        RX packets 11  bytes 906 (906.0 B)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 0  bytes 0 (0.0 B)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536<br>        inet 127.0.0.1  netmask 255.0.0.0<br>        loop  txqueuelen 1000  (Local Loopback)<br>        RX packets 0  bytes 0 (0.0 B)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 0  bytes 0 (0.0 B)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>[root@392bed5a0bcd <span class="hljs-built_in">local</span>]<span class="hljs-comment"># vim</span><br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Docker%E5%AE%B9%E5%99%A8/" class="category-chain-item">Docker容器</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%AD%A6%E4%B9%A0/">#学习</a>
      
        <a href="/tags/Docker/">#Docker</a>
      
        <a href="/tags/go/">#go</a>
      
        <a href="/tags/%E5%AE%B9%E5%99%A8/">#容器</a>
      
        <a href="/tags/linux/">#linux</a>
      
        <a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/">#云原生</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Dockerfile概述与用法</div>
      <div>https://gopherlinzy.github.io/2022/09/06/docker-Dockerfile/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>孙禄毅</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年9月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/19/redis-NoSQL-SQL/" title="Redis（一）入门：NoSQL OR SQL，看完这篇你就懂了">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Redis（一）入门：NoSQL OR SQL，看完这篇你就懂了</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/31/docker-volumes/" title="Docker卷(volumes)">
                        <span class="hidden-mobile">Docker卷(volumes)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments">
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'Gopherlinzy/Gopherlinzy.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/Gopherlinzy/Gopherlinzy.github.io" target="_blank" rel="nofollow noopener"><span>Github</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
