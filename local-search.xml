<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go基础：数据结构（定义和go语言实现）</title>
    <link href="/2023/04/24/go-dataStructure/"/>
    <url>/2023/04/24/go-dataStructure/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>最近在刷leetcode的每日一题的，总会碰到一些问题，因为竞赛时用惯了c++的STL库，有数据结构的实现，可以直接使用，到现在用go总会遇到头疼的事情就是用到数据结构的时候需要自己定义结构并且实现方法，刚好这几天笔试里面也有关于数据结构的题目，所以这一篇主要来讲一下数据结构</p></blockquote><h1 id="一、数组-Array"><a href="#一、数组-Array" class="headerlink" title="一、数组 (Array)"></a>一、数组 (Array)</h1><p><code>数组是一种线性数据结构，它由相同类型的元素组成，每个元素可以通过下标访问。</code>在Go语言中，数组是一种值类型，声明数组时必须指定长度，长度不能被修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个长度为5的整型数组</span><br><span class="hljs-keyword">var</span> a [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br><br><span class="hljs-comment">// 访问数组元素，下标从0开始</span><br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="1、优缺点"><a href="#1、优缺点" class="headerlink" title="1、优缺点"></a>1、优缺点</h2><ul><li>优点：<ul><li>数组的访问速度很快，因为它们是在内存中连续存储的</li><li>数组是一种简单、清晰的数据结构，易于理解和实现</li></ul></li><li>缺点：<ul><li>数组的长度是固定的，无法动态增加或缩小</li><li>插入或删除元素时需要移动数组中的其他元素，效率较低</li></ul></li></ul><h2 id="2、适用场景和不适用场景"><a href="#2、适用场景和不适用场景" class="headerlink" title="2、适用场景和不适用场景"></a>2、适用场景和不适用场景</h2><ul><li>适用场景：<ul><li>当需要在一个集合中存储相同类型的元素时，可以使用数组，例如存储身份证号、学号等</li><li>当需要快速访问数组中的元素时，可以使用数组</li></ul></li><li>不适用场景：<ul><li>当需要动态地添加或删除元素时，不适合使用数组</li><li>当需要支持不同类型的元素时，不适合使用数组</li></ul></li></ul><h1 id="二、切片-Slice"><a href="#二、切片-Slice" class="headerlink" title="二、切片 (Slice)"></a>二、切片 (Slice)</h1><p><code>切片是一个引用类型，由三个部分组成：指向底层数组的指针、切片的长度和切片的容量。</code>切片的底层数组包含了切片中存储的所有元素，而切片则提供了访问这些元素的方法。Go 语言中的切片是动态数组，它可以根据需要动态增长和收缩。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个长度为0的整型切片</span><br><span class="hljs-keyword">var</span> b []<span class="hljs-type">int</span><br><br><span class="hljs-comment">// 使用 make 函数初始化一个长度为5的切片</span><br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<br><br><span class="hljs-comment">// 使用切片的 append 方法向末尾添加元素</span><br>b = <span class="hljs-built_in">append</span>(b, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 获取切片长度</span><br>l = <span class="hljs-built_in">len</span>(b)<br><br><span class="hljs-comment">// 获取切片容量</span><br>c = <span class="hljs-built_in">cap</span>(b)<br><br><span class="hljs-comment">// 删除指定 index 下标的元素</span><br>b = <span class="hljs-built_in">append</span>(b[:index], b[index+<span class="hljs-number">1</span>:])<br><br><span class="hljs-comment">// 同理删除区间[left,right] 内的元素</span><br>b = <span class="hljs-built_in">append</span>(b[:left], b[right+<span class="hljs-number">1</span>:])<br></code></pre></td></tr></table></figure><h2 id="1、优缺点-1"><a href="#1、优缺点-1" class="headerlink" title="1、优缺点"></a>1、优缺点</h2><ul><li>优点:<ul><li>切片具有动态扩容的能力，可以在运行时根据实际需求自动增加容量，并且在传递函数参数时可以避免复制整个数组</li><li>切片还具有可索引、可迭代、可排序等特性</li></ul></li><li>缺点:<ul><li>切片对内存的占用会比数组更大，因为切片会存储指向底层数组的指针、切片长度和容量等信息</li><li>切片的底层数组是由 Go 运行时自动分配的，因此在内存分配和垃圾回收方面可能会对性能产生影响</li></ul></li></ul><h2 id="2、适用场景和不适用场景-1"><a href="#2、适用场景和不适用场景-1" class="headerlink" title="2、适用场景和不适用场景"></a>2、适用场景和不适用场景</h2><ul><li>适用场景：<ul><li>切片适用于需要动态扩容的情况，例如读取未知长度的文件或者从网络上接收数据。由于切片可以在传递函数参数时避免复制整个数组，因此它也适用于需要在函数间传递大量数据的场景</li></ul></li><li>不适用场景：<ul><li>切片不适用于需要固定长度的数组场景，例如矩阵计算、游戏开发等。由于切片可能会对性能产生影响，因此在性能要求较高的场景中也需要谨慎使用</li></ul></li></ul><h1 id="三、链表-Linked-List"><a href="#三、链表-Linked-List" class="headerlink" title="三、链表 (Linked List)"></a>三、链表 (Linked List)</h1><p><code>链表由一系列节点组成，每个节点包含两部分：数据域和指针域。数据域用于存储数据，指针域用于指向下一个节点。</code>链表分为单向链表和双向链表，单向链表的每个节点只包含指向下一个节点的指针，而双向链表的每个节点既包含指向下一个节点的指针，也包含指向上一个节点的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ListNode <span class="hljs-keyword">struct</span> &#123;<br>    Val  <span class="hljs-type">int</span><br>    Next *ListNode<br>&#125;<br><br><span class="hljs-comment">// 在链表末尾插入一个节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insert</span><span class="hljs-params">(head *ListNode, val <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> &amp;ListNode&#123;val, <span class="hljs-literal">nil</span>&#125;<br>    &#125;<br>    node := head<br>    <span class="hljs-keyword">for</span> node.Next != <span class="hljs-literal">nil</span> &#123;<br>        node = node.Next<br>    &#125;<br>    node.Next = &amp;ListNode&#123;val, <span class="hljs-literal">nil</span>&#125;<br>    <span class="hljs-keyword">return</span> head<br>&#125;<br><br><span class="hljs-comment">// 删除链表中的指定节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(head *ListNode, val <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> head.Val == val &#123;<br>        <span class="hljs-keyword">return</span> head.Next<br>    &#125;<br>    node := head<br>    <span class="hljs-keyword">for</span> node.Next != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> node.Next.Val == val &#123;<br>            node.Next = node.Next.Next<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        node = node.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> head<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1、优缺点-2"><a href="#1、优缺点-2" class="headerlink" title="1、优缺点"></a>1、优缺点</h2><ul><li>优点：<ul><li>链表可以高效地进行元素的插入和删除操作，而无需进行元素移动</li></ul></li><li>缺点：<ul><li>链表难以进行随机访问，并且需要额外的空间来存储指针</li></ul></li></ul><h2 id="2、适用场景和不适用场景-2"><a href="#2、适用场景和不适用场景-2" class="headerlink" title="2、适用场景和不适用场景"></a>2、适用场景和不适用场景</h2><ul><li>适用场景：<ul><li>链表适合用于需要频繁进行元素插入和删除的场景，比如实现栈、队列和哈希表等数据结构</li></ul></li><li>不适用场景：<ul><li>链表不适合用于需要进行随机访问的场景，比如需要根据下标获取元素的场景</li></ul></li></ul><h1 id="四、栈（Stack）"><a href="#四、栈（Stack）" class="headerlink" title="四、栈（Stack）"></a>四、栈（Stack）</h1><p><code>栈是一种线性数据结构，具有后进先出（LIFO）的特点。</code>栈通常有两个基本操作：push（推入）和pop（弹出）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stack []<span class="hljs-type">int</span><br><br><span class="hljs-comment">// 将元素添加到栈的顶部</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>    *s = <span class="hljs-built_in">append</span>(*s, x)<br>&#125;<br><span class="hljs-comment">// 从栈的顶部移除元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> s.IsEmpty() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    x := (*s)[<span class="hljs-built_in">len</span>(*s)<span class="hljs-number">-1</span>]<br>    *s = (*s)[:<span class="hljs-built_in">len</span>(*s)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-comment">// 栈是否为空</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span></span> IsEmpty() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(*s) == <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// 栈大小</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span></span> Size() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(*s)<br>&#125;<br><br><span class="hljs-comment">// 返回栈顶元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> s.IsEmpty() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> (*s)[<span class="hljs-built_in">len</span>(*s)<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1、优缺点-3"><a href="#1、优缺点-3" class="headerlink" title="1、优缺点"></a>1、优缺点</h2><ul><li>优点：<ul><li>简单易懂，易于实现</li><li>可以快速访问栈顶元素</li><li>可以方便地实现递归算法</li></ul></li><li>缺点：<ul><li>无法随机访问其他位置的元素，只能访问栈顶元素</li><li>如果栈空间不够用，需要扩容或者重新分配空间</li></ul></li></ul><h2 id="2、适用场景和不适用场景-3"><a href="#2、适用场景和不适用场景-3" class="headerlink" title="2、适用场景和不适用场景"></a>2、适用场景和不适用场景</h2><ul><li>适用场景：<ul><li>在编程语言中，栈用于函数调用和返回，以及表达式求值</li><li>栈在实现DFS（深度优先搜索）算法、回溯算法等场景中也经常使用</li></ul></li><li>不适用场景：<ul><li>需要随机访问元素时不适合使用栈</li></ul></li></ul><h1 id="五、队列（Queue）"><a href="#五、队列（Queue）" class="headerlink" title="五、队列（Queue）"></a>五、队列（Queue）</h1><p><code>队列是一种线性数据结构，它按照先进先出（FIFO）的原则存储元素，即新元素总是添加到队列的末尾，然后在队列的另一端删除旧元素。</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Queue []<span class="hljs-type">int</span><br><br><span class="hljs-comment">// 将元素添加到队列的末尾</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Enqueue(v <span class="hljs-type">int</span>) &#123;<br>    *q = <span class="hljs-built_in">append</span>(*q, v)<br>&#125;<br><span class="hljs-comment">// 从队列的头部删除元素并返回</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Dequeue() <span class="hljs-type">int</span> &#123;<br>    head := (*q)[<span class="hljs-number">0</span>]<br>    *q = (*q)[<span class="hljs-number">1</span>:]<br>    <span class="hljs-keyword">return</span> head<br>&#125;<br><br><span class="hljs-comment">// 检查队列是否为空</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> IsEmpty() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(*q) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1、优缺点-4"><a href="#1、优缺点-4" class="headerlink" title="1、优缺点"></a>1、优缺点</h2><ul><li>优点：<ul><li>能够有效地对数据进行排序，而且处理起来非常高效，可以快速地添加或删除元素</li><li>队列通常用于需要按顺序处理数据的场景，如任务调度、缓冲等</li></ul></li><li>缺点：<ul><li>只能从一端插入元素，从另一端删除元素，因此不太适合需要随机访问数据的场景</li></ul></li></ul><h2 id="2、适用场景和不适用场景-4"><a href="#2、适用场景和不适用场景-4" class="headerlink" title="2、适用场景和不适用场景"></a>2、适用场景和不适用场景</h2><ul><li>适用场景：<ul><li>需要按照先进先出的顺序处理数据的场景</li><li>需要实现任务调度、缓冲等场景</li></ul></li><li>不适用场景：<ul><li>需要随机访问数据的场景</li><li>需要在队列中间插入或删除元素的场景</li></ul></li></ul><h1 id="六、哈希表（Hash-Table）"><a href="#六、哈希表（Hash-Table）" class="headerlink" title="六、哈希表（Hash Table）"></a>六、哈希表（Hash Table）</h1><p><code>哈希表（Hash Table）是一种基于散列函数（Hash Function）实现的数据结构，它可以提供快速的插入、查找和删除操作。</code>哈希表的实现基于数组和链表，通过散列函数将键（Key）映射到数组索引上，将对应的值（Value）存储在对应的数组单元格中。哈希表的优点是高效，平均情况下的时间复杂度为O(1)，适用于需要快速查找的场景。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建map</span><br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br><br><span class="hljs-comment">// 向map中添加元素</span><br>m[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">1</span><br>m[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">2</span><br><br><span class="hljs-comment">// 通过key来获取value</span><br>v := m[<span class="hljs-string">&quot;apple&quot;</span>]<br><br><span class="hljs-comment">// 判断某个key是否存在</span><br>_, ok := m[<span class="hljs-string">&quot;orange&quot;</span>]<br></code></pre></td></tr></table></figure><h2 id="1、优缺点-5"><a href="#1、优缺点-5" class="headerlink" title="1、优缺点"></a>1、优缺点</h2><ul><li>优点：<ul><li>快速查找，平均情况下的时间复杂度为O(1)，适用于需要快速查找的场景。</li><li>可以动态地添加、删除元素</li></ul></li><li>缺点：<ul><li>不保证元素的顺序</li><li>内存占用较高</li><li>容易产生哈希冲突，冲突会导致散列表的性能下降，因此需要解决冲突的方法</li></ul></li></ul><h2 id="2、适用场景和不适用场景-5"><a href="#2、适用场景和不适用场景-5" class="headerlink" title="2、适用场景和不适用场景"></a>2、适用场景和不适用场景</h2><ul><li>适用场景：<ul><li>需要快速查找的场景</li><li>对于缓存，数据量不大的情况下，可以使用哈希表来存储数据，方便快速查询</li></ul></li><li>不适用场景：<ul><li>如果需要有序遍历所有元素，那么哈希表不适合</li><li>哈希表对内存的利用率不高，如果数据量非常大，会占用大量的内存空间，导致性能下降</li></ul></li></ul><h1 id="七、集合（Set）"><a href="#七、集合（Set）" class="headerlink" title="七、集合（Set）"></a>七、集合（Set）</h1><p><code>集合（Set）是一种不允许重复元素的数据结构，通常用于查找、去重、求交集、求并集等场景。</code>集合可以用数组、链表、哈希表等数据结构实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Set <span class="hljs-keyword">struct</span> &#123;<br>    m <span class="hljs-keyword">map</span>[<span class="hljs-keyword">interface</span>&#123;&#125;]<span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-comment">// 创建一个新的集合</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSet</span><span class="hljs-params">()</span></span> *Set &#123;<br>    <span class="hljs-keyword">return</span> &amp;Set&#123;m: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">interface</span>&#123;&#125;]<span class="hljs-type">bool</span>)&#125;<br>&#125;<br><br><span class="hljs-comment">// 添加元素到集合中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Set)</span></span> Add(item <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    s.m[item] = <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// 从集合中删除元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Set)</span></span> Remove(item <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    <span class="hljs-built_in">delete</span>(s.m, item)<br>&#125;<br><br><span class="hljs-comment">// 判断集合中是否包含某个元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Set)</span></span> Contains(item <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">bool</span> &#123;<br>    _, ok := s.m[item]<br>    <span class="hljs-keyword">return</span> ok<br>&#125;<br><br><span class="hljs-comment">// 获取集合中元素的数量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Set)</span></span> Size() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s.m)<br>&#125;<br><br><span class="hljs-comment">// 将集合转换成切片</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Set)</span></span> ToList() []<span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    list := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s.m))<br>    <span class="hljs-keyword">for</span> item := <span class="hljs-keyword">range</span> s.m &#123;<br>        list = <span class="hljs-built_in">append</span>(list, item)<br>    &#125;<br>    <span class="hljs-keyword">return</span> list<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1、优缺点-6"><a href="#1、优缺点-6" class="headerlink" title="1、优缺点"></a>1、优缺点</h2><ul><li>优点：<ul><li>集合不允许重复元素，能够保证数据的唯一性</li><li>集合可以进行去重、求交集、求并集等操作，方便数据处理</li><li>集合的元素可以是任意类型，灵活性高</li></ul></li><li>缺点：<ul><li>集合的实现需要额外的存储空间，相比数组或链表，占用更多内存</li><li>集合不支持随机访问，只能遍历或判断是否包含某个元素</li></ul></li></ul><h2 id="2、适用场景和不适用场景-6"><a href="#2、适用场景和不适用场景-6" class="headerlink" title="2、适用场景和不适用场景"></a>2、适用场景和不适用场景</h2><ul><li>适用场景：<ul><li>需要去重或者判断元素是否存在的场景</li><li>需要求交集、求并集等操作的场景</li></ul></li><li>不适用场景：<ul><li>需要随机访问元素的场景，应该使用数组或链表</li><li>需要有序访问元素的场景，应该使用链表或树结构</li></ul></li></ul><h1 id="八、树（Tree）"><a href="#八、树（Tree）" class="headerlink" title="八、树（Tree）"></a>八、树（Tree）</h1><p><code>树是一种非线性数据结构，它由若干个节点组成，每个节点有零个或多个子节点。</code>树具有以下特点：</p><ul><li>树中只有一个节点，称为根节点。</li><li>每个节点最多有一个父节点，除了根节点没有父节点。</li><li>每个节点可以有多个子节点。</li><li>如果一个节点没有子节点，则称为叶子节点。</li><li>如果从一个节点可以到达另一个节点，则称这两个节点具有父子关系。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TreeNode <span class="hljs-keyword">struct</span> &#123;<br>    Val <span class="hljs-type">int</span><br>    Left *TreeNode<br>    Right *TreeNode<br>&#125;<br><br><span class="hljs-comment">// 创建一个新的树节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTreeNode</span><span class="hljs-params">(val <span class="hljs-type">int</span>, left *TreeNode, right *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">return</span> &amp;TreeNode&#123;val, left, right&#125;<br>&#125;<br><br><span class="hljs-comment">// 插入一个节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node *TreeNode)</span></span> Insert(val <span class="hljs-type">int</span>) *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> NewTreeNode(val, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> val &lt; node.Val &#123;<br>        node.Left = node.Left.Insert(val)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        node.Right = node.Right.Insert(val)<br>    &#125;<br>    <span class="hljs-keyword">return</span> node<br>&#125;<br><br><span class="hljs-comment">// 查找一个节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node *TreeNode)</span></span> Find(val <span class="hljs-type">int</span>) *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> || node.Val == val &#123;<br>        <span class="hljs-keyword">return</span> node<br>    &#125;<br>    <span class="hljs-keyword">if</span> val &lt; node.Val &#123;<br>        <span class="hljs-keyword">return</span> node.Left.Find(val)<br>    &#125;<br>    <span class="hljs-keyword">return</span> node.Right.Find(val)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1、优缺点-7"><a href="#1、优缺点-7" class="headerlink" title="1、优缺点"></a>1、优缺点</h2><ul><li>优点：<ul><li>树是一种非常高效的数据结构，插入、查找、删除操作的时间复杂度均为O(log n)</li><li>树结构天生就是具有层次性的，非常适合表示一些具有层次性质的问题，如文件系统、目录结构等</li><li>树结构可以用于快速排序、二叉搜索树等算法</li></ul></li><li>缺点：<ul><li>树结构的缺点是占用空间较大</li><li>树结构在处理一些非层次性问题时，效率可能不高</li></ul></li></ul><h2 id="2、适用场景和不适用场景-7"><a href="#2、适用场景和不适用场景-7" class="headerlink" title="2、适用场景和不适用场景"></a>2、适用场景和不适用场景</h2><ul><li>适用场景：<ul><li>表示层次性结构的问题，如文件系统、目录结构等</li><li>快速排序、二叉搜索树等算法</li><li>表示树形结构的问题，如语法树、家谱等</li></ul></li><li>不适用场景：<ul><li>对空间有较高要求的场景，如嵌入式系统等</li><li>处理非层次性问题的场景</li></ul></li></ul><h1 id="九、堆（Heap）"><a href="#九、堆（Heap）" class="headerlink" title="九、堆（Heap）"></a>九、堆（Heap）</h1><p><code>堆是一种基于完全二叉树的数据结构，其中每个节点的值都大于等于（最大堆）或小于等于（最小堆）其子节点的值。</code>它的特点是在任何时刻，堆的根节点所存储的值都是堆中所有元素中最大或最小的。</p><p>在Go语言中，可以使用标准库中的 <code>container/heap</code> 包实现堆。具体实现需要实现 Heap 接口的以下方法：</p><ol><li>Len：获取堆中元素的数量；</li><li>Less：比较堆中两个元素的大小；</li><li>Swap：交换堆中两个元素的位置；</li><li>Push：向堆中插入一个元素；</li><li>Pop：从堆中弹出一个元素。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个最大堆</span><br><span class="hljs-keyword">type</span> MaxHeap []<span class="hljs-type">int</span><br><br><span class="hljs-comment">// 获取堆的长度</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MaxHeap)</span></span> Len() <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h) &#125;<br><br><span class="hljs-comment">// 比较两个元素的大小</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MaxHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> h[i] &gt; h[j] &#125;<br><br><span class="hljs-comment">// 交换两个元素的位置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MaxHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123; h[i], h[j] = h[j], h[i] &#125;<br><br><span class="hljs-comment">// 把一个元素添加到堆中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MaxHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    *h = <span class="hljs-built_in">append</span>(*h, x.(<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-comment">// 从堆中删除一个元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MaxHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    n := <span class="hljs-built_in">len</span>(*h)<br>    x := (*h)[n<span class="hljs-number">-1</span>]<br>    *h = (*h)[:n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br></code></pre></td></tr></table></figure>在使用时，可以通过以下方式创建一个最大堆并添加元素：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">h := &amp;MaxHeap&#123;&#125;<br>heap.Push(h, <span class="hljs-number">2</span>)<br>heap.Push(h, <span class="hljs-number">1</span>)<br>heap.Push(h, <span class="hljs-number">3</span>)<br><br><span class="hljs-comment">// 获取最大值并弹出</span><br>fmt.Println(heap.Pop(h).(<span class="hljs-type">int</span>)) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>也可以使用以下方法进行堆排序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">arr := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;<br>h := MaxHeap(arr)<br>heap.Init(&amp;h)<br>heap.Sort(&amp;h)<br>fmt.Println(h) <span class="hljs-comment">// [1 2 3]</span><br></code></pre></td></tr></table></figure><h2 id="1、优缺点-8"><a href="#1、优缺点-8" class="headerlink" title="1、优缺点"></a>1、优缺点</h2><ul><li>优点：<ul><li>插入和删除的时间复杂度都是 O(log n)，效率高</li><li>堆只需要占用很小的连续内存空间，空间利用率高</li></ul></li><li>缺点：<ul><li>不能快速查找指定值，只能查找堆顶元素</li><li>对于堆中相同的值，无法保证其排序前后顺序</li></ul></li></ul><h2 id="2、适用场景和不适用场景-8"><a href="#2、适用场景和不适用场景-8" class="headerlink" title="2、适用场景和不适用场景"></a>2、适用场景和不适用场景</h2><ul><li>适用场景：<ul><li>大&#x2F;小顶堆常用于优先级队列，如任务调度等场景</li><li>堆排序算法</li><li>最大&#x2F;最小值查询场景</li></ul></li><li>不适用场景：<ul><li>需要查找具体值的场景</li><li>堆中有相同元素，需要保证顺序的场景</li></ul></li></ul><h1 id="十、图（Graph）"><a href="#十、图（Graph）" class="headerlink" title="十、图（Graph）"></a>十、图（Graph）</h1><p><code>图（Graph）是由节点（Vertex）和边（Edge）构成的一种数据结构，用于表示多对多的关系。</code>节点表示实体，边表示实体之间的关系。图可以用于模拟现实生活中各种复杂的关系网络，例如社交网络、交通网络、物流网络等。</p><p>在Go语言中，可以使用邻接矩阵或邻接表来表示图。其中邻接矩阵使用二维数组表示图，邻接表使用链表或数组来表示图。具体实现方法如下：</p><p>邻接矩阵：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Graph <span class="hljs-keyword">struct</span> &#123;<br>    vertexNum <span class="hljs-type">int</span>        <span class="hljs-comment">// 节点数</span><br>    matrix    [][]<span class="hljs-type">int</span>    <span class="hljs-comment">// 邻接矩阵</span><br>    visited   []<span class="hljs-type">bool</span>     <span class="hljs-comment">// 记录节点是否被访问过</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGraph</span><span class="hljs-params">(vertexNum <span class="hljs-type">int</span>)</span></span> *Graph &#123;<br>    matrix := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, vertexNum)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> matrix &#123;<br>        matrix[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, vertexNum)<br>    &#125;<br>    visited := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, vertexNum)<br>    <span class="hljs-keyword">return</span> &amp;Graph&#123;vertexNum, matrix, visited&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Graph)</span></span> AddEdge(from, to, weight <span class="hljs-type">int</span>) &#123;<br>    g.matrix[from][to] = weight<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Graph)</span></span> DFS(start <span class="hljs-type">int</span>) &#123;<br>    g.visited[start] = <span class="hljs-literal">true</span><br>    fmt.Println(start)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; g.vertexNum; i++ &#123;<br>        <span class="hljs-keyword">if</span> !g.visited[i] &amp;&amp; g.matrix[start][i] != <span class="hljs-number">0</span> &#123;<br>            g.DFS(i)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Graph)</span></span> BFS(start <span class="hljs-type">int</span>) &#123;<br>    queue := []<span class="hljs-type">int</span>&#123;start&#125;<br>    g.visited[start] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        node := queue[<span class="hljs-number">0</span>]<br>        queue = queue[<span class="hljs-number">1</span>:]<br>        fmt.Println(node)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; g.vertexNum; i++ &#123;<br>            <span class="hljs-keyword">if</span> !g.visited[i] &amp;&amp; g.matrix[node][i] != <span class="hljs-number">0</span> &#123;<br>                g.visited[i] = <span class="hljs-literal">true</span><br>                queue = <span class="hljs-built_in">append</span>(queue, i)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>邻接表：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Graph <span class="hljs-keyword">struct</span> &#123;<br>    nodes []*Node<br>&#125;<br><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>    val  <span class="hljs-type">int</span><br>    next *Node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewNode</span><span class="hljs-params">(val <span class="hljs-type">int</span>)</span></span> *Node &#123;<br>    <span class="hljs-keyword">return</span> &amp;Node&#123;val: val, next: <span class="hljs-literal">nil</span>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *Node)</span></span> AddNode(val <span class="hljs-type">int</span>) &#123;<br>    temp := n<br>    <span class="hljs-keyword">for</span> temp.next != <span class="hljs-literal">nil</span> &#123;<br>        temp = temp.next<br>    &#125;<br>    temp.next = NewNode(val)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGraph</span><span class="hljs-params">()</span></span> *Graph &#123;<br>    <span class="hljs-keyword">return</span> &amp;Graph&#123;nodes: []*Node&#123;&#125;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Graph)</span></span> AddNode(val <span class="hljs-type">int</span>) &#123;<br>    g.nodes = <span class="hljs-built_in">append</span>(g.nodes, NewNode(val))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Graph)</span></span> AddEdge(src, dst <span class="hljs-type">int</span>) &#123;<br>    g.nodes[src].AddNode(dst)<br>    g.nodes[dst].AddNode(src)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Graph)</span></span> Print() &#123;<br>    <span class="hljs-keyword">for</span> i, node := <span class="hljs-keyword">range</span> g.nodes &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;Node %d: &quot;</span>, i)<br>        temp := node<br>        <span class="hljs-keyword">for</span> temp != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Printf(<span class="hljs-string">&quot;%d &quot;</span>, temp.val)<br>            temp = temp.next<br>        &#125;<br>        fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1、优缺点-9"><a href="#1、优缺点-9" class="headerlink" title="1、优缺点"></a>1、优缺点</h2><ul><li>优点：<ul><li>图可以直观地表示复杂的关系网络</li><li>可以用图算法解决许多实际问题，例如最短路径问题、最小生成树问题等</li></ul></li><li>缺点：<ul><li>图的表示和操作比较复杂，需要消耗大量的时间和空间</li><li>图的算法比较复杂，需要较高的算法水平</li></ul></li></ul><h2 id="2、适用场景和不适用场景-9"><a href="#2、适用场景和不适用场景-9" class="headerlink" title="2、适用场景和不适用场景"></a>2、适用场景和不适用场景</h2><ul><li>适用场景：<ul><li>社交网络、交通网络、物流网络等复杂的关系网络</li><li>用于最短路径问题、最小生成树问题等实际问题</li></ul></li><li>不适用场景：<ul><li>数据之间不存在明确的关系</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go基础入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>golang</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go底层原理：一起来唠唠GMP调度（一）</title>
    <link href="/2023/04/24/go-GMP-1/"/>
    <url>/2023/04/24/go-GMP-1/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>春招开始了，作为23届的科班咸鱼学习记录一下八股文和go底层原理（GC、GMP调度、goroutine等）本文介绍 Go 语言运行时调度器的实现原理，其中包含调度器的设计与实现原理、演变过程以及与运行时调度相关的数据结构。<br>参考几篇不错的文章：<br>mingguangtu<a href="https://zhuanlan.zhihu.com/p/586236582">《深入分析Go1.18 GMP调度器底层原理》</a><br>刘丹冰Aceld<a href="https://learnku.com/articles/41728">《Golang 调度器 GMP 原理与调度全分析》</a></p></blockquote><h1 id="一、进程、线程、Goroutine"><a href="#一、进程、线程、Goroutine" class="headerlink" title="一、进程、线程、Goroutine"></a>一、进程、线程、Goroutine</h1><h2 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h2><p>在了解Go的调度器的时候，都离不开操作系统、进程与线程这些概念。</p><table><thead><tr><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>操作系统资源调度和分配的基本单位</td><td>CPU调度和分派的基本单位</td></tr><tr><td>一个进程可以有多个线程</td><td>一个线程只能属于一个进程</td></tr><tr><td>有独立的地址空间</td><td>同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器</td></tr><tr><td>创建销毁开销大，进程切换时，耗费资源较大</td><td>创建销毁开销小，线程切换时，耗费资源小</td></tr><tr><td>实现操作系统的并发</td><td>实现进程内部的并发</td></tr></tbody></table><p><code>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</code>资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。</p><p><code>在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换,如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。</code></p><p><img src="/img/go-GMP-1/efb77fb2af084d9fb8c278ce2703af88-20230424162942012.png" alt="在这里插入图片描述"></p><blockquote><p>摘抄某知乎大佬的比喻：进程&#x3D;火车，线程&#x3D;车厢</p><ul><li>线程在进程下行进（单纯的车厢无法运行）</li><li>一个进程可以包含多个线程（一辆火车可以有多个车厢）</li><li>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</li><li>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</li><li>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</li><li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</li><li>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）</li><li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－”互斥锁”</li><li>进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</li></ul></blockquote><h2 id="2、Goroutine"><a href="#2、Goroutine" class="headerlink" title="2、Goroutine"></a>2、Goroutine</h2><p>Goroutine &#x3D; Golang + Coroutine。Goroutine是golang实现的用户态、轻量级的协程。Goroutine具有以下特点：</p><ul><li>相比线程，其启动的代价很小，以很小栈空间启动（2Kb左右）</li><li>能够动态地伸缩栈的大小，最大可以支持到Gb级别</li><li>工作在用户态，切换成本很小</li><li>与线程关系是 N:M，即可以在 N 个系统线程上多工调度 M 个Goroutine</li></ul><blockquote><p>Goroutine是Golang支持高并发的重要保障。Golang可以创建成千上万个Goroutine来处理任务，将这些Goroutine分配、负载、调度到处理器上采用的是G-M-P模型。</p></blockquote><h1 id="二、Go调度器设计思想"><a href="#二、Go调度器设计思想" class="headerlink" title="二、Go调度器设计思想"></a>二、Go调度器设计思想</h1><p>在我们学习Go调度器前，先了解线程模型的概念，大部分的调度器都是基于线程模型思想开发的。</p><h2 id="1、线程模型"><a href="#1、线程模型" class="headerlink" title="1、线程模型"></a>1、线程模型</h2><p><code>线程创建、管理、调度等采用的方式称为线程模型。</code>线程模型一般分为以下三种：</p><ul><li>内核级线程(Kernel Level Thread)模型</li><li>用户级线程(User Level Thread)模型</li><li>两级线程模型，也称混合型线程模型</li></ul><p>三大线程模型最大差异就在于用户级线程与内核调度实体KSE（KSE，Kernel Scheduling Entity）之间的对应关系。KSE是Kernel Scheduling Entity的缩写，其是可被操作系统内核调度器调度的对象实体，是操作系统内核的最小调度单元，可以简单理解为内核级线程。</p><p><code>用户级线程即协程，由应用程序创建与管理，协程必须与内核级线程绑定之后才能执行。线程由 CPU 调度是抢占式的，协程由用户态调度是协作式的，一个协程让出 CPU 后，才执行下一个协程。</code></p><table><thead><tr><th>特性</th><th>用户级线程</th><th>内核级线程</th></tr></thead><tbody><tr><td>创建者</td><td>应用程序</td><td>内核</td></tr><tr><td>操作系统是否感知存在</td><td>否</td><td>是</td></tr><tr><td>开销成本</td><td>创建成本低，上下文切换成本低，上下文切换不需要硬件支持</td><td>创建成本高，上下文切换成本高，上下文切换需要硬件支持</td></tr><tr><td>如果线程阻塞</td><td>整个进程将被阻塞。即不能利用多处理来发挥并发优势</td><td>其他线程可以继续执行,进程不会阻塞</td></tr><tr><td>案例</td><td>JAVA threads</td><td>Window Solaris</td></tr></tbody></table><h3 id="1-1-内核级线程模型"><a href="#1-1-内核级线程模型" class="headerlink" title="1.1 内核级线程模型"></a>1.1 内核级线程模型</h3><p>内核级线程模型中用户线程与内核线程是一对一关系（1 : 1）。<code>线程的创建、销毁、切换工作都是有内核完成的。</code>应用程序不参与线程的管理工作，只能调用内核级线程编程接口(应用程序创建一个新线程或撤销一个已有线程时，都会进行一个系统调用）。</p><p>操作系统调度器管理、调度并分派这些线程。运行时调度器为每个用户级线程静态关联一个内核级线程，用户线程在其生命期内都会绑定到该内核线程。一旦用户线程终止，两个线程都将离开系统。</p><p><img src="/img/go-GMP-1/b62a0aacbbaa4328b3181c7012e0e975-20230424162942042.png" alt="在这里插入图片描述"><br>大部分编程语言的线程库(如linux的pthread，Java的java.lang.Thread，C++11的std::thread等等)都是对操作系统的线程（内核级线程)的一层封装，创建出来的每个线程与一个不同的内核级线程静态关联，因此其调度完全由OS调度器来做。</p><blockquote><p>内核级线程模型有如下优点：</p><ul><li>在多处理器系统中，内核能够并行执行同一进程内的多个线程</li><li>如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行</li><li>当一个线程阻塞时，内核根据选择可以运行另一个进程的线程，而用户空间实现的线程中，运行时系统始终运行自己进程中的线程</li></ul><p>缺点：</p><ul><li>线程的创建与删除都需要CPU参与，成本大</li><li>需要使用大量线程的场景下对OS的性能影响会很大</li></ul></blockquote><h3 id="1-2-用户级线程模型"><a href="#1-2-用户级线程模型" class="headerlink" title="1.2 用户级线程模型"></a>1.2 用户级线程模型</h3><p>用户线程模型中的用户线程与内核线程是多对一关系（N : 1）。<code>线程的创建、销毁以及线程之间的协调、同步等工作都是在用户态完成，具体来说就是由应用程序的线程库来完成。</code>线程的并发处理从宏观来看，任意时刻每个进程只能够有一个线程在运行，且只有一个处理器内核会被分配给该进程。</p><p>从图中可以看出来：一个进程中所有创建的线程都与同一个内核线程在运行时动态关联。内核线程将被操作系统调度器指派到处理器内核。用户级线程是一种”多对一”的线程映射</p><p><img src="/img/go-GMP-1/2324da609bf74e1190cd082b7a2fc9f9-20230424162942066.png" alt="在这里插入图片描述"></p><blockquote><p>用户级线程有如下优点：</p><ul><li>创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多, 因为保存线程状态的过程和调用程序都只是本地过程</li><li>线程能够利用的表空间和堆栈空间比内核级线程多</li></ul><p>缺点：</p><ul><li>线程发生I&#x2F;O或页面故障引起的阻塞时，如果调用阻塞系统调用则内核由于不知道有多线程的存在，而会阻塞整个进程从而阻塞所有线程, 因此同一进程中只能同时有一个线程在运行</li><li>资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用</li></ul></blockquote><h3 id="1-3-混合型线程模型"><a href="#1-3-混合型线程模型" class="headerlink" title="1.3 混合型线程模型"></a>1.3 混合型线程模型</h3><p>混合型线程模型中用户线程与内核线程是多对多关系（N : M）。<code>混合型线程模型充分吸收上面两种模型的优点，为一个进程中创建多个内核线程，并且线程可以与不同的内核线程在运行时进行动态关联，当某个内核线程由于其上工作的线程的阻塞操作被内核调度出CPU时，当前与其关联的其余用户线程可以重新与其他内核线程建立关联关系。</code></p><p>其线程创建在用户空间中完成，线程的调度和同步也在应用程序中进行。一个应用程序中的多个用户级线程被绑定到一些（小于或等于用户级线程的数目）内核级线程上。</p><p>此模型有时也被称为 两级线程模型，即用户调度器实现用户线程到内核线程的“调度”，内核调度器实现内核线程到CPU上的调度。</p><p><img src="/img/go-GMP-1/ef949e34bb92430986e59ae4c9157a24-20230424162942039.png" alt="在这里插入图片描述"></p><blockquote><p>缺点:</p><ul><li>这种动态关联机制的实现很复杂，也需要用户自己去实现。Go语言中的并发就是使用的这种实现方式，Go为了实现该模型自己实现了一个运行时调度器来负责Go中的”线程”与内核的动态关联。</li></ul></blockquote><p>这里我们只需要知道 Go 的线程模型，下面我们讲一下GMP调度的升级之路<br><img src="/img/go-GMP-1/1e31580c350c4ae8909e06f4e9e7961b-20230424162942031.png" alt="在这里插入图片描述"></p><h2 id="2、-被废弃的-G-M-调度器"><a href="#2、-被废弃的-G-M-调度器" class="headerlink" title="2、 被废弃的 G-M 调度器"></a>2、 被废弃的 G-M 调度器</h2><p><code>Golang在底层实现了混合型线程模型。</code>Go 语言将线程分为了两种类型：内核级线程 M （Machine），轻量级的用户态的协程 Goroutine。</p><p>这里我们提到了 Go 语言调度器的三个核心概念中的两个：</p><ul><li><p>M： Machine的缩写，代表了内核线程 OS Thread，CPU调度的基本单元</p></li><li><p>G： Goroutine的缩写，用户态、轻量级的协程，一个 G 代表了对一段需要被执行的 Go 语言程序的封装；每个 Goroutine 都有自己独立的栈存放自己程序的运行状态；分配的栈大小 2KB，可以按需扩缩容</p></li></ul><p><img src="/img/go-GMP-1/1b7a2036f80e4a84b872bdb3d9af4dc8-20230424162941941.png" alt="在这里插入图片描述"></p><h3 id="2-1-了解-G-M-调度如何工作"><a href="#2-1-了解-G-M-调度如何工作" class="headerlink" title="2.1 了解 G-M 调度如何工作"></a>2.1 了解 G-M 调度如何工作</h3><p>老调度器存在一个全局 G 队列，M在执行和放回队首的 G 都需要访问全局 G 队列，因为存在多个 M 同时竞争，在访问<code>临界资源</code>全局 G 队列时需要加锁进行保证互斥 &#x2F; 同步，所以全局 G 队列是有互斥锁进行保护的。<br><img src="/img/go-GMP-1/13b53e10037d486da30b5595d993eca3-20230424162942041.png" alt="在这里插入图片描述"><br>我们知道在多线程下，老调度器存在几个缺点：</p><ul><li>创建、销毁、调度 G 都需要每个 M 获取锁，在多线程下这就形成了激烈的<code>锁竞争</code>。</li><li>M 转移 G 会造成延迟和额外的系统负载。比如当 G 中包含创建新协程的时候，M 创建了 G’，为了继续执行 G，需要把 G’交给 M’执行，也造成了很差的局部性，因为 G’和 G 是相关的，最好放在 M 上执行，而不是其他 M’。</li><li>系统调用 (CPU 在 M 之间的切换) 导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li></ul><h2 id="3、如今高效的-GMP-模型"><a href="#3、如今高效的-GMP-模型" class="headerlink" title="3、如今高效的 GMP 模型"></a>3、如今高效的 GMP 模型</h2><p>Go为了解决 G-M 调度的缺点，在原先的 G-M 调度器基础上引进了 P，也就是如今Go优秀的GMP 调度模型。</p><ul><li>P：Processor的缩写，<code>代表一个虚拟的处理器，是线程 M 和 G 的中间层</code>，它能提供线程需要的上下文环境，也会负责调度线程上的等待队列，它维护一个本地的可运行的 G 队列，通过处理器 P 的调度，每一个内核线程都能够执行多个 Goroutine，它能在 Goroutine 进行一些 I&#x2F;O 操作时及时让出计算资源，提高线程的利用率。</li></ul><p><img src="/img/go-GMP-1/9af053c8b7bb4df78c2935a7fa8ad096-20230424162942183.png" alt="在这里插入图片描述"></p><h3 id="3-1-GMP模型调度流程"><a href="#3-1-GMP模型调度流程" class="headerlink" title="3.1 GMP模型调度流程"></a>3.1 GMP模型调度流程</h3><p>了解一下图中出现的几个概念：</p><ol><li>全局队列（Global Queue）：存放等待运行的 G。</li><li>P 的本地队列：同全局队列类似，存放的也是等待运行的 G，本地队列中 G 的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列（本地队列的前一半 + G’，通常为 G’）。</li></ol><p><img src="/img/go-GMP-1/81eb40586a884f21be73955d6a31a613-20230424162942176.png" alt="在这里插入图片描述"></p><blockquote><p>GMP调度流程大致如下：</p><ol><li>线程M想运行任务就需得获取 P，即与P关联</li><li>P 的本地队列(LRQ)获取 G</li><li>若LRQ中没有可运行的G，M 会尝试从全局队列(GRQ)拿一批G放到P的本地队列（拿取数量 &#x3D; 全局队列中 G 的数量 &#x2F; 运行的 M-P 数量 + 1，至少拿一个，保证合理分配）</li><li>若全局队列也未找到可运行的G时候，M会随机从其他 P 的本地队列偷一半放到自己 P 的本地队列</li><li>拿到可运行的G之后，M 运行 G，G 执行结束后，M 会从 P 获取下一个 G，不断重复下去</li><li>当 M 执行某一个 G 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除 (detach)，然后再创建一个新的操作系统的线程 (如果有空闲的线程可用就复用空闲线程) 来服务于这个 P</li><li>当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中</li></ol></blockquote><h3 id="3-2-GMP调度设计策略"><a href="#3-2-GMP调度设计策略" class="headerlink" title="3.2 GMP调度设计策略"></a>3.2 GMP调度设计策略</h3><ul><li><p><strong>复用线程</strong>：避免频繁的创建、销毁线程，而是对线程的复用。可以使用下面两种机制实现对线程对复用。</p><ul><li><p><strong>Work Stealing 任务窃取机制</strong>：M 优先执行其所绑定的 P 的本地队列的 G；如果本地队列为空，当 P 本地队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列；如果全局队列也为空时，会从其他 P 的本地队列偷一半放到自己 P 的本地队列，这种 GMP 调度模型也叫任务窃取调度模型；</p></li><li><p><strong>Hand Off 交接机制</strong>：当前线程 M 因为 G 进行系统调用阻塞时，线程 M 释放绑定的 P，P 会寻找其他空闲的线程 M 绑定执行， 如果没找到空闲的 M 的 P 进入全局 P 队列。</p></li></ul></li><li><p><strong>利用多核并行能力</strong>：Go默认设置线程 M 最大数量为10000，实际等于 CPU 的核心数。GOMAXPROCS 设置 P 处理器的数量，实际上 P 数量应该小于等于 CPU 核数。GOMAXPROCS 也限制了并行，比如 GOMAXPROCS &#x3D; 核数&#x2F;2，则最多利用了一半的 CPU 核进行并行。</p></li><li><p><strong>基于协作的抢占机制</strong>：</p><ul><li>G 主动让出 CPU 才能调度执行下一个 G，某些 Goroutine 可以长时间占用线程，造成其它 Goroutine 的饥饿；</li><li>垃圾回收需要暂停整个程序（Stop-the-world，STW），最长可能需要几分钟的时间，导致整个程序无法工作；</li><li>Go为了公平，让每个孩子都有奶吃，一个 G 最多占用 CPU 10ms，防止其他 G 等待时间过长被饿死。</li></ul></li><li><p><strong>基于信号的真抢占机制</strong>：尽管基于协作的抢占机制能够缓解长时间 GC 导致整个程序无法工作和大多数 Goroutine 饥饿问题，但是还是有部分情况下，Go调度器有无法被抢占的情况，例如，for 循环或者垃圾回收长时间占用线程，为了解决这些问题， Go1.14 引入了基于信号的抢占式调度机制，能够解决 GC 垃圾回收和栈扫描时存在的问题。</p></li></ul><h3 id="3-3-GMP调度场景"><a href="#3-3-GMP调度场景" class="headerlink" title="3.3 GMP调度场景"></a>3.3 GMP调度场景</h3><p>可能到这里对于调度流程和设计策略还是一知半解，先用几张图形象的描述下 GMP 调度机制的一些场景，帮助理解 GMP 调度器为了保证公平性、可扩展性、及提高并发效率，所设计的一些机制和策略。</p><h4 id="3-3-1-G1-运行中创建-G2"><a href="#3-3-1-G1-运行中创建-G2" class="headerlink" title="3.3.1 G1 运行中创建 G2"></a>3.3.1 G1 运行中创建 G2</h4><p>正在 M1 上运行的 G1，通过go func() 创建 G2 后，由于局部性，G2优先放入 P 的本地队列。<br><img src="/img/go-GMP-1/7ab32a60302a4a14a4a94ccb7230e7c0-20230424162942086.png" alt="在这里插入图片描述"></p><h4 id="3-3-2-G-运行结束后"><a href="#3-3-2-G-运行结束后" class="headerlink" title="3.3.2 G 运行结束后"></a>3.3.2 G 运行结束后</h4><p>M1 上的 G1 运行完成后（调用goexit()函数），M1 上运行的 Goroutine 会切换为 G0，<code>G0 负责调度协程的切换（运行schedule() 函数）</code>，从 M1 上 P 的本地运行队列获取 G2 去执行（函数execute()）。</p><blockquote><p>注意：这里 G0 是程序启动时的线程 M（也叫M0）的系统栈表示的 G 结构体，负责 M 上 G 的调度；</p></blockquote><p><img src="/img/go-GMP-1/91984c3fbf2a422fb07809164327e7df-20230424162942181.png" alt="在这里插入图片描述"></p><h4 id="3-3-3-M-上创建的-G-个数大于本地队列长度时"><a href="#3-3-3-M-上创建的-G-个数大于本地队列长度时" class="headerlink" title="3.3.3 M 上创建的 G 个数大于本地队列长度时"></a>3.3.3 M 上创建的 G 个数大于本地队列长度时</h4><p>如果 P 本地队列最多能存 4 个 G（实际上是256个），正在 M1 上运行的 G2 要通过 go func()创建 6 个 G，那么，前 4 个 G 放在 P 本地队列中，G2 创建了第 5 个 G（G7）时，<code>P 本地队列中前一半和 G7 一起打乱顺序放入全局队列，P 本地队列剩下的 G 往前移动</code>，G2 创建的第 6 个 G（G8）时，放入 P 本地队列中，因为还有空间</p><p><img src="/img/go-GMP-1/926d8e228f2b448f81aa7550466897a2-20230424162942224.png" alt="在这里插入图片描述"></p><h4 id="3-3-5-M-的自旋状态"><a href="#3-3-5-M-的自旋状态" class="headerlink" title="3.3.5 M 的自旋状态"></a>3.3.5 M 的自旋状态</h4><p>创建新的 G 时，运行的 G 会尝试唤醒其他空闲的 M 绑定 P 去执行，如果 G2 唤醒了M2，M2 绑定了一个 P2，会先运行 M2 的 G0，这时 M2 没有从 P2 的本地队列中找到 G，会进入<code>自旋状态（spinning）</code>，自旋状态的 M2 会尝试从全局空闲线程队列里面获取 G，放到 P2 本地队列去执行，获取的数量满足公式：n &#x3D; min(len(globrunqsize)&#x2F;GOMAXPROCS + 1, len(localrunsize&#x2F;2))，含义是每个P应该从全局队列承担的 G 数量，为了公平性和提高效率，不能太多，要给其他 P 留点；</p><p><img src="/img/go-GMP-1/94259f6f080441beabfb1def4150e284-20230424162942181.png" alt="在这里插入图片描述"></p><h4 id="3-3-5-任务窃取机制"><a href="#3-3-5-任务窃取机制" class="headerlink" title="3.3.5 任务窃取机制"></a>3.3.5 任务窃取机制</h4><p>自旋状态的 M 会寻找可运行的 G，如果全局队列为空，则会从其他 P 偷取 G 来执行，个数是其他 P 运行队列的一半；</p><p><img src="/img/go-GMP-1/21f0b2438cfc45049889a9f219542285-20230424162942281.png" alt="在这里插入图片描述"></p><h4 id="3-3-6-G-发生系统调用进入阻塞时"><a href="#3-3-6-G-发生系统调用进入阻塞时" class="headerlink" title="3.3.6 G 发生系统调用进入阻塞时"></a>3.3.6 G 发生系统调用进入阻塞时</h4><p>如果 G 发生系统调度进入阻塞，其所在的 M 也会阻塞，因为会进入内核状态等待系统资源，和 M 绑定的 P 会解除绑定寻找空闲的 M 执行，这是为了提高效率，不能让 P 本地队列的 G 因所在 M 进入阻塞状态而无法执行。<br><img src="/img/go-GMP-1/dda8bb034684472fbebcf4e8376856d0-20230424162942200.png" alt="在这里插入图片描述"></p><blockquote><p>GMP模型的阻塞可能发生在下面几种情况：</p><ul><li>I&#x2F;O，select</li><li>block on syscall</li><li>channel</li><li>等待锁</li><li>runtime.Gosched()</li></ul></blockquote><h5 id="3-3-6-1-用户态阻塞"><a href="#3-3-6-1-用户态阻塞" class="headerlink" title="3.3.6.1 用户态阻塞"></a>3.3.6.1 用户态阻塞</h5><ul><li>当 G 因为channel操作或者network I&#x2F;O而阻塞时（实际上golang已经用netpoller实现了 G 网络I&#x2F;O阻塞不会导致M被阻塞，仅阻塞G），对应的G会被放置到某个wait队列(如channel的waitq)，该G的状态由_Gruning变为_Gwaitting，而M会跳过该G尝试获取并执行下一个G，如果此时没有runnable的G供M运行，那么M将解绑P，并进入sleep状态；</li><li>当阻塞的G被另一端的G2唤醒时（比如channel的可读&#x2F;写通知），G被标记为runnable，尝试加入G2所在P的runnext，然后再是P的Local队列和Global队列。</li></ul><h5 id="3-3-6-2-系统调用阻塞"><a href="#3-3-6-2-系统调用阻塞" class="headerlink" title="3.3.6.2 系统调用阻塞"></a>3.3.6.2 系统调用阻塞</h5><ul><li>当G被阻塞在某个系统调用上时，此时G会阻塞在_Gsyscall状态，M也处于 block on syscall 状态，此时的M执行可被抢占调度：执行该G的M会与P解绑，而P则尝试与其它idle的M绑定，继续执行其它G。如果没有其它idle的M，但P的Local队列中仍然有G需要执行，则创建一个新的M；</li><li>当系统调用完成后，G会重新尝试获取一个idle的P进入它的Local队列恢复执行，如果没有idle的P，G会被标记为runnable加入到Global队列。</li></ul><h4 id="3-3-7-G-退出系统调用时"><a href="#3-3-7-G-退出系统调用时" class="headerlink" title="3.3.7 G 退出系统调用时"></a>3.3.7 G 退出系统调用时</h4><p>如果刚才进入系统调用的 G2 解除了阻塞，其所在的 M1 会寻找 P 去执行，优先找原来的 P，发现没有找到或者 P 已经与其他 M 绑定，则其上的 G2 会进入全局队列，等其他 M 获取执行，M1 进入休眠线程队列，等待 P 将他重新唤醒。<br><img src="/img/go-GMP-1/bd9fad3e4608453a80cc240bea45fe33-20230424162942235.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Go基础入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>golang</tag>
      
      <tag>后端</tag>
      
      <tag>GMP调度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go基础入门：sort包</title>
    <link href="/2023/04/24/go-sort/"/>
    <url>/2023/04/24/go-sort/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><code>切片是Go语言中引入的用于在大多数场合替代数组的语法元素。</code>切片是长度可变的同类型元素序列，它不支持存储不同类型的元素。<br><strong>有序列的地方就有排序的需求</strong>。在各种排序算法都已经成熟的今天，我们完全可以针对特定元素类型的切片手写排序函数&#x2F;方法，但多数情况下不推荐这么做，因为Go标准库内置了sort包可以很好地帮助我们实现原生类型元素切片以及自定义类型元素切片的排序任务。</p></blockquote><h1 id="一、sort包简介"><a href="#一、sort包简介" class="headerlink" title="一、sort包简介"></a>一、sort包简介</h1><p>Go的sort包用来排序，二分查找等操作。</p><h1 id="二、sort包内排序原理实现"><a href="#二、sort包内排序原理实现" class="headerlink" title="二、sort包内排序原理实现"></a>二、sort包内排序原理实现</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Len是集合中元素的个数。</span><br>Len() <span class="hljs-type">int</span><br><span class="hljs-comment">// Less是排序条件（索引i与j的元素对比排序）</span><br>Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span><br><span class="hljs-comment">// Swap交换索引i和j的元素。</span><br>Swap(i, j <span class="hljs-type">int</span>)<br>&#125;<br><br><span class="hljs-comment">// Sort按Less方法确定的升序对数据进行排序。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sort</span><span class="hljs-params">(data Interface)</span></span> &#123;<br>n := data.Len()<br><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>limit := bits.Len(<span class="hljs-type">uint</span>(n))<br>pdqsort(data, <span class="hljs-number">0</span>, n, limit)<br>&#125;<br></code></pre></td></tr></table></figure><p>入口的 Sort 函数调用的 pdqsort 并不完全是快排。</p><blockquote><p><code>pdqsort实质为一种混合排序算法，在不同情况下切换到不同的排序机制</code>，该实现灵感来自C++和RUST的实现，是对C++标准库算法introsort的一种改进，其理想情况下的时间复杂度为 O(n)，最坏情况下的时间复杂度为 O(n* logn)，不需要额外的空间。</p></blockquote><p>pdqsort算法的改进在于对常见的情况做了特殊优化，其主要的思想是不断判定目前的序列情况，然后使用不同的方式和路径达到最优解；其实现就是对下面三种情况的不断循环：</p><ul><li>短序列情况：对于长度在 [0, MAX_INSERTION] 的输入，使用 insertion sort (插入排序)来进行排序后直接返回，这里的 MAX_INSERTION 我们选定为 12。</li><li>最坏情况，如果发现改进的 quicksort 效果不佳(limit &#x3D;&#x3D; 0)，则后续排序都使用 heap sort 来保证最坏情况时间复杂度为 O(n*logn)。</li><li>正常情况，对于其他输入，使用改进的 quicksort 来排序</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pdqsort</span><span class="hljs-params">(data Interface, a, b, limit <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">const</span> maxInsertion = <span class="hljs-number">12</span><br><br><span class="hljs-keyword">var</span> (<br>wasBalanced    = <span class="hljs-literal">true</span> <span class="hljs-comment">// whether the last partitioning was reasonably balanced</span><br>wasPartitioned = <span class="hljs-literal">true</span> <span class="hljs-comment">// whether the slice was already partitioned</span><br>)<br><br><span class="hljs-keyword">for</span> &#123;<br>length := b - a<br><br><span class="hljs-keyword">if</span> length &lt;= maxInsertion &#123;<br>insertionSort(data, a, b)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// Fall back to heapsort if too many bad choices were made.</span><br><span class="hljs-keyword">if</span> limit == <span class="hljs-number">0</span> &#123;<br>heapSort(data, a, b)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// If the last partitioning was imbalanced, we need to breaking patterns.</span><br><span class="hljs-keyword">if</span> !wasBalanced &#123;<br>breakPatterns(data, a, b)<br>limit--<br>&#125;<br><br>pivot, hint := choosePivot(data, a, b)<br><span class="hljs-keyword">if</span> hint == decreasingHint &#123;<br>reverseRange(data, a, b)<br><span class="hljs-comment">// The chosen pivot was pivot-a elements after the start of the array.</span><br><span class="hljs-comment">// After reversing it is pivot-a elements before the end of the array.</span><br><span class="hljs-comment">// The idea came from Rust&#x27;s implementation.</span><br>pivot = (b - <span class="hljs-number">1</span>) - (pivot - a)<br>hint = increasingHint<br>&#125;<br><br><span class="hljs-comment">// The slice is likely already sorted.</span><br><span class="hljs-keyword">if</span> wasBalanced &amp;&amp; wasPartitioned &amp;&amp; hint == increasingHint &#123;<br><span class="hljs-keyword">if</span> partialInsertionSort(data, a, b) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Probably the slice contains many duplicate elements, partition the slice into</span><br><span class="hljs-comment">// elements equal to and elements greater than the pivot.</span><br><span class="hljs-keyword">if</span> a &gt; <span class="hljs-number">0</span> &amp;&amp; !data.Less(a<span class="hljs-number">-1</span>, pivot) &#123;<br>mid := partitionEqual(data, a, b, pivot)<br>a = mid<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>mid, alreadyPartitioned := partition(data, a, b, pivot)<br>wasPartitioned = alreadyPartitioned<br><br>leftLen, rightLen := mid-a, b-mid<br>balanceThreshold := length / <span class="hljs-number">8</span><br><span class="hljs-keyword">if</span> leftLen &lt; rightLen &#123;<br>wasBalanced = leftLen &gt;= balanceThreshold<br>pdqsort(data, a, mid, limit)<br>a = mid + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>wasBalanced = rightLen &gt;= balanceThreshold<br>pdqsort(data, mid+<span class="hljs-number">1</span>, b, limit)<br>b = mid<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了更方便理解应用排序函数Sort，我们需要让被排序的切片类型实现 sort.Interface接口，以整型切片排序为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// IntSlice将Interface的方法附加到[]int，按递减顺序排序。</span><br><span class="hljs-keyword">type</span> IntSlice []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x IntSlice)</span></span> Len() <span class="hljs-type">int</span>           &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(x) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x IntSlice)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> x[i] &gt; x[j] &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x IntSlice)</span></span> Swap(i, j <span class="hljs-type">int</span>)      &#123; x[i], x[j] = x[j], x[i] &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sl := IntSlice([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">24</span>, <span class="hljs-number">46</span>, <span class="hljs-number">81</span>, <span class="hljs-number">9</span>, <span class="hljs-number">67</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">13</span>&#125;)<br>fmt.Println(sl) <span class="hljs-comment">// [24, 46, 81, 9, 67, 6, 5, 13]</span><br><br><span class="hljs-comment">// Sort按照less条件排序</span><br>sort.Sort(sl)<br>fmt.Println(sl) <span class="hljs-comment">// [81 67 46 24 13 9 6 5]</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用 sort.Sort 函数的实现排序后，因为我们并没有重写接口的Sort方法，所以默认使用sort包里Sort函数，它使用的是<code>快速排序(quickSort)</code>。<br>我们知道快速排序是在所有数量级为(O(nlogn))的排序算法中其平均性能最好的算法，但在某些情况下其性能却并非最佳。<br>Go sort包中的quickSort函数也没有严格拘泥于仅使用快排算法，而是<code>以快速排序为主</code>，并根据目标状况在特殊条件下选择了其他不同的排序算法，包括<code>堆排序(heapSort)、插入排序(insertionSort)</code>等。</p></blockquote><p>sort.Sort函数不保证排序是稳定的，要想使用稳定排序，需要使用<code>sort.Stable</code>函数。（保证排序的稳定性，相等元素的相对次序不变）</p><blockquote><p>注：稳定排序：假定在待排序的序列中存在多个具有相同值的元素，若经过排序，这些元素的相对次序保持不变，即在原序列中，若r[i]&#x3D;r[j]且r[i]在r[j]之前，在排序后的序列中，若r[i]仍在r[j]之前，则称这种排序算法是稳定的(stable)；否则称为不稳定的。</p></blockquote><h1 id="三、sort包内置函数"><a href="#三、sort包内置函数" class="headerlink" title="三、sort包内置函数"></a>三、sort包内置函数</h1><p>如果我们直接使用sort.Sort函数对切片进行排序还是比较繁琐的，所以sort包提供了许多<code>内置函数</code>，比如：Ints、Float64s、Strings、Slice,、Sort、 SearchInts、SearchFloat64s、SearchStrings和Search等。</p><h2 id="1、sort-Ints-x-int"><a href="#1、sort-Ints-x-int" class="headerlink" title="1、sort.Ints(x []int)"></a>1、sort.Ints(x []int)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">ints := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, ints) <br>sort.Ints(ints) <span class="hljs-comment">//默认升序</span><br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, ints) <span class="hljs-comment">//[1 2 3 4] </span><br>sort.Sort(sort.Reverse(sort.IntSlice(ints))) <span class="hljs-comment">//降序排序 </span><br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, ints) <span class="hljs-comment">//[4 3 2 1]</span><br></code></pre></td></tr></table></figure><blockquote><p><code>sort.Strings(x []string) sort.Float64s(x []float64)</code>使用方法相同。</p></blockquote><h2 id="2、sort-Slice-x-any-less-func-i-j-int-bool"><a href="#2、sort-Slice-x-any-less-func-i-j-int-bool" class="headerlink" title="2、sort.Slice(x any, less func(i, j int) bool)"></a>2、sort.Slice(x any, less func(i, j int) bool)</h2><p>Slice函数有个好处，如果传入对象是切片，实现回调函数即可，如果传入对象是结构体，也可以自定义排序规则。</p><ul><li>传入对象是切片，实现回调函数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">slices := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;<br>sort.Slice(slices, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> slices[i] &lt; slices[j]<br>&#125;)<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, slices)<span class="hljs-comment">//[1 1 1 4 4 5]</span><br></code></pre></td></tr></table></figure><ul><li>传入对象是结构体，可以自定义排序规则</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> stu <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>age  <span class="hljs-type">int</span><br>&#125;<br><br>stus := []stu&#123;&#123;<span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-number">20</span>&#125;, &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">23</span>&#125;, &#123;<span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-number">21</span>&#125;&#125;<br>sort.Slice(stus, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> stus[i].name == stus[j].name &#123;<br><span class="hljs-keyword">return</span> stus[i].age &gt; stus[j].age <span class="hljs-comment">// 年龄逆序</span><br>&#125;<br><span class="hljs-keyword">return</span> stus[i].name &lt; stus[j].name <span class="hljs-comment">// 名字正序</span><br>&#125;)<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, stus) <span class="hljs-comment">//[&#123;a 23&#125; &#123;h 21&#125; &#123;h 20&#125;]</span><br></code></pre></td></tr></table></figure><h2 id="3、sort-SearchInts-a-int-x-int-int"><a href="#3、sort-SearchInts-a-int-x-int-int" class="headerlink" title="3、sort.SearchInts(a []int, x int) int"></a>3、sort.SearchInts(a []int, x int) int</h2><p>作用：用来二分查找对应值的索引值，索引值从0开始。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">arr := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;<br>idx := sort.SearchInts(arr, <span class="hljs-number">4</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, idx) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><blockquote><p><code>sort.SearchFloat64s(a []float64, x float64) int sort.SearchStrings(a []string, x string) int</code> 功能同上。</p></blockquote><h2 id="4、sort-Search-n-int-f-func-int-bool-int"><a href="#4、sort-Search-n-int-f-func-int-bool-int" class="headerlink" title="4、sort.Search(n int, f func(int) bool) int"></a>4、sort.Search(n int, f func(int) bool) int</h2><p>作用：自定义的二分查找，需要自己实现查找条件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">arr := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;<br>idx := sort.Search(<span class="hljs-built_in">len</span>(arr), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> arr[i] &gt; <span class="hljs-number">4</span><br>&#125;)<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, idx) <span class="hljs-comment">//4</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go基础入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>后端</tag>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gRPC（八）生态 grpc-gateway 应用：同一个服务端支持Rpc和Restful Api</title>
    <link href="/2022/11/10/grpc-gateway/"/>
    <url>/2022/11/10/grpc-gateway/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>示例代码已经上传到github：<a href="https://github.com/Gopherlinzy/grpc-gateway-example">点击跳转</a><br>gRPC官方文档：<a href="https://grpc.io/docs/languages/go/basics/">点击跳转</a><br>grpc-gateway官方文档：<a href="https://grpc-ecosystem.github.io/grpc-gateway/">点击跳转</a><br>源自 coreos 的一篇博客，转载到了 gRPC 官方博客 <a href="https://grpc.io/blog/coreos/">gRPC with REST and Open APIs</a>。</p></blockquote><h1 id="一、gRPC-Gateway概述"><a href="#一、gRPC-Gateway概述" class="headerlink" title="一、gRPC-Gateway概述"></a>一、gRPC-Gateway概述</h1><h2 id="1、简述"><a href="#1、简述" class="headerlink" title="1、简述"></a>1、简述</h2><blockquote><p>取自官方概述：<br>grpc-gateway is a plugin of protoc. It reads gRPC service definition, and generates a reverse-proxy server which translates a RESTful JSON API into gRPC. This server is generated according to custom options in your gRPC definition.</p></blockquote><p>gRPC-Gateway 是 <code>protoc 的插件</code>。它读取gRPC服务定义并<code>生成反向代理服务器，将 RESTful JSON API 转换为 gRPC</code>。该服务器是根据服务定义中的 <code>google.api.http</code> 注释生成的。</p><h2 id="2、出现"><a href="#2、出现" class="headerlink" title="2、出现"></a>2、出现</h2><p>etcd v3 改用 gRPC 后为了兼容原来的 API，同时要提供 HTTP&#x2F;JSON 方式的API，为了满足这个需求，要么开发两套 API，要么实现一种转换机制，所以<code>grpc-gateway</code>诞生了。</p><ul><li>通过protobuf的自定义option实现了一个<code>网关</code>，服务端同时开启gRPC和HTTP服务。</li><li>HTTP服务接收客户端请求后转换为grpc请求数据，获取响应后转为json数据返回给客户端。</li><li>当 HTTP 请求到达 gRPC-Gateway 时，它将 JSON 数据解析为 Protobuf 消息。<code>使用解析的 Protobuf 消息发出正常的 Go gRPC 客户端请求。</code></li><li>Go gRPC 客户端将 Protobuf 结构编码为 <code>Protobuf 二进制格式</code>，然后将其发送到 gRPC 服务器。</li><li>gRPC 服务器处理请求并以 Protobuf 二进制格式返回响应。</li><li>Go gRPC 客户端将其解析为 Protobuf 消息，并将其返回到 gRPC-Gateway，后者将 Protobuf 消息编码为 JSON 并将其返回给原始客户端。</li></ul><p>架构如下</p><p><img src="/img/grpc-gateway/grpc1.png"></p><h1 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h1><p>由于本实践偏向 Grpc+Grpc Gateway的方面，我们的需求是同一个服务端支持Rpc和Restful Api，那么就意味着<code>http2、TLS</code>等等的应用，功能方面就是一个服务端能够接受来自grpc和Restful Api的请求并响应。</p><p>本文示例代码已经上传到github：<a href="https://github.com/Gopherlinzy/grpc-gateway-example">点击跳转</a></p><h2 id="1、目录结构"><a href="#1、目录结构" class="headerlink" title="1、目录结构"></a>1、目录结构</h2><p>新建grpc-gateway-example文件夹，我们项目的初始目录目录如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">grpc-gateway-example/<br>├── certs<br>├── client<br>├── cmd<br>├── pkg<br>├── proto<br>│   ├── google<br>│   │   └── api<br>│   │   │   └── annotations.proto<br>│   │   │   └── http.proto<br>│   │   └── protobuf<br>│   │   │   └── descriptor.proto<br>├── server<br>└── Makefile<br></code></pre></td></tr></table></figure><ul><li>certs：存放证书凭证</li><li>client：客户端</li><li>cmd：存放 cobra 命令模块</li><li>pkg：第三方公共模块</li><li>proto：protobuf的一些相关文件（含.proto、pb.go、.pb.gw.go)，google&#x2F;api中用于存放<code>annotations.proto、http.proto</code>、google&#x2F;protobuf中用于存放<code>descriptor.proto</code><ul><li>如果你生成Go代码的时候出现<code>File not found</code>，那一定就是找不到下面的文件。</li><li><code>annotations.proto和http.proto</code>文件需要手动从 <a href="https://github.com/googleapis/googleapis/tree/master/google/api">https://github.com/googleapis/googleapis/tree/master/google/api</a>地址复制到自己的项目中或者手动复制代码！！</li><li><code>descriptor.proto</code>文件可以直接复制代码！！</li></ul></li><li>server：服务端</li><li>Makefile：用于存放编译的代码。</li></ul><h2 id="2、环境准备"><a href="#2、环境准备" class="headerlink" title="2、环境准备"></a>2、环境准备</h2><h3 id="1）Protobuf"><a href="#1）Protobuf" class="headerlink" title="1）Protobuf"></a>1）Protobuf</h3><p>详细的请移步到<a href="https://linzyblog.netlify.app/2022/10/31/grpc-protobuf/">《gRPC（二）入门：Protobuf入门》</a></p><h3 id="2）gRPC"><a href="#2）gRPC" class="headerlink" title="2）gRPC"></a>2）gRPC</h3><p>详细的请移步到<a href="https://linzyblog.netlify.app/2022/11/01/grpc-use/">《gRPC（三）基础：gRPC快速入门》</a></p><h3 id="3）gRPC-Gateway"><a href="#3）gRPC-Gateway" class="headerlink" title="3）gRPC-Gateway"></a>3）gRPC-Gateway</h3><p>gRPC-Gateway 只是一个插件，只需要安装一下就可以了。这里建议科学上网：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get -u github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway<br></code></pre></td></tr></table></figure><h2 id="3、编写-IDL"><a href="#3、编写-IDL" class="headerlink" title="3、编写 IDL"></a>3、编写 IDL</h2><h3 id="1）google-api"><a href="#1）google-api" class="headerlink" title="1）google.api"></a>1）google.api</h3><p><code>proto</code> 目录中有 <code>google/api</code> 目录，它用到了 google 官方提供的两个 api 描述文件，主要是针对 grpc-gateway 的 http 转换提供支持，定义了 Protocol Buffer 所扩展的 HTTP Option。</p><h3 id="2）hello-proto"><a href="#2）hello-proto" class="headerlink" title="2）hello.proto"></a>2）hello.proto</h3><p>编写Demo的 <code>.proto </code>文件，我们在 proto目录下新建 hello.proto 文件，写入文件内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">package</span> proto;<br>option go_package = <span class="hljs-string">&quot;./proto/helloworld;helloworld&quot;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;proto/google/api/annotations.proto&quot;</span>;<br><br><span class="hljs-comment">// 定义Hello服务</span><br>service Hello &#123;<br>  <span class="hljs-comment">// 定义SayHello方法</span><br>  rpc SayHello(HelloRequest) returns (HelloResponse) &#123;<br>    <span class="hljs-comment">// http option 网关</span><br>    option (google.api.http) = &#123;<br>      post: <span class="hljs-string">&quot;/hello_world&quot;</span><br>      body: <span class="hljs-string">&quot;*&quot;</span><br>    &#125;;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// HelloRequest 请求结构</span><br>message HelloRequest &#123;<br>  <span class="hljs-type">string</span> referer = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// HelloResponse 响应结构</span><br>message HelloResponse &#123;<br>  <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 hello.proto 文件中，引用了 <code>google/api/annotations.proto </code>，达到支持HTTP Option的效果</p><ul><li>定义了一个 serviceRPC 服务 HelloWorld，在其内部定义了一个 <code>HTTP Option</code> 的POST方法，HTTP 响应路径为<code>/hello_world</code>。</li><li>定义message类型<code>HelloWorldRequest、HelloWorldResponse</code>，用于响应请求和返回结果。</li></ul><blockquote><p>每个方法都必须添加 <code>google.api.http</code> 注解后 gRPC-Gateway 才能生成对应 http 方法。<br>其中post为 HTTP Method，即 POST 方法，<code>/hello_world</code> 则是请求路径。</p></blockquote><h3 id="3）编译proto"><a href="#3）编译proto" class="headerlink" title="3）编译proto"></a>3）编译proto</h3><p>在Makefile文件内输入以下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">protoc:<br>protoc  --go_out=.  --<span class="hljs-keyword">go</span>-grpc_out=. --grpc-gateway_out=. ./proto<span class="hljs-comment">/*.proto</span><br></code></pre></td></tr></table></figure><ul><li>Go Plugins 用于生成 .pb.go 文件</li><li>gRPC Plugins 用于生成 _grpc.pb.go</li><li>gRPC-Gateway 则是 pb.gw.go</li></ul><p>使用 <code>make protoc</code> 编译proto：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">➜ <span class="hljs-built_in">make</span> protoc<br>protoc  --go_out=.  --<span class="hljs-keyword">go</span>-grpc_out=. --grpc-gateway_out=. ./proto<span class="hljs-comment">/*.proto</span><br></code></pre></td></tr></table></figure><p><img src="/img/grpc-gateway/grpc2.png"></p><h2 id="4、制作证书"><a href="#4、制作证书" class="headerlink" title="4、制作证书"></a>4、制作证书</h2><p>详细的请移步到<a href="https://linzyblog.netlify.app/2022/11/03/grpc-tls/">《gRPC（五）进阶：通过TLS建立安全连接》</a></p><p>在服务端支持Rpc和Restful Api，需要用到TLS，因此我们要先制作证书</p><p>进入certs目录，生成TLS所需的公钥密钥文件</p><h3 id="1）生成CA根证书"><a href="#1）生成CA根证书" class="headerlink" title="1）生成CA根证书"></a>1）生成CA根证书</h3><p>在 <code>ca.conf</code> 文件并写入内容如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">[ req ]<br>default_bits       = <span class="hljs-number">4096</span><br>distinguished_name = req_distinguished_name<br><br>[ req_distinguished_name ]<br>countryName                 = GB<br>countryName_default         = CN<br>stateOrProvinceName         = State or Province Name (full name)<br>stateOrProvinceName_default = ZheJiang<br>localityName                = Locality Name (eg, city)<br>localityName_default        = HuZhou<br>organizationName            = Organization Name (eg, company)<br>organizationName_default    = Step<br>commonName                  = linzyblog.netlify.app<br>commonName_max              = <span class="hljs-number">64</span><br>commonName_default          = linzyblog.netlify.app<br></code></pre></td></tr></table></figure><ol><li>生成ca私钥，得到ca.key</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">openssl genrsa -out ca.key <span class="hljs-number">4096</span><br></code></pre></td></tr></table></figure><ol start="2"><li>生成ca证书签发请求，得到ca.csr</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">$ openssl req -<span class="hljs-built_in">new</span> -sha256 -out ca.csr -key ca.key -config ca.conf<br>GB [CN]:<br>State or Province Name (full name) [ZheJiang]:<br>Locality Name (eg, city) [HuZhou]:<br>Organization Name (eg, company) [Step]:<br>linzyblog.netlify.app [linzyblog.netlify.app]:<br></code></pre></td></tr></table></figure><ol start="3"><li>生成ca根证书，得到ca.crt</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">openssl x509 -req -days <span class="hljs-number">3650</span> -in ca.csr -signkey ca.key -out ca.crt<br></code></pre></td></tr></table></figure><p><img src="/img/grpc-gateway/grpc3.png"></p><h3 id="2）生成终端用户证书"><a href="#2）生成终端用户证书" class="headerlink" title="2）生成终端用户证书"></a>2）生成终端用户证书</h3><p>在 <code>server.conf</code> 写入以下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go">[ req ]<br>default_bits       = <span class="hljs-number">2048</span><br>distinguished_name = req_distinguished_name<br><br>[ req_distinguished_name ]<br>countryName                 = Country Name (<span class="hljs-number">2</span> letter code)<br>countryName_default         = CN<br>stateOrProvinceName         = State or Province Name (full name)<br>stateOrProvinceName_default = ZheJiang<br>localityName                = Locality Name (eg, city)<br>localityName_default        = HuZhou<br>organizationName            = Organization Name (eg, company)<br>organizationName_default    = Step<br>commonName                  = CommonName (e.g. server FQDN or YOUR name)<br>commonName_max              = <span class="hljs-number">64</span><br>commonName_default          = linzyblog.netlify.app<br><br>[ req_ext ]<br>subjectAltName = @alt_names<br><br>[alt_names]<br>DNS<span class="hljs-number">.1</span>   = grpc-gateway-example<br>IP      = <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure><ol><li>生成私钥，得到server.key</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">openssl genrsa -out server.key <span class="hljs-number">2048</span><br></code></pre></td></tr></table></figure><ol start="2"><li>生成证书签发请求，得到server.csr</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">openssl req -<span class="hljs-built_in">new</span> -sha256 -out server.csr -key server.key -config server.conf<br></code></pre></td></tr></table></figure><p>这里也一直回车就好。</p><ol start="3"><li>用CA证书生成终端用户证书，得到server.crt</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">openssl x509 -req -days <span class="hljs-number">3650</span> -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.pem -extensions req_ext -extfile server.conf<br></code></pre></td></tr></table></figure><p><img src="/img/grpc-gateway/grpc4.png"></p><blockquote><p>这样我们需要的证书凭证就足够了</p></blockquote><h1 id="三、命令行模块-cmd"><a href="#三、命令行模块-cmd" class="headerlink" title="三、命令行模块 cmd"></a>三、命令行模块 cmd</h1><h2 id="1、Cobra介绍"><a href="#1、Cobra介绍" class="headerlink" title="1、Cobra介绍"></a>1、Cobra介绍</h2><p>官方文档：<a href="https://grpc-ecosystem.github.io/grpc-gateway/">点击跳转</a></p><p><code>Cobra 是一个用于创建强大的现代 CLI 应用程序的库</code>。它提供了一个简单的界面来创建强大的现代 CLI 界面，类似于 git 和 go 工具。</p><p>Cobra 提供：</p><ul><li>简易的子命令行模式</li><li>完全兼容 <code>POSIX</code> 的命令行模式(包括短版和长版）</li><li>嵌套的子命令</li><li>全局、本地和级联<code>flags</code></li><li>使用Cobra很容易的生成应用程序和命令，使用 <code>cobra create appname</code>和 <code>cobra add cmdname</code></li><li>提供智能提示</li><li>自动生成commands和flags的帮助信息</li><li>自动生成详细的 <code>help</code> 信息，如 app -help。</li><li>自动识别帮助 <code>flag、 -h，--help</code>。</li><li>自动生成应用程序在 bash 下命令自动完成功能。</li><li>自动生成应用程序的 man 手册。</li><li>命令行别名。</li><li>自定义 <code>help</code> 和 <code>usage</code> 信息。</li><li>可选的与 <code>viper</code> 的紧密集成。</li></ul><h2 id="2、概念"><a href="#2、概念" class="headerlink" title="2、概念"></a>2、概念</h2><p>Cobra 建立在命令（commands）、参数（arguments ）、选项（flags）的结构之上。</p><ul><li><strong>commands</strong>：命令代表行为,一般表示 action，即运行的二进制命令服务。同时可以拥有子命令（children commands）</li><li><strong>arguments</strong>：参数代表命令行参数。</li><li><strong>flags</strong>：选项代表对命令行为的改变，即命令行选项。二进制命令的配置参数，可对应配置文件。参数可分为全局参数和子命令参数。</li></ul><p>最好的命令行程序在实际使用时，就应该像在读一段优美的语句，能够更加直观的知道如何与用户进行交互。</p><p>执行命令行程序应该遵循一般的格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#appname command  arguments</span><br>docker pull alpine:latest<br><br><span class="hljs-comment">#appname command flag</span><br>docker ps -a<br><br><span class="hljs-comment">#appname command flag argument</span><br>git commit -m <span class="hljs-string">&quot;linzy&quot;</span><br></code></pre></td></tr></table></figure><h2 id="3、安装"><a href="#3、安装" class="headerlink" title="3、安装"></a>3、安装</h2><p>使用 Cobra 很容易。首先，用于go get安装最新版本的库。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get -u github.com/spf13/cobra@latest<br></code></pre></td></tr></table></figure><h2 id="4、编写-server"><a href="#4、编写-server" class="headerlink" title="4、编写 server"></a>4、编写 server</h2><p>在编写 cmd 时需要先用 server 进行测试关联，因此这一步我们先写 server.go 用于测试</p><p>在 server 模块下 新建 <code>server.go</code> 文件，写入测试内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> server<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>ServerPort  <span class="hljs-type">string</span><br>CertName    <span class="hljs-type">string</span><br>CertPemPath <span class="hljs-type">string</span><br>CertKeyPath <span class="hljs-type">string</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Serve</span><span class="hljs-params">()</span></span> (err <span class="hljs-type">error</span>) &#123;<br>log.Println(ServerPort)<br><br>log.Println(CertName)<br><br>log.Println(CertPemPath)<br><br>log.Println(CertKeyPath)<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、编写-cmd"><a href="#5、编写-cmd" class="headerlink" title="5、编写 cmd"></a>5、编写 cmd</h2><p>在cmd模块下 新建 <code>root.go</code> 文件，写入内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> cmd<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><br><span class="hljs-string">&quot;github.com/spf13/cobra&quot;</span><br>)<br><br><span class="hljs-comment">// rootCmd表示在没有任何子命令的情况下的基本命令</span><br><span class="hljs-keyword">var</span> rootCmd = &amp;cobra.Command&#123;<br><span class="hljs-comment">// Command的用法，Use是一个行用法消息</span><br>Use: <span class="hljs-string">&quot;grpc&quot;</span>,<br><span class="hljs-comment">// Short是help命令输出中显示的简短描述</span><br>Short: <span class="hljs-string">&quot;Run the gRPC hello-world server&quot;</span>,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Execute</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := rootCmd.Execute(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>os.Exit(<span class="hljs-number">-1</span>)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>当前 cmd 目录下继续 新建 <code>server.go</code> 文件，写入内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> cmd<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/spf13/cobra&quot;</span><br><span class="hljs-string">&quot;grpc-gateway-example/server&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-comment">// 创建附加命令</span><br><span class="hljs-comment">// 本地标签：在本地分配一个标志，该标志仅适用于该特定命令。</span><br><span class="hljs-keyword">var</span> serverCmd = &amp;cobra.Command&#123;<br>Use:   <span class="hljs-string">&quot;server&quot;</span>,<br>Short: <span class="hljs-string">&quot;Run the gRPC hello-world server&quot;</span>,<br><span class="hljs-comment">// 运行:典型的实际工作功能。大多数命令只会实现这一点；</span><br><span class="hljs-comment">// 另外还有PreRun、PreRunE、PostRun、PostRunE等等不同时期的运行命令，但比较少用，具体使用时再查看亦可</span><br>Run: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cmd *cobra.Command, args []<span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;Recover error : %v&quot;</span>, err)<br>&#125;<br>&#125;()<br><br>server.Serve()<br>&#125;,<br>&#125;<br><br><span class="hljs-comment">// 在 init() 函数中定义flags和处理配置。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 我们定义了一个flag，值存储在&amp;server.ServerPort中，长命令为--port，短命令为-p，，默认值为50052。</span><br><span class="hljs-comment">// 命令的描述为server port。这一种调用方式成为Local Flags 本地标签</span><br>serverCmd.Flags().StringVarP(&amp;server.ServerPort, <span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;50052&quot;</span>, <span class="hljs-string">&quot;server port&quot;</span>)<br>serverCmd.Flags().StringVarP(&amp;server.CertPemPath, <span class="hljs-string">&quot;cert-pem&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;./certs/server.pem&quot;</span>, <span class="hljs-string">&quot;cert pem path&quot;</span>)<br>serverCmd.Flags().StringVarP(&amp;server.CertKeyPath, <span class="hljs-string">&quot;cert-key&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;./certs/server.key&quot;</span>, <span class="hljs-string">&quot;cert key path&quot;</span>)<br>serverCmd.Flags().StringVarP(&amp;server.CertName, <span class="hljs-string">&quot;cert-name&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;grpc-gateway-example&quot;</span>, <span class="hljs-string">&quot;server&#x27;s hostname&quot;</span>)<br><br><span class="hljs-comment">// AddCommand向这父命令（rootCmd）添加一个或多个命令</span><br>rootCmd.AddCommand(serverCmd)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6、启动-amp-请求"><a href="#6、启动-amp-请求" class="headerlink" title="6、启动 &amp; 请求"></a>6、启动 &amp; 请求</h2><p>我们在 <code>grpc-gateway-example</code> 目录下，新建文件main.go，写入内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;grpc-gateway-example/cmd&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>cmd.Execute()<br>&#125;<br></code></pre></td></tr></table></figure><p>当前目录下执行·go run main.go server·，查看输出是否为（此时应为默认值）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span> server<br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">10</span> <span class="hljs-number">12</span>:<span class="hljs-number">08</span>:<span class="hljs-number">22</span> <span class="hljs-number">50052</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">10</span> <span class="hljs-number">12</span>:<span class="hljs-number">08</span>:<span class="hljs-number">22</span> grpc-gateway-example                       <br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">10</span> <span class="hljs-number">12</span>:<span class="hljs-number">08</span>:<span class="hljs-number">22</span> ./certs/server.pem                         <br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">10</span> <span class="hljs-number">12</span>:<span class="hljs-number">08</span>:<span class="hljs-number">22</span> ./certs/server.key                         <br></code></pre></td></tr></table></figure><p>执行<code>go run main.go server --port=8000 --cert-pem=test-pem --cert-key=test-key --cert-name=test-name</code>，检验命令行参数是否正确：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span> server --port=<span class="hljs-number">8000</span> --cert-pem=test-pem --cert-key=test-key --cert-name=test-name<br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">10</span> <span class="hljs-number">12</span>:<span class="hljs-number">24</span>:<span class="hljs-number">53</span> <span class="hljs-number">8000</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">10</span> <span class="hljs-number">12</span>:<span class="hljs-number">24</span>:<span class="hljs-number">54</span> test-name<br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">10</span> <span class="hljs-number">12</span>:<span class="hljs-number">24</span>:<span class="hljs-number">54</span> test-pem <br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">10</span> <span class="hljs-number">12</span>:<span class="hljs-number">24</span>:<span class="hljs-number">54</span> test-key<br></code></pre></td></tr></table></figure><p>到这都无误，我们的 <code>cmd</code> 模块编写就正确了，下面开始我们的重点</p><h2 id="7、目录结构"><a href="#7、目录结构" class="headerlink" title="7、目录结构"></a>7、目录结构</h2><p>完成以上操作之后我们的目录是这样的结构，看看是不是缺少了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go">grpc-gateway-example/<br>├── certs<br>├── client<br>├── cmd<span class="hljs-comment">// 命令行模块</span><br>│   ├── root.<span class="hljs-keyword">go</span><br>│   └── server.<span class="hljs-keyword">go</span><br>├── pkg<br>├── proto<br>│   ├── google<br>│   │   └── api<br>│   │   │   ├── annotations.proto<br>│   │   │   └── http.proto<br>│   │   └── protobuf<br>│   │   │   └── descriptor.proto<br>│   ├── helloworld<br>│   │   ├── hello.pb.<span class="hljs-keyword">go</span><span class="hljs-comment">// proto编译后文件</span><br>│   │   ├── hello.pb.gw.<span class="hljs-keyword">go</span><span class="hljs-comment">// gateway编译后文件</span><br>│   │   └── hello_grpc.pb.<span class="hljs-keyword">go</span><span class="hljs-comment">// proto编译后接口文件</span><br>│   ├── hello.proto<br>├── server<span class="hljs-comment">// GRPC服务端</span><br>│   └── server.<span class="hljs-keyword">go</span><br>└── Makefile<br></code></pre></td></tr></table></figure><h1 id="四、服务端模块-server"><a href="#四、服务端模块-server" class="headerlink" title="四、服务端模块 server"></a>四、服务端模块 server</h1><h2 id="1、编写-hello-proto"><a href="#1、编写-hello-proto" class="headerlink" title="1、编写 hello.proto"></a>1、编写 hello.proto</h2><p>在server目录下新建文件 <code>hello.go</code> ，写入文件内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> server<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;grpc-gateway-example/proto/helloworld&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> helloService <span class="hljs-keyword">struct</span> &#123;<br>helloworld.UnimplementedHelloServer<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewHelloService</span><span class="hljs-params">()</span></span> *helloService &#123;<br><span class="hljs-keyword">return</span> &amp;helloService&#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// ctx context.Context用于接受上下文参数</span><br><span class="hljs-comment">// r *pb.HelloWorldRequest用于接受protobuf的Request参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h helloService)</span></span> SayHello(ctx context.Context, r *helloworld.HelloRequest) (*helloworld.HelloResponse, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> &amp;helloworld.HelloResponse&#123;<br>Message: <span class="hljs-string">&quot;hello grpc-gateway&quot;</span>,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、编写-grpc-go"><a href="#2、编写-grpc-go" class="headerlink" title="2、编写 grpc.go"></a>2、编写 grpc.go</h2><p>在 pkg 下新建 util 目录，新建 <code>grpc.go</code> 文件，写入内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> util<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-comment">// 将gRPC请求和HTTP请求分别调用不同的handler处理。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GrpcHandlerFunc</span><span class="hljs-params">(grpcServer *grpc.Server, otherHandler http.Handler)</span></span> http.Handler &#123;<br><span class="hljs-keyword">if</span> otherHandler == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>grpcServer.ServeHTTP(w, r)<br>&#125;)<br>&#125;<br><span class="hljs-keyword">return</span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-keyword">if</span> r.ProtoMajor == <span class="hljs-number">2</span> &amp;&amp; strings.Contains(r.Header.Get(<span class="hljs-string">&quot;Content-Type&quot;</span>), <span class="hljs-string">&quot;application/grpc&quot;</span>) &#123;<br>grpcServer.ServeHTTP(w, r)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>otherHandler.ServeHTTP(w, r)<br>&#125;<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>GrpcHandlerFunc</code> 函数是用于判断请求是来源于 Rpc 客户端还是 Restful Api 的请求，根据不同的请求注册不同的 ServeHTTP 服务；<code>r.ProtoMajor == 2</code> 也代表着请求必须基于<code>HTTP/2</code>。<br>简而言之函数将gRPC请求和HTTP请求分别调用不同的handler处理。</p></blockquote><p>如果不需要 TLS 建立安全链接，则可以使用<code>h2c</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GrpcHandlerFunc</span><span class="hljs-params">(grpcServer *grpc.Server, otherHandler http.Handler)</span></span> http.Handler &#123;<br><span class="hljs-keyword">return</span> h2c.NewHandler(http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-keyword">if</span> r.ProtoMajor == <span class="hljs-number">2</span> &amp;&amp; strings.Contains(r.Header.Get(<span class="hljs-string">&quot;Content-Type&quot;</span>), <span class="hljs-string">&quot;application/grpc&quot;</span>) &#123;<br>grpcServer.ServeHTTP(w, r)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>otherHandler.ServeHTTP(w, r)<br>&#125;<br>&#125;), &amp;http2.Server&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、编写-tls-go"><a href="#3、编写-tls-go" class="headerlink" title="3、编写 tls.go"></a>3、编写 tls.go</h2><p>在pkg下的 util 目录下，新建 <code>tls.go</code> 文件，写入内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> util<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;crypto/tls&quot;</span><br><span class="hljs-string">&quot;golang.org/x/net/http2&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-comment">// 用于处理从证书凭证文件（PEM），最终获取tls.Config作为HTTP2的使用参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetTLSConfig</span><span class="hljs-params">(certPemPath, certKeyPath <span class="hljs-type">string</span>)</span></span> *tls.Config &#123;<br><span class="hljs-keyword">var</span> certKeyPair *tls.Certificate<br>cert, _ := ioutil.ReadFile(certPemPath)<br>key, _ := ioutil.ReadFile(certKeyPath)<br><br><span class="hljs-comment">// 从一对PEM编码的数据中解析公钥/私钥对。成功则返回公钥/私钥对</span><br>pair, err := tls.X509KeyPair(cert, key)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;TLS KeyPair err: %v\n&quot;</span>, err)<br>&#125;<br><br>certKeyPair = &amp;pair<br><br><span class="hljs-keyword">return</span> &amp;tls.Config&#123;<br><span class="hljs-comment">// tls.Certificate：返回一个或多个证书，实质我们解析PEM调用的X509KeyPair的函数声明</span><br><span class="hljs-comment">// 就是func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (Certificate, error)，返回值就是Certificate</span><br>Certificates: []tls.Certificate&#123;*certKeyPair&#125;,<br><span class="hljs-comment">// http2.NextProtoTLS：NextProtoTLS是谈判期间的NPN/ALPN协议，用于HTTP/2的TLS设置</span><br>NextProtos: []<span class="hljs-type">string</span>&#123;http2.NextProtoTLS&#125;,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>GetTLSConfig 函数是用于获取TLS配置</code>，在内部，我们读取了 server.key 和 server.pem 这类证书凭证文件。经过一系列处理获取 <code>tls.Config</code> 作为 HTTP2 的使用参数。</p><h2 id="4、重新编写核心文件-server-x2F-server-go"><a href="#4、重新编写核心文件-server-x2F-server-go" class="headerlink" title="4、重新编写核心文件 server&#x2F;server.go"></a>4、重新编写核心文件 server&#x2F;server.go</h2><p>修改server目录下的server.go文件，该文件是我们服务里的核心文件，写入内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> server<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;crypto/tls&quot;</span><br><span class="hljs-string">&quot;github.com/grpc-ecosystem/grpc-gateway/v2/runtime&quot;</span><br><span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br><span class="hljs-string">&quot;google.golang.org/grpc/credentials&quot;</span><br><span class="hljs-string">&quot;grpc-gateway-example/pkg/util&quot;</span><br><span class="hljs-string">&quot;grpc-gateway-example/proto/helloworld&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>ServerPort  <span class="hljs-type">string</span><br>CertName    <span class="hljs-type">string</span><br>CertPemPath <span class="hljs-type">string</span><br>CertKeyPath <span class="hljs-type">string</span><br>EndPoint    <span class="hljs-type">string</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Serve</span><span class="hljs-params">()</span></span> (err <span class="hljs-type">error</span>) &#123;<br>EndPoint = <span class="hljs-string">&quot;:&quot;</span> + ServerPort<br><span class="hljs-comment">// 用于监听本地的网络地址通知</span><br><span class="hljs-comment">// 它的函数原型func Listen(network, address string) (Listener, error)</span><br>conn, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, EndPoint)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;TCP Listen err:%v\n&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 通过util.GetTLSConfig解析得到tls.Config，传达给http.Server服务的TLSConfig配置项使用</span><br>tlsConfig := util.GetTLSConfig(CertPemPath, CertKeyPath)<br>srv := createInternalServer(conn, tlsConfig)<br><br>log.Printf(<span class="hljs-string">&quot;gRPC and https listen on: %s\n&quot;</span>, ServerPort)<br><br><span class="hljs-comment">// NewListener将会创建一个Listener</span><br><span class="hljs-comment">// 它接受两个参数，第一个是来自内部Listener的监听器，第二个参数是tls.Config（必须包含至少一个证书）</span><br><span class="hljs-keyword">if</span> err = srv.Serve(tls.NewListener(conn, tlsConfig)); err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;ListenAndServe: %v\n&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// 将认证的中间件注册进去, 前面所获取的tlsConfig仅能给HTTP使用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createInternalServer</span><span class="hljs-params">(conn net.Listener, tlsConfig *tls.Config)</span></span> *http.Server &#123;<br><span class="hljs-keyword">var</span> opts []grpc.ServerOption<br><br><span class="hljs-comment">// 输入证书文件和服务器的密钥文件构造TLS证书凭证</span><br>creds, err := credentials.NewServerTLSFromFile(CertPemPath, CertKeyPath)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;Failed to create server TLS credentials %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// grpc.Creds()其原型为func Creds(c credentials.TransportCredentials) ServerOption</span><br><span class="hljs-comment">// 该函数返回 ServerOption，它为服务器连接设置凭据</span><br>opts = <span class="hljs-built_in">append</span>(opts, grpc.Creds(creds))<br><br><span class="hljs-comment">// 创建了一个没有注册服务的grpc服务端</span><br>grpcServer := grpc.NewServer(opts...)<br><br><span class="hljs-comment">// 注册grpc服务</span><br>helloworld.RegisterHelloServer(grpcServer, NewHelloService())<br><br><span class="hljs-comment">// 创建 grpc-gateway 关联组件</span><br><span class="hljs-comment">// context.Background()返回一个非空的空上下文。</span><br><span class="hljs-comment">// 它没有被注销，没有值，没有过期时间。它通常由主函数、初始化和测试使用，并作为传入请求的顶级上下文</span><br>ctx := context.Background()<br><span class="hljs-comment">// 从客户端的输入证书文件构造TLS凭证</span><br>dcreds, err := credentials.NewClientTLSFromFile(CertPemPath, CertName)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;Failed to create client TLS credentials %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// grpc.WithTransportCredentials 配置一个连接级别的安全凭据(例：TLS、SSL)，返回值为type DialOption</span><br><span class="hljs-comment">// grpc.DialOption DialOption选项配置我们如何设置连接（其内部具体由多个的DialOption组成，决定其设置连接的内容）</span><br>dopts := []grpc.DialOption&#123;grpc.WithTransportCredentials(dcreds)&#125;<br><br><span class="hljs-comment">// 创建HTTP NewServeMux及注册grpc-gateway逻辑</span><br><span class="hljs-comment">// runtime.NewServeMux：返回一个新的ServeMux，它的内部映射是空的；</span><br><span class="hljs-comment">// ServeMux是grpc-gateway的一个请求多路复用器。它将http请求与模式匹配，并调用相应的处理程序</span><br>gwmux := runtime.NewServeMux()<br><br><span class="hljs-comment">// RegisterHelloWorldHandlerFromEndpoint：注册HelloWorld服务的HTTP Handle到grpc端点</span><br><span class="hljs-keyword">if</span> err := helloworld.RegisterHelloHandlerFromEndpoint(ctx, gwmux, EndPoint, dopts); err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;Failed to register gw server: %v\n&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// http服务</span><br><span class="hljs-comment">// 分配并返回一个新的ServeMux</span><br>mux := http.NewServeMux()<br><span class="hljs-comment">// 为给定模式注册处理程序</span><br>mux.Handle(<span class="hljs-string">&quot;/&quot;</span>, gwmux)<br><br><span class="hljs-keyword">return</span> &amp;http.Server&#123;<br>Addr:      EndPoint,<br>Handler:   util.GrpcHandlerFunc(grpcServer, mux),<br>TLSConfig: tlsConfig,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、server流程刨析"><a href="#5、server流程刨析" class="headerlink" title="5、server流程刨析"></a>5、server流程刨析</h2><h3 id="1）启动监听"><a href="#1）启动监听" class="headerlink" title="1）启动监听"></a>1）启动监听</h3><p><code>net.Listen(&quot;tcp&quot;, EndPoint)</code> 函数用于监听本地网络地址的监听。其函数原型<code>Listen(ctx context.Context, network, address string) (Listener, error)</code></p><p>参数：</p><ul><li>network：必须是tcp, tcp4, tcp6, unix或unixpacket。</li><li>address：对于TCP网络，如果address参数中的host为空或未指定的IP地址，则会自动返回一个可用的端口或者IP地址。</li></ul><p>net.Listen(“tcp”, EndPoint)函数返回值是<code>Listener</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Listener <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// 接受等待并将下一个连接返回给Listener</span><br>Accept() (Conn, <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// 关闭Listener</span><br>Close() <span class="hljs-type">error</span><br><br><span class="hljs-comment">// 返回 Listener 的网络地址。</span><br>Addr() Addr<br>&#125;<br></code></pre></td></tr></table></figure><p><code>net.Listen</code> 会返回一个监听器的结构体，返回接下来的动作，让其执行下一步的操作，可用执行以下操作Accept、Close、Addr。</p><h3 id="2）获取TLSConfig"><a href="#2）获取TLSConfig" class="headerlink" title="2）获取TLSConfig"></a>2）获取TLSConfig</h3><p>通过调用 <code>util.GetTLSConfig</code> 函数解析得到 <code>tls.Config</code>，通过传达给 <code>createInternalServer</code>函数完成 http.Server 服务的 <code>TLSConfig</code> 配置项使用。</p><h3 id="3）创建内部服务"><a href="#3）创建内部服务" class="headerlink" title="3）创建内部服务"></a>3）创建内部服务</h3><p>程序采用HTTP2、HTTPS，需要支持TLS，在启动 <code>grpc.NewServer()</code> 前需要将<code>serverOptions</code>（服务器选项，类似于中间件，可用设置例如凭证、编解码器和保持存活参数等选项。），而前面所获取的 tlsConfig 仅能给HTTP使用，因此第一步我们要创建 grpc 的 TLS 认证凭证。</p><ol><li>创建 grpc 的 TLS 认证凭证<br>引用 <code>google.golang.org/grpc/credentials</code> 第三方包，<code>credentials</code> 包实现gRPC库支持的各种凭据，这些凭据封装了客户机与服务器进行身份验证所需的所有状态，并进行各种断言，例如，关于客户机的身份、角色或是否授权进行特定调用。</li></ol><p>我们调用 <code>NewServerTLSFromFile</code> 它能够从服务器的输入证书文件和密钥文件构造TLS凭据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServerTLSFromFile</span><span class="hljs-params">(certFile, keyFile <span class="hljs-type">string</span>)</span></span> (TransportCredentials, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// LoadX509KeyPair从一对文件中读取并解析一个公私钥对。文件中必须包含PEM编码的数据。</span><br>cert, err := tls.LoadX509KeyPair(certFile, keyFile)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-comment">// NewTLS使用tls.Config来构建基于TLS的TransportCredentials（传输凭证）</span><br><span class="hljs-keyword">return</span> NewTLS(&amp;tls.Config&#123;Certificates: []tls.Certificate&#123;cert&#125;&#125;), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>grpc ServerOption</li></ol><p>grpc.Creds() 其原型为<code>func Creds(c credentials.TransportCredentials) ServerOption</code>，返回一个为服务器连接设置凭据的ServerOption。</p><ol start="3"><li>创建 grpc 服务端<br>grpc.NewServer() 创建一个没有注册服务的grpc服务端，可以配置 <code>ServerOption</code></li><li>注册grpc服务</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 注册grpc服务</span><br>helloworld.RegisterHelloServer(grpcServer, NewHelloService())<br></code></pre></td></tr></table></figure><ol start="5"><li>创建 <code>grpc-gateway</code> 关联组件</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// context.Background()返回一个非空的空上下文。</span><br><span class="hljs-comment">// 它没有被注销，没有值，没有过期时间。它通常由主函数、初始化和测试使用，并作为传入请求的顶级上下文</span><br>ctx := context.Background()<br><span class="hljs-comment">// 从客户端的输入证书文件构造TLS凭证</span><br>dcreds, err := credentials.NewClientTLSFromFile(CertPemPath, CertName)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;Failed to create client TLS credentials %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// grpc.WithTransportCredentials 配置一个连接级别的安全凭据(例：TLS、SSL)，返回值为type DialOption</span><br><span class="hljs-comment">// grpc.DialOption DialOption选项配置我们如何设置连接（其内部具体由多个的DialOption组成，决定其设置连接的内容）</span><br>dopts := []grpc.DialOption&#123;grpc.WithTransportCredentials(dcreds)&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>创建HTTP NewServeMux及注册 <code>grpc-gateway</code> 逻辑</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建HTTP NewServeMux及注册grpc-gateway逻辑</span><br><span class="hljs-comment">// runtime.NewServeMux：返回一个新的ServeMux，它的内部映射是空的；</span><br><span class="hljs-comment">// ServeMux是grpc-gateway的一个请求多路复用器。它将http请求与模式匹配，并调用相应的处理程序</span><br>gwmux := runtime.NewServeMux()<br><br><span class="hljs-comment">// RegisterHelloWorldHandlerFromEndpoint：注册HelloWorld服务的HTTP Handle到grpc端点</span><br><span class="hljs-keyword">if</span> err := helloworld.RegisterHelloHandlerFromEndpoint(ctx, gwmux, EndPoint, dopts); err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;Failed to register gw server: %v\n&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// http服务</span><br><span class="hljs-comment">// 分配并返回一个新的ServeMux</span><br>mux := http.NewServeMux()<br><span class="hljs-comment">// 为给定模式注册处理程序</span><br>mux.Handle(<span class="hljs-string">&quot;/&quot;</span>, gwmux)<br></code></pre></td></tr></table></figure><ol start="7"><li>注册具体服务</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// RegisterHelloWorldHandlerFromEndpoint：注册HelloWorld服务的HTTP Handle到grpc端点</span><br><span class="hljs-keyword">if</span> err := helloworld.RegisterHelloHandlerFromEndpoint(ctx, gwmux, EndPoint, dopts); err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;Failed to register gw server: %v\n&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ctx：上下文</li><li>gwmux：<code>grpc-gateway</code> 的请求多路复用器</li><li>EndPoint：服务网络地址</li><li>dopts：配置好的安全凭据</li></ul><h3 id="4）创建Listener"><a href="#4）创建Listener" class="headerlink" title="4）创建Listener"></a>4）创建Listener</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewListener将会创建一个Listener</span><br><span class="hljs-comment">// 它接受两个参数，第一个是来自内部Listener的监听器，第二个参数是tls.Config（必须包含至少一个证书）</span><br><span class="hljs-keyword">if</span> err = srv.Serve(tls.NewListener(conn, tlsConfig)); err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;ListenAndServe: %v\n&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5）服务接受请求"><a href="#5）服务接受请求" class="headerlink" title="5）服务接受请求"></a>5）服务接受请求</h3><p>我们调用 <code>srv.Serve(tls.NewListener(conn, tlsConfig))</code>它是http.Server的方法，并且需要一个Listener作为参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> Serve(l net.Listener) <span class="hljs-type">error</span> &#123;<br>...<br>    <span class="hljs-keyword">defer</span> l.Close()<br>    ...<br>    baseCtx := context.Background()<br>    ...<br>    ctx := context.WithValue(baseCtx, ServerContextKey, srv)<br>    <span class="hljs-keyword">for</span> &#123;<br>        rw, e := l.Accept()<br>        ...<br>        c := srv.newConn(rw)<br>        c.setState(c.rwc, StateNew, runHooks) <span class="hljs-comment">// before Serve can return</span><br>        <span class="hljs-keyword">go</span> c.serve(ctx)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它创建了一个 context.Background() 上下文对象，并调用 Listener 的 Accept 方法开始接受请求，在获取到连接数据后使用 newConn 创建连接对象，在最后使用goroutine的方式处理连接请求，完成请求后自动关闭连接。</p><h1 id="五、验证功能"><a href="#五、验证功能" class="headerlink" title="五、验证功能"></a>五、验证功能</h1><h2 id="1、编写-client"><a href="#1、编写-client" class="headerlink" title="1、编写 client"></a>1、编写 client</h2><p>在目录client下，创建 main.go 文件，新增以下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;golang.org/x/net/context&quot;</span><br><span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br><span class="hljs-string">&quot;google.golang.org/grpc/credentials&quot;</span><br><span class="hljs-string">&quot;grpc-gateway-example/proto/helloworld&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>creds, err := credentials.NewClientTLSFromFile(<span class="hljs-string">&quot;./certs/server.pem&quot;</span>, <span class="hljs-string">&quot;grpc-gateway-example&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;Failed to create TLS credentials %v&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>conn, err := grpc.Dial(<span class="hljs-string">&quot;:50052&quot;</span>, grpc.WithTransportCredentials(creds))<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br><br>c := helloworld.NewHelloClient(conn)<br>ct := context.Background()<br>body := &amp;helloworld.HelloRequest&#123;<br>Referer: <span class="hljs-string">&quot;Grpc&quot;</span>,<br>&#125;<br><br>r, err := c.SayHello(ct, body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br><br>log.Println(r)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、启动-amp-请求"><a href="#2、启动-amp-请求" class="headerlink" title="2、启动 &amp; 请求"></a>2、启动 &amp; 请求</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"># 启动服务端<br>$ <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span> server<br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">34</span>:<span class="hljs-number">06</span> gRPC and https listen on: <span class="hljs-number">50052</span><br><br># 启动客户端<br>$ <span class="hljs-keyword">go</span> run client/main.<span class="hljs-keyword">go</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">34</span>:<span class="hljs-number">43</span> message:<span class="hljs-string">&quot;hello grpc-gateway&quot;</span><br></code></pre></td></tr></table></figure><p>执行测试Restful Api，用POST方式访问<a href="https://localhost:50052/hello_world">https://localhost:50052/hello_world</a><br><img src="/img/grpc-gateway/grpc5.png"></p><h1 id="六、最终目录结构"><a href="#六、最终目录结构" class="headerlink" title="六、最终目录结构"></a>六、最终目录结构</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go">grpc-gateway-example/<br>├── certs<span class="hljs-comment">//证书凭证</span><br>│   ├── ca.conf<br>│   ├── ca.crt<br>│   ├── ca.csr<br>│   ├── ca.key<br>│   ├── server.conf<br>│   ├── server.csr<br>│   ├── server.key<br>│   └── server.pem<br>├── client<span class="hljs-comment">// 客户端</span><br>│   └── main.<span class="hljs-keyword">go</span><br>├── cmd<span class="hljs-comment">// 命令行模块</span><br>│   ├── root.<span class="hljs-keyword">go</span><br>│   └── server.<span class="hljs-keyword">go</span><br>├── pkg<span class="hljs-comment">// 第三方公共模块</span><br>│   └── util<br>│   │   │   ├── grpc.<span class="hljs-keyword">go</span><br>│   │   │   └── tls.<span class="hljs-keyword">go</span><br>├── proto<br>│   ├── google<br>│   │   └── api<br>│   │   │   ├── annotations.proto<br>│   │   │   └── http.proto<br>│   │   └── protobuf<br>│   │   │   └── descriptor.proto<br>│   ├── helloworld<br>│   │   ├── hello.pb.<span class="hljs-keyword">go</span><span class="hljs-comment">// proto编译后文件</span><br>│   │   ├── hello.pb.gw.<span class="hljs-keyword">go</span><span class="hljs-comment">// gateway编译后文件</span><br>│   │   └── hello_grpc.pb.<span class="hljs-keyword">go</span><span class="hljs-comment">// proto编译后接口文件</span><br>│   ├── hello.proto<br>├── server<span class="hljs-comment">// GRPC服务端</span><br>│   └── server.<span class="hljs-keyword">go</span><br>├── main.<span class="hljs-keyword">go</span><br>└── Makefile<br></code></pre></td></tr></table></figure><p>参考：<br><a href="https://developer.aliyun.com/article/879486">https://developer.aliyun.com/article/879486</a><br><a href="https://eddycjy.com/posts/go/grpc-gateway/2018-02-27-hello-world/">https://eddycjy.com/posts/go/grpc-gateway/2018-02-27-hello-world/</a></p>]]></content>
    
    
    <categories>
      
      <category>gRPC学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>微服务</tag>
      
      <tag>grpc</tag>
      
      <tag>grpc-gateway</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gRPC（七）进阶：自定义身份验证</title>
    <link href="/2022/11/08/grpc-token/"/>
    <url>/2022/11/08/grpc-token/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>示例代码已经上传到github：<a href="https://github.com/Gopherlinzy/go-grpc-example">点击跳转</a><br>gRPC官方文档：<a href="https://grpc.io/docs/languages/go/basics/">点击跳转</a><br>在前面的章节中，我们介绍了两种可全局认证的方法：</p><ul><li><a href="https://linzyblog.netlify.app/2022/11/03/grpc-tls/">基于 CA 的 TLS 证书认证</a></li><li><a href="https://linzyblog.netlify.app/2022/11/07/grpc-interceptor/">拦截器 interceptor</a></li></ul><p>而在实际需求中，常常会对某些模块的 RPC 方法做特殊认证或校验，而gRPC也专门提供了这类特殊认证的接口。</p></blockquote><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>gRPC为每个gRPC方法调用提供了Token认证支持，可以基于用户传入的Token判断用户是否登陆、以及权限等，实现Token认证的前提是，需要定义一个结构体，并实现<code>credentials.PerRPCCredentials</code>接口。</p><h2 id="1、credentials-PerRPCCredentials-接口"><a href="#1、credentials-PerRPCCredentials-接口" class="headerlink" title="1、credentials.PerRPCCredentials 接口"></a>1、credentials.PerRPCCredentials 接口</h2><p>类型定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PerRPCCredentials <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// 返回需要认证的必要信息</span><br>GetRequestMetadata(ctx context.Context, uri ...<span class="hljs-type">string</span>) (<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br><span class="hljs-comment">// 是否使用安全链接(TLS)</span><br>RequireTransportSecurity() <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 gRPC 中默认定义了 <code>PerRPCCredentials</code>，是 gRPC 默认提供用于自定义认证的接口，它的作用是将所需的安全认证信息添加到每个 RPC 方法的上下文中。其包含 2 个方法：</p><ul><li><code>GetRequestMetadata</code>：获取当前请求认证所需的元数据（metadata），以 map 的形式返回本次调用的授权信息，ctx 是用来控制超时的</li><li><code>RequireTransportSecurity</code>：是否需要基于 TLS 认证进行安全传输，如果返回 true 则说明该 Credentials 需要在一个有 TLS 认证的安全连接上传输，如果当前连接并没有使用 TLS 则会报错：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">transport: cannot send secure credentials on an insecure connection<br></code></pre></td></tr></table></figure><h2 id="2、实现流程"><a href="#2、实现流程" class="headerlink" title="2、实现流程"></a>2、实现流程</h2><ul><li>在发出请求之前，gRPC 会将 Credentials（认证凭证）存放在 metadata（元数据）中进行传递。</li><li>在真正发起调用之前，gRPC 会通过 GetRequestMetadata函数，将用户定义的 Credentials（认证凭证）提取出来，并添加到 metadata（元数据）中，随着请求一起传递到服务端。</li><li>然后服务端从 metadata 中取出 Credentials 进行有效性校验。</li></ul><h1 id="二、实现自定义身份验证"><a href="#二、实现自定义身份验证" class="headerlink" title="二、实现自定义身份验证"></a>二、实现自定义身份验证</h1><p>具体分为以下两步：</p><ul><li>1）客户端请求时带上 Credentials；</li><li>2）服务端取出 Credentials，并验证有效性，一般配合拦截器使用（这里我们使用两种方法，拦截器以及RPC方法）。</li></ul><h2 id="1、目录结构"><a href="#1、目录结构" class="headerlink" title="1、目录结构"></a>1、目录结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>-grpc-example<br>├─client<br>│  ├─token_client<br>│  │   └──client.<span class="hljs-keyword">go</span><br>├─pkg<br>│  ├─token<br>│  │   └──token.<span class="hljs-keyword">go</span><br>├─proto<br>│  ├─token<br>│  │   └──token.proto<br>└─server<br>    ├─token_server<br>│  └──server.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><h2 id="2、编写IDL"><a href="#2、编写IDL" class="headerlink" title="2、编写IDL"></a>2、编写IDL</h2><p>在 proto&#x2F;token 文件夹下的 token.proto 文件中，写入如下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br>option go_package = <span class="hljs-string">&quot;./proto/token;token&quot;</span>;<br><span class="hljs-keyword">package</span> tokenservice;<br><br><span class="hljs-comment">// 验证参数</span><br>message TokenValidateParam &#123;<br>  <span class="hljs-type">string</span> token = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int32</span> uid = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 请求参数</span><br>message Request &#123;<br>  <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 请求返回</span><br>message Response &#123;<br>  <span class="hljs-type">int32</span> uid = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">string</span> name = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 服务</span><br>service TokenService &#123;<br>  rpc Token(Request) returns (Response);<br>&#125;<br></code></pre></td></tr></table></figure><p>在Makefile文件中写入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">token:<br>protoc --go_out=. --<span class="hljs-keyword">go</span>-grpc_out=. ./proto/token<span class="hljs-comment">/*.proto</span><br></code></pre></td></tr></table></figure><p>用<code>make token</code>指令生成Go代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">➜ <span class="hljs-built_in">make</span> token<br>protoc --go_out=. --<span class="hljs-keyword">go</span>-grpc_out=. ./proto/token<span class="hljs-comment">/*.proto</span><br></code></pre></td></tr></table></figure><p><img src="/img/grpc_token/grpc1.png"></p><h2 id="3、编写基础模板和空定义"><a href="#3、编写基础模板和空定义" class="headerlink" title="3、编写基础模板和空定义"></a>3、编写基础模板和空定义</h2><p>我们先把基础的模板和空定义写出来在进行完善</p><h3 id="1）server-go"><a href="#1）server-go" class="headerlink" title="1）server.go"></a>1）server.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> Address = <span class="hljs-string">&quot;127.0.0.1:8888&quot;</span><br><br><span class="hljs-keyword">type</span> TokenService <span class="hljs-keyword">struct</span> &#123;<br>token.UnimplementedTokenServiceServer<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listen, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, Address)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;start error:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">var</span> opts []grpc.ServerOption<br><br>server := grpc.NewServer(opts...)<br>token.RegisterTokenServiceServer(server, &amp;TokenService&#123;&#125;)<br><br>fmt.Println(<span class="hljs-string">&quot;服务启动成功....&quot;</span>)<br>server.Serve(listen)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2）client-go"><a href="#2）client-go" class="headerlink" title="2）client.go"></a>2）client.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> Address = <span class="hljs-string">&quot;127.0.0.1:8888&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> opts []grpc.DialOption<br><br>conn, err := grpc.Dial(Address, opts...)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;grpc.Dial error:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><span class="hljs-comment">// 实例化客户端</span><br>client := token.NewTokenServiceClient(conn)<br><br><span class="hljs-comment">// 调用具体方法</span><br>token, err := client.Token(context.Background(), &amp;token.Request&#123;Name: <span class="hljs-string">&quot;linzy&quot;</span>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;client.Token error:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;return result:&quot;</span>, token)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、实现PerRPCCredentials-接口"><a href="#4、实现PerRPCCredentials-接口" class="headerlink" title="4、实现PerRPCCredentials 接口"></a>4、实现PerRPCCredentials 接口</h2><p>我们在 pkg&#x2F;token 目录里的 token.go 文件内实现PerRPCCredentials 接口的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> IsTLS = <span class="hljs-literal">false</span><br><br><span class="hljs-comment">// 定义一个认证的结构体，这里是因为我在porto写好了一个数据结构</span><br><span class="hljs-comment">// 也可以自定义认证字段</span><br><span class="hljs-keyword">type</span> TokenAuth <span class="hljs-keyword">struct</span> &#123;<br>token.TokenValidateParam<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *TokenAuth)</span></span> GetRequestMetadata(ctx context.Context, uri ...<span class="hljs-type">string</span>) (<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 将 Credentials（认证凭证）存放在 metadata（元数据）中进行传递。</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;uid&quot;</span>:   strconv.FormatInt(<span class="hljs-type">int64</span>(x.GetUid()), <span class="hljs-number">10</span>),<br><span class="hljs-string">&quot;token&quot;</span>: x.GetToken(),<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *TokenAuth)</span></span> RequireTransportSecurity() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> IsTLS<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、实现认证功能"><a href="#5、实现认证功能" class="headerlink" title="5、实现认证功能"></a>5、实现认证功能</h2><p>我们已经实现了客户端请求时带上 Credentials 凭证，后面就需要实现服务端的功能，在获取授权信息并校验有效性。</p><h3 id="1）实现拦截器认证"><a href="#1）实现拦截器认证" class="headerlink" title="1）实现拦截器认证"></a>1）实现拦截器认证</h3><p>在 <code>pkg/Interceptor</code> 目录下的 Interceptor.go 文件内写入以下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 用一元拦截器实现认证</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ServerInterceptorCheckToken</span><span class="hljs-params">()</span></span> grpc.UnaryServerInterceptor &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">handler grpc.UnaryHandler)</span></span> (resp <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 验证token</span><br>_, err = CheckToken(ctx)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Interceptor 拦截器内token认证失败\n&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;Interceptor 拦截器内token认证成功\n&quot;</span>)<br><span class="hljs-keyword">return</span> handler(ctx, req)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 验证</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CheckToken</span><span class="hljs-params">(ctx context.Context)</span></span> (*token.Response, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 取出元数据</span><br>md, b := metadata.FromIncomingContext(ctx)<br><span class="hljs-keyword">if</span> !b &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, status.Error(codes.InvalidArgument, <span class="hljs-string">&quot;token信息不存在&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> token, uid <span class="hljs-type">string</span><br><span class="hljs-comment">// 取出token</span><br>tokenInfo, ok := md[<span class="hljs-string">&quot;token&quot;</span>]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, status.Error(codes.InvalidArgument, <span class="hljs-string">&quot;token不存在&quot;</span>)<br>&#125;<br><br>token = tokenInfo[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment">// 取出uid</span><br>uidTmp, ok := md[<span class="hljs-string">&quot;uid&quot;</span>]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, status.Error(codes.InvalidArgument, <span class="hljs-string">&quot;uid不存在&quot;</span>)<br>&#125;<br>uid = uidTmp[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment">//验证</span><br>sum := md5.Sum([]<span class="hljs-type">byte</span>(uid))<br>md5Str := fmt.Sprintf(<span class="hljs-string">&quot;%x&quot;</span>, sum)<br><span class="hljs-keyword">if</span> md5Str != token &#123;<br>fmt.Println(<span class="hljs-string">&quot;md5Str:&quot;</span>, md5Str)<br>fmt.Println(<span class="hljs-string">&quot;uid:&quot;</span>, uid)<br>fmt.Println(<span class="hljs-string">&quot;token:&quot;</span>, token)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, status.Error(codes.InvalidArgument, <span class="hljs-string">&quot;token验证失败&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>gPRC 传输的时候把授权信息存放在 metada 的，所以需要先获取 metadata。通过<code>metadata.FromIncomingContext</code>可以从 ctx 中取出本次调用的 metadata，然后再从 md 中取出授权信息并校验即可。</p></blockquote><p>在server.go文件内添加拦截器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">opts = <span class="hljs-built_in">append</span>(opts, grpc.UnaryInterceptor(Interceptor.ServerInterceptorCheckToken()))<br></code></pre></td></tr></table></figure><h3 id="2）实现RPC方法认证"><a href="#2）实现RPC方法认证" class="headerlink" title="2）实现RPC方法认证"></a>2）实现RPC方法认证</h3><p>实现了校验有效性我们就需要在 <code>server.go</code> 服务端实现Token RPC的方法进行授权认证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TokenService <span class="hljs-keyword">struct</span> &#123;<br>token.UnimplementedTokenServiceServer<br>tokenAuth.TokenAuth<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u TokenService)</span></span> Token(ctx context.Context, r *token.Request) (*token.Response, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 验证token</span><br>_, err := Interceptor.CheckToken(ctx)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Token RPC方法内token认证失败\n&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%v Token RPC方法内token认证成功\n&quot;</span>, r.GetName())<br><span class="hljs-keyword">return</span> &amp;token.Response&#123;Name: r.GetName()&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同样的在<code>client.go</code> 文件内输入token信息，并调用<code>grpc.WithPerRPCCredentials</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// token信息</span><br>auth := tokenAuth.TokenAuth&#123;<br>token.TokenValidateParam&#123;<br>Token: <span class="hljs-string">&quot;81dc9bdb52d04dc20036dbd8313ed055&quot;</span>,<br>Uid:   <span class="hljs-number">1234</span>,<br>&#125;,<br>&#125;<br>opts = <span class="hljs-built_in">append</span>(opts, grpc.WithPerRPCCredentials(&amp;auth))<br></code></pre></td></tr></table></figure><h2 id="6、启动-amp-请求"><a href="#6、启动-amp-请求" class="headerlink" title="6、启动 &amp; 请求"></a>6、启动 &amp; 请求</h2><p>输入一个正确的token：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"># 启动服务端<br>$ <span class="hljs-keyword">go</span> run server.<span class="hljs-keyword">go</span><br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">52505</span><br>服务启动成功....<br>Interceptor 拦截器内token认证成功<br><br>linzy Token RPC方法内token认证成功<br><br># 启动客户端<br>$ <span class="hljs-keyword">go</span> run client.<span class="hljs-keyword">go</span> <br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">52545</span><br><span class="hljs-keyword">return</span> result: name:<span class="hljs-string">&quot;linzy&quot;</span><br></code></pre></td></tr></table></figure><p>修改token信息为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// token信息</span><br>auth := tokenAuth.TokenAuth&#123;<br>token.TokenValidateParam&#123;<br>Token: <span class="hljs-string">&quot;81dc9bdb52d0ed0585&quot;</span>,<br>Uid:   <span class="hljs-number">1234</span>,<br>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"># 启动服务端<br>$ <span class="hljs-keyword">go</span> run server.<span class="hljs-keyword">go</span><br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">52505</span><br>服务启动成功....<br>md5Str: <span class="hljs-number">81</span>dc9bdb52d04dc20036dbd8313ed055<br>uid: <span class="hljs-number">1234</span><br>token: <span class="hljs-number">81</span>dc9bdb52d0ed0585<br>Interceptor 拦截器内token认证失败<br><br># 启动客户端<br>$ <span class="hljs-keyword">go</span> run client.<span class="hljs-keyword">go</span> <br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">52857</span><br>client.Token <span class="hljs-type">error</span>: rpc <span class="hljs-type">error</span>: code = InvalidArgument desc = token验证失败<br></code></pre></td></tr></table></figure><h2 id="7、实现RequireTransportSecurity-方法"><a href="#7、实现RequireTransportSecurity-方法" class="headerlink" title="7、实现RequireTransportSecurity()方法"></a>7、实现RequireTransportSecurity()方法</h2><p>身份认证功能已经完成，但是我们gRPC通信还是明文传输，对于如此重要的信息肯定要建立安全连接，所以要实现 RequireTransportSecurity 方法。</p><p>方法实现很简单，我们只需要建立安全连接的时候，返回一个true就行，使用我们之前的证书进行TLS连接即可。</p><blockquote><p>具体可以看我的上一篇<a href="https://linzyblog.netlify.app/2022/11/03/grpc-tls/">《通过TLS建立安全连接》</a></p></blockquote><p>server.go添加以下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> tokenAuth.IsTLS &#123;<br><span class="hljs-comment">// TLS认证</span><br><span class="hljs-comment">// 根据服务端输入的证书文件和密钥构造 TLS 凭证</span><br>c, err := credentials.NewServerTLSFromFile(<span class="hljs-string">&quot;./conf/server_side_TLS/server.pem&quot;</span>, <span class="hljs-string">&quot;./conf/server_side_TLS/server.key&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;credentials.NewServerTLSFromFile err: %v&quot;</span>, err)<br>&#125;<br>opts = <span class="hljs-built_in">append</span>(opts, grpc.Creds(c))<br>&#125;<br></code></pre></td></tr></table></figure><p>client.go添加以下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> tokenAuth.IsTLS &#123;<br><span class="hljs-comment">//打开tls 走tls认证</span><br><span class="hljs-comment">// 根据客户端输入的证书文件和密钥构造 TLS 凭证。</span><br><span class="hljs-comment">// 第二个参数 serverNameOverride 为服务名称。</span><br>c, err := credentials.NewClientTLSFromFile(<span class="hljs-string">&quot;./conf/server_side_TLS/server.pem&quot;</span>, <span class="hljs-string">&quot;go-grpc-example&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;credentials.NewClientTLSFromFile err: %v&quot;</span>, err)<br>&#125;<br>opts = <span class="hljs-built_in">append</span>(opts, grpc.WithTransportCredentials(c))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>opts = <span class="hljs-built_in">append</span>(opts, grpc.WithInsecure())<br>&#125;<br></code></pre></td></tr></table></figure><p>我们只需要修改token.go文件内的<code>IsTLS</code>变量就可以实现是否使用安全链接(TLS)。</p><p>启动 &amp; 请求之后我们抓个包看一下是否已经建立安全链接了了。</p><p><img src="/img/grpc_token/grpc2.png"><br><img src="/img/grpc_token/grpc3.png"></p><h1 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h1><p>1）实现<code>credentials.PerRPCCredentials</code>接口就可以把数据当做 gRPC 中的 Credential 在添加到 metadata 中，跟着请求一起传递到服务端；<br>2）服务端从 ctx 中解析 metadata，然后从 metadata 中获取 授权信息并进行验证；<br>3）可以借助 Interceptor 实现全局身份验证。</p>]]></content>
    
    
    <categories>
      
      <category>gRPC学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>微服务</tag>
      
      <tag>grpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gRPC（六）进阶：拦截器 interceptor</title>
    <link href="/2022/11/07/grpc-interceptor/"/>
    <url>/2022/11/07/grpc-interceptor/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>示例代码已经上传到github：<a href="https://github.com/Gopherlinzy/go-grpc-example">点击跳转</a><br>gRPC官方文档：<a href="https://grpc.io/docs/languages/go/basics/">点击跳转</a></p></blockquote><h1 id="一、拦截器概述"><a href="#一、拦截器概述" class="headerlink" title="一、拦截器概述"></a>一、拦截器概述</h1><h2 id="1、什么是拦截器？"><a href="#1、什么是拦截器？" class="headerlink" title="1、什么是拦截器？"></a>1、什么是拦截器？</h2><p>在常规的 HTTP 服务器中，我们可以设置有一个中间件将我们的处理程序包装在服务器上。此中间件可用于在实际提供正确内容之前执行服务器想要执行的任何操作，它可以是身份验证或日志记录或任​​何东西。</p><blockquote><p>中间件：<br>中间件供系统软件和应用软件之间连接、便于软件各部件之间的沟通的计算机软件，相当于不同技术、工具和数据库之间的桥梁，例如他可以记录响应时长、记录请求和响应数据日志，身份验证等。<br>中间件可以在拦截到发送给 handler 的请求，且可以拦截 handler 返回给客户端的响应</p></blockquote><p><code>gRPC 不同，它允许在服务器和客户端都使用拦截器。</code></p><ul><li>服务器端拦截器是 gRPC 服务器在到达实际 RPC 方法之前调用的函数。它可以用于多种用途，例如日志记录、跟踪、速率限制、身份验证和授权。</li><li>同样，客户端拦截器是 gRPC 客户端在调用实际 RPC 之前调用的函数。<br><img src="/img/grpc_interceptor/grpc1.png"></li></ul><h2 id="2、gRPC-拦截器核心概念"><a href="#2、gRPC-拦截器核心概念" class="headerlink" title="2、gRPC 拦截器核心概念"></a>2、gRPC 拦截器核心概念</h2><ul><li>一元是我们大多数人使用的。就是发送一个请求并获得一个响应。</li><li>流是当您发送或接收 protobuf 消息的数据管道时。这意味着如果一个 gRPC 服务响应一个流，消费者可以在这个流中期望多个响应。</li></ul><blockquote><p>具体可以看我讲<a href="https://linzyblog.netlify.app/2022/11/03/grpc-stream/">《gRPC流》</a> 其中提到了流和一元的详细概念</p></blockquote><p>拦截器正如他名字的含义，它在 API 请求被执行之前拦截它们。这可用于<code>记录、验证或在处理 API 请求之前发生的任何事情</code>，拦截器还可以做统一接口的认证工作，不需要每一个接口都做一次认证了，多个接口多次访问，只需要在统一个地方认证即可。使用 HTTP API，这在 Golang 中很容易，你可以使用中间件包装 HTTP 处理程序。</p><p>gRPC有两种数据通信方式，那必然有两种拦截器：</p><ul><li><code>UnaryInterceptors</code> — 用于 API 调用，即一个客户端请求和一个服务器响应。</li><li><code>StreamInterceptors</code> —用于 API 调用，其中客户端发送请求但接收回数据流，允许服务器随时间响应多个项目。实际上，由于 gRPC 是双向的，因此客户端也可以使用它来发送数据。</li></ul><h2 id="3、服务端拦截器和客户端拦截器"><a href="#3、服务端拦截器和客户端拦截器" class="headerlink" title="3、服务端拦截器和客户端拦截器"></a>3、服务端拦截器和客户端拦截器</h2><p>gRPC允许在客户端和服务器以及一元和流式调用中使用拦截器，上面提到过<code>gRPC允许在服务器和客户端都使用拦截器</code>，那么我们就有 4 种不同的拦截器。</p><p>如果我们去<a href="https://pkg.go.dev/google.golang.org/grpc?utm_source=godoc">go-grpc</a>库看看他们是如何处理这个的，我们可以看到四个不同的用例。两种拦截器类型都可用于服务器和客户端。</p><ul><li>UnaryClientInterceptor — 在客户端拦截所有一元 gRPC 调用。</li><li>UnaryServerInterceptor — 在服务器端拦截一元 gRPC 调用。</li><li>StreamClientInterceptor — 拦截器在创建客户端流时触发。</li><li>StreamServerInterceptor — 拦截器在服务器上执行 Stream 之前触发。</li></ul><p><img src="/img/grpc_interceptor/grpc2.png"></p><p>关于gRPC拦截器类型的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> UnaryClientInterceptor <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, method <span class="hljs-type">string</span>, req, reply <span class="hljs-keyword">interface</span>&#123;&#125;, cc *ClientConn, invoker UnaryInvoker, opts ...CallOption)</span></span> <span class="hljs-type">error</span><br><br><span class="hljs-keyword">type</span> UnaryServerInterceptor <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;, info *UnaryServerInfo, handler UnaryHandler)</span></span> (resp <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>)<br><br><span class="hljs-keyword">type</span> StreamClientInterceptor <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, desc *StreamDesc, cc *ClientConn, method <span class="hljs-type">string</span>, streamer Streamer, opts ...CallOption)</span></span> (ClientStream, <span class="hljs-type">error</span>)<br><br><span class="hljs-keyword">type</span> StreamServerInterceptor <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(srv <span class="hljs-keyword">interface</span>&#123;&#125;, ss ServerStream, info *StreamServerInfo, handler StreamHandler)</span></span> <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure><h2 id="4、Metadata-元数据"><a href="#4、Metadata-元数据" class="headerlink" title="4、Metadata 元数据"></a>4、Metadata 元数据</h2><p>gRPC 允许发送自定义元数据。元数据是键值的一个非常简单的概念。</p><p>如果我们查看<a href="https://pkg.go.dev/google.golang.org/grpc/metadata#MD">golang 元数据规范</a>，我们可以看到它是一个map[string][]string。</p><blockquote><p>元数据可以作为header或trailer发送</p><ul><li>header应该在数据之前发送。</li><li>trailer应在处理完毕后发送。</li></ul></blockquote><p><code>元数据允许我们在不更改 protobuf 消息的情况下向请求中添加数据。</code>这通常用于添加与请求相关但不属于请求的数据。</p><p>例如，我们可以在请求的元数据中添加 JWT 令牌作为身份验证。这允许我们在不改变实际服务器逻辑的情况下使用逻辑扩展 API 端点。这对于身份验证、速率限制或日志记录很有用。</p><p>理论够了！我相信我们已经准备好开始测试它了。</p><h1 id="二、拦截器的使用"><a href="#二、拦截器的使用" class="headerlink" title="二、拦截器的使用"></a>二、拦截器的使用</h1><h2 id="1、目录结构"><a href="#1、目录结构" class="headerlink" title="1、目录结构"></a>1、目录结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>-grpc-example<br>├─client<br>│  ├─hello_client<br>│  │   └──client.<span class="hljs-keyword">go</span><br>│  ├─stream_client<br>│  │   └──client.<span class="hljs-keyword">go</span><br>├─pkg<br>│  ├─Interceptor<br>│  │   └──Interceptor.<span class="hljs-keyword">go</span><br>├─proto<br>│  ├─hello<br>│  ├─stream<br>└─server<br>    ├─hello_server<br>│  └──server.<span class="hljs-keyword">go</span><br>    ├─stream_server<br>    │  └──server.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><blockquote><p>偷个懒，这里我们就拿之前的一元和流的示例上使用拦截器<br>示例我们做一个简单的 interceptor 示例，显示拦截器调用RPC方法前的时间、当前运行程序的操作系统、RPC方法结束后的时间，以及调用RPC的方法名。<br>创建<code>pkg/Interceptor</code>目录，在<code>Interceptor.go</code>文件里我们写拦截器的方法。</p></blockquote><h2 id="2、一元拦截器"><a href="#2、一元拦截器" class="headerlink" title="2、一元拦截器"></a>2、一元拦截器</h2><h3 id="1）UnaryClientInterceptor"><a href="#1）UnaryClientInterceptor" class="headerlink" title="1）UnaryClientInterceptor"></a>1）UnaryClientInterceptor</h3><p>作用：这是我们可以使用客户端元数据丰富消息的地方，例如有关客户端运行的硬件或操作系统的一些信息，或者可能启动我们的跟踪流程。</p><p>客户端一元拦截器类型为 <code>grpc.UnaryClientInterceptor</code>，具体如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UnaryClientInterceptor</span><span class="hljs-params">()</span></span> grpc.UnaryClientInterceptor &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, method <span class="hljs-type">string</span>, req, reply <span class="hljs-keyword">interface</span>&#123;&#125;,</span></span><br><span class="hljs-params"><span class="hljs-function">cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 预处理(pre-processing)</span><br>start := time.Now()<br><span class="hljs-comment">// 获取正在运行程序的操作系统</span><br>cos := runtime.GOOS<br><span class="hljs-comment">// 将操作系统信息附加到传出请求</span><br>ctx = metadata.AppendToOutgoingContext(ctx, <span class="hljs-string">&quot;client-os&quot;</span>, cos)<br><br><span class="hljs-comment">// 可以看做是当前 RPC 方法，一般在拦截器中调用 invoker 能达到调用 RPC 方法的效果，当然底层也是 gRPC 在处理。</span><br><span class="hljs-comment">// 调用RPC方法(invoking RPC method)</span><br>err := invoker(ctx, method, req, reply, cc, opts...)<br><br><span class="hljs-comment">// 后处理(post-processing)</span><br>end := time.Now()<br>log.Printf(<span class="hljs-string">&quot;RPC: %s,,client-OS: &#x27;%v&#x27; req:%v start time: %s, end time: %s, err: %v&quot;</span>, method, cos, req, start.Format(time.RFC3339), end.Format(time.RFC3339), err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>invoker(ctx, method, req, reply, cc, opts...)</code> 是真正调用 RPC 方法。因此我们可以在调用前后增加自己的逻辑：比如调用前检查一下参数之类的，调用后记录一下本次请求处理耗时等。</p></blockquote><p>所谓的拦截器其实就是一个函数，可以分为<code>预处理(pre-processing)、调用RPC方法(invoking RPC method)、后处理(post-processing)</code>三个阶段。</p><ul><li>ctx：Go语言中的上下文，一般和 Goroutine 配合使用，起到超时控制的效果</li><li>method：当前调用的 RPC 方法名</li><li>req：本次请求的参数，只有在处理前阶段修改才有效</li><li>reply：本次请求响应，需要在处理后阶段才能获取到</li><li>cc：gRPC 连接信息</li><li>invoker：可以看做是当前 RPC 方法，一般在拦截器中调用 invoker 能达到调用 RPC 方法的效果，当然底层也是 gRPC 在处理。</li><li>opts：本次调用指定的 options 信息</li></ul><p>作为一个客户端拦截器，可以在处理前检查 req 看看本次请求带没带 token 之类的鉴权数据，没有的话就可以在拦截器中加上。</p><p><strong>hello_client</strong><br>建立连接时通过 grpc.WithUnaryInterceptor 指定要加载的拦截器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//添加一元拦截器</span><br>conn, err := grpc.Dial(<span class="hljs-string">&quot;:&quot;</span>+PORT, grpc.WithInsecure(),<br>grpc.WithUnaryInterceptor(Interceptor.UnaryClientInterceptor()))<br></code></pre></td></tr></table></figure><h3 id="2）UnaryServerInterceptor"><a href="#2）UnaryServerInterceptor" class="headerlink" title="2）UnaryServerInterceptor"></a>2）UnaryServerInterceptor</h3><p>作用：我们可能想要对请求的真实性进行一些检查，例如对其进行授权，或者检查某些字段是否存在&#x2F;验证请求。</p><p>客户端拦截器与服务端拦截器类似：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UnaryServerInterceptor</span><span class="hljs-params">()</span></span> grpc.UnaryServerInterceptor &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">handler grpc.UnaryHandler)</span></span> (resp <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 预处理(pre-processing)</span><br>start := time.Now()<br><span class="hljs-comment">// 从传入上下文获取元数据</span><br>md, ok := metadata.FromIncomingContext(ctx)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;couldn&#x27;t parse incoming context metadata&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 检索客户端操作系统，如果它不存在，则此值为空</span><br>os := md.Get(<span class="hljs-string">&quot;client-os&quot;</span>)<br><span class="hljs-comment">// 获取客户端IP地址</span><br>ip, err := getClientIP(ctx)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-comment">// RPC 方法真正执行的逻辑</span><br><span class="hljs-comment">// 调用RPC方法(invoking RPC method)</span><br>m, err := handler(ctx, req)<br>end := time.Now()<br><span class="hljs-comment">// 记录请求参数 耗时 错误信息等数据</span><br><span class="hljs-comment">// 后处理(post-processing)</span><br>log.Printf(<span class="hljs-string">&quot;RPC: %s,client-OS: &#x27;%v&#x27; and IP: &#x27;%v&#x27; req:%v start time: %s, end time: %s, err: %v&quot;</span>, info.FullMethod, os, ip, req, start.Format(time.RFC3339), end.Format(time.RFC3339), err)<br><span class="hljs-keyword">return</span> m, err<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// GetClientIP检查上下文以检索客户机的ip地址</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getClientIP</span><span class="hljs-params">(ctx context.Context)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>p, ok := peer.FromContext(ctx)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;couldn&#x27;t parse client IP address&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> p.Addr.String(), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code> handler(ctx, req)</code> 是真正执行 RPC 方法，与invoker的调用不一样，不要搞混了。因此我们可以在真正执行前后检查数据：比如查看客户端操作系统和客户端IP地址、记录请求参数，耗时，错误信息等数据。</p></blockquote><p>参数具体含义如下：</p><ul><li>ctx：请求上下文</li><li>req：RPC 方法的请求参数</li><li>info：RPC 方法的所有信息</li><li>handler：RPC 方法真正执行的逻辑</li></ul><p><strong>hello_server</strong></p><p>服务端则是在 NewServer 时指定拦截器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//添加一元拦截器</span><br>server := grpc.NewServer(grpc.UnaryInterceptor(Interceptor.UnaryServerInterceptor()))<br></code></pre></td></tr></table></figure><h3 id="3）启动-amp-请求"><a href="#3）启动-amp-请求" class="headerlink" title="3）启动 &amp; 请求"></a>3）启动 &amp; 请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"># 启动服务端<br>$ <span class="hljs-keyword">go</span> run server.<span class="hljs-keyword">go</span><br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">51081</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">18</span>:<span class="hljs-number">37</span>:<span class="hljs-number">28</span> RPC: /hello.UserService/SayHi,client-OS: <span class="hljs-string">&#x27;[windows]&#x27;</span> and IP: <span class="hljs-string">&#x27;127.0.0.1:51104&#x27;</span> req:name:<span class="hljs-string">&quot;lin钟一&quot;</span> start time: <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T18:<span class="hljs-number">37</span>:<span class="hljs-number">28</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br>, end time: <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T18:<span class="hljs-number">37</span>:<span class="hljs-number">28</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>, err: &lt;<span class="hljs-literal">nil</span>&gt;<br><br># 启动客户端<br>$ <span class="hljs-keyword">go</span> run client.<span class="hljs-keyword">go</span> <br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">51102</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">18</span>:<span class="hljs-number">37</span>:<span class="hljs-number">28</span> RPC: /hello.UserService/SayHi,,client-OS: <span class="hljs-string">&#x27;windows&#x27;</span> req:name:<span class="hljs-string">&quot;lin钟一&quot;</span> start time: <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T18:<span class="hljs-number">37</span>:<span class="hljs-number">28</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>, end time: <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T18:<span class="hljs-number">3</span><br><span class="hljs-number">7</span>:<span class="hljs-number">28</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>, err: &lt;<span class="hljs-literal">nil</span>&gt;<br>resp: hi lin钟一--<span class="hljs-number">-2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span> <span class="hljs-number">18</span>:<span class="hljs-number">37</span>:<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><h2 id="3、流式拦截器"><a href="#3、流式拦截器" class="headerlink" title="3、流式拦截器"></a>3、流式拦截器</h2><p>流拦截器过程和一元拦截器有所不同，同样可以分为3个阶段：</p><ul><li>1）预处理(pre-processing)</li><li>2）调用RPC方法(invoking RPC method)</li><li>3）后处理(post-processing)</li></ul><p>预处理阶段和一元拦截器类似，但是调用RPC方法和后处理这两个阶段则完全不同。</p><p>StreamAPI 的请求和响应都是通过 Stream 进行传递的，更进一步是<code>通过 Streamer 调用 SendMsg 和 RecvMsg 这两个方法获取的</code>。</p><p>然后 Streamer 又是调用RPC方法来获取的，所以在流拦截器中我们可以<code>对 Streamer 进行包装</code>，然后实现 <code>SendMsg</code> 和 <code>RecvMsg</code> 这两个方法。</p><h3 id="1）StreamClientInterceptor"><a href="#1）StreamClientInterceptor" class="headerlink" title="1）StreamClientInterceptor"></a>1）StreamClientInterceptor</h3><p>作用：例如，如果我们将 100 个对象的列表传输到服务器，例如文件或视频的块，我们可以在发送每个块之前拦截，并验证校验和等内容是否有效，将元数据添加到帧等。</p><p>本例中通过结构体嵌入的方式，对 Streamer 进行包装，在 SendMsg 和 RecvMsg 之前打印出具体的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StreamClientInterceptor</span><span class="hljs-params">()</span></span> grpc.StreamClientInterceptor &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn,</span></span><br><span class="hljs-params"><span class="hljs-function">method <span class="hljs-type">string</span>, streamer grpc.Streamer, opts ...grpc.CallOption)</span></span> (grpc.ClientStream, <span class="hljs-type">error</span>) &#123;<br>log.Printf(<span class="hljs-string">&quot;opening client streaming to the server method: %v&quot;</span>, method)<br><span class="hljs-comment">// 调用Streamer函数，获得ClientStream</span><br>stream, err := streamer(ctx, desc, cc, method)<br><span class="hljs-keyword">return</span> newStreamClient(stream), err<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 嵌入式 streamClient 允许我们访问SendMsg和RecvMsg函数</span><br><span class="hljs-keyword">type</span> streamClient <span class="hljs-keyword">struct</span> &#123;<br>grpc.ClientStream<br>&#125;<br><br><span class="hljs-comment">// 对ClientStream进行包装</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newStreamClient</span><span class="hljs-params">(c grpc.ClientStream)</span></span> grpc.ClientStream &#123;<br><span class="hljs-keyword">return</span> &amp;streamClient&#123;c&#125;<br>&#125;<br><br><span class="hljs-comment">// RecvMsg从流中接收消息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *streamClient)</span></span> RecvMsg(m <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 在这里，我们可以对接收到的消息执行额外的逻辑，例如</span><br><span class="hljs-comment">// 验证</span><br>log.Printf(<span class="hljs-string">&quot;Receive a message (Type: %T) at %v&quot;</span>, m, time.Now().Format(time.RFC3339))<br><span class="hljs-keyword">if</span> err := e.ClientStream.RecvMsg(m); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// RecvMsg从流中接收消息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *streamClient)</span></span> SendMsg(m <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 在这里，我们可以对接收到的消息执行额外的逻辑，例如</span><br><span class="hljs-comment">// 验证</span><br>log.Printf(<span class="hljs-string">&quot;Send a message (Type: %T) at %v&quot;</span>, m, time.Now().Format(time.RFC3339))<br><span class="hljs-keyword">if</span> err := e.ClientStream.SendMsg(m); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>因为SendMsg 和 RecvMsg 方法 ClientStream接口内的方法，我们需要先调用 <code>streamer(ctx, desc, cc, method)</code>函数获取到<code>ClientStream</code>再对他进一步结构体封装，实现他SendMsg 和 RecvMsg 方法。</p></blockquote><p><strong>stream_client</strong><br>通过 grpc.WithStreamInterceptor 指定要加载的拦截器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">conn, err := grpc.Dial(<span class="hljs-string">&quot;:&quot;</span>+PORT, grpc.WithInsecure(), grpc.WithStreamInterceptor(Interceptor.StreamClientInterceptor()))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;grpc.Dial err: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br></code></pre></td></tr></table></figure><h3 id="2）-StreamServerInterceptor"><a href="#2）-StreamServerInterceptor" class="headerlink" title="2） StreamServerInterceptor"></a>2） StreamServerInterceptor</h3><p>作用：例如，如果我们正在接收上述文件块，也许我们想确定在传输过程中没有丢失任何内容，并在存储之前再次验证校验和。</p><p>与客户端类似：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StreamServerInterceptor</span><span class="hljs-params">()</span></span> grpc.StreamServerInterceptor &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(srv <span class="hljs-keyword">interface</span>&#123;&#125;, ss grpc.ServerStream,</span></span><br><span class="hljs-params"><span class="hljs-function">info *grpc.StreamServerInfo, handler grpc.StreamHandler)</span></span> <span class="hljs-type">error</span> &#123;<br>wrapper := newStreamServer(ss)<br><span class="hljs-keyword">return</span> handler(srv, wrapper)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 嵌入式EdgeServerStream允许我们访问RecvMsg函数</span><br><span class="hljs-keyword">type</span> streamServer <span class="hljs-keyword">struct</span> &#123;<br>grpc.ServerStream<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newStreamServer</span><span class="hljs-params">(s grpc.ServerStream)</span></span> grpc.ServerStream &#123;<br><span class="hljs-keyword">return</span> &amp;streamServer&#123;s&#125;<br>&#125;<br><br><span class="hljs-comment">// RecvMsg从流中接收消息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *streamServer)</span></span> RecvMsg(m <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 在这里，我们可以对接收到的消息执行额外的逻辑，例如</span><br><span class="hljs-comment">// 验证</span><br>log.Printf(<span class="hljs-string">&quot;Receive a message (Type: %T) at %v&quot;</span>, m, time.Now().Format(time.RFC3339))<br><span class="hljs-keyword">if</span> err := e.ServerStream.RecvMsg(m); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// RecvMsg从流中接收消息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *streamServer)</span></span> SendMsg(m <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 在这里，我们可以对接收到的消息执行额外的逻辑，例如</span><br><span class="hljs-comment">// 验证</span><br>log.Printf(<span class="hljs-string">&quot;Send a message (Type: %T) at %v&quot;</span>, m, time.Now().Format(time.RFC3339))<br><span class="hljs-keyword">if</span> err := e.ServerStream.SendMsg(m); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>StreamServerInterceptor 拦截器自带 ServerStream 参数，我们直接同样的形式进行结构体嵌入封装，在实现他的方法。</p></blockquote><p><strong>stream_server</strong><br>通过 grpc.StreamInterceptor 指定要加载的拦截器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">server := grpc.NewServer(grpc.StreamInterceptor(Interceptor.StreamServerInterceptor()))<br></code></pre></td></tr></table></figure><h3 id="3）启动-amp-请求-1"><a href="#3）启动-amp-请求-1" class="headerlink" title="3）启动 &amp; 请求"></a>3）启动 &amp; 请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"># 启动服务端<br>$ <span class="hljs-keyword">go</span> run server.<span class="hljs-keyword">go</span><br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">54096</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">17</span> Receive a message (Type: *stream.StreamRequest) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">17</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">17</span> stream.Recv pt.name: gRPC Stream Client: Route, pt.value: <span class="hljs-number">1111</span>              <br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">17</span> Receive a message (Type: *stream.StreamRequest) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">17</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">17</span> Send a message (Type: *stream.StreamResponse) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">17</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>  <br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">18</span> stream.Recv pt.name: gRPC Stream Client: Route, pt.value: <span class="hljs-number">1111</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">18</span> Receive a message (Type: *stream.StreamRequest) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">18</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">18</span> Send a message (Type: *stream.StreamResponse) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">18</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>  <br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">19</span> stream.Recv pt.name: gRPC Stream Client: Route, pt.value: <span class="hljs-number">1111</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">19</span> Receive a message (Type: *stream.StreamRequest) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">19</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">19</span> Send a message (Type: *stream.StreamResponse) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">19</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>  <br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">20</span> stream.Recv pt.name: gRPC Stream Client: Route, pt.value: <span class="hljs-number">1111</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">20</span> Receive a message (Type: *stream.StreamRequest) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">20</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">20</span> Send a message (Type: *stream.StreamResponse) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">20</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">21</span> stream.Recv pt.name: gRPC Stream Client: Route, pt.value: <span class="hljs-number">1111</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">22</span> Receive a message (Type: *stream.StreamRequest) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">22</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">22</span> Send a message (Type: *stream.StreamResponse) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">22</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">23</span> stream.Recv pt.name: gRPC Stream Client: Route, pt.value: <span class="hljs-number">1111</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">23</span> Receive a message (Type: *stream.StreamRequest) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">23</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">23</span> Send a message (Type: *stream.StreamResponse) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">23</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">24</span> stream.Recv pt.name: gRPC Stream Client: Route, pt.value: <span class="hljs-number">1111</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">24</span> Receive a message (Type: *stream.StreamRequest) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">24</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">24</span> Send a message (Type: *stream.StreamResponse) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">24</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><br># 启动客户端<br>$ <span class="hljs-keyword">go</span> run client.<span class="hljs-keyword">go</span> <br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">54108</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">17</span> opening client streaming to the server method: /proto.StreamService/Route<br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">17</span> Send a message (Type: *stream.StreamRequest) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">17</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>    <br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">17</span> Receive a message (Type: *stream.StreamResponse) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">17</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">17</span> resp: pj.name: gRPC Stream Server: Route, pt.value: <span class="hljs-number">0</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">17</span> Receive a message (Type: *stream.StreamResponse) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">17</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">18</span> Send a message (Type: *stream.StreamRequest) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">18</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">18</span> resp: pj.name: gRPC Stream Server: Route, pt.value: <span class="hljs-number">1</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">18</span> Receive a message (Type: *stream.StreamResponse) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">18</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">19</span> Send a message (Type: *stream.StreamRequest) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">19</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">19</span> resp: pj.name: gRPC Stream Server: Route, pt.value: <span class="hljs-number">2</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">19</span> Receive a message (Type: *stream.StreamResponse) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">19</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">20</span> Send a message (Type: *stream.StreamRequest) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">20</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">20</span> resp: pj.name: gRPC Stream Server: Route, pt.value: <span class="hljs-number">3</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">20</span> Receive a message (Type: *stream.StreamResponse) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">20</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">21</span> Send a message (Type: *stream.StreamRequest) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">21</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">22</span> resp: pj.name: gRPC Stream Server: Route, pt.value: <span class="hljs-number">4</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">22</span> Receive a message (Type: *stream.StreamResponse) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">22</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">23</span> Send a message (Type: *stream.StreamRequest) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">23</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">23</span> resp: pj.name: gRPC Stream Server: Route, pt.value: <span class="hljs-number">5</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">23</span> Receive a message (Type: *stream.StreamResponse) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">23</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">24</span> Send a message (Type: *stream.StreamRequest) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">24</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">24</span> resp: pj.name: gRPC Stream Server: Route, pt.value: <span class="hljs-number">6</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">07</span>:<span class="hljs-number">24</span> Receive a message (Type: *stream.StreamResponse) at <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">07</span>:<span class="hljs-number">24</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br>Server Closed<br></code></pre></td></tr></table></figure><h2 id="4、实现多个拦截器"><a href="#4、实现多个拦截器" class="headerlink" title="4、实现多个拦截器"></a>4、实现多个拦截器</h2><p>gRPC框架中只能为每个服务一起配置一元和流拦截器，，gRPC 会根据不同方法选择对应类型的拦截器执行，因此所有的工作只能在一个函数中完成。</p><p>开源的<code>grpc-ecosystem</code>项目中的<a href="https://github.com/grpc-ecosystem/go-grpc-middleware">go-grpc-middleware</a>包已经基于gRPC对拦截器实现了链式拦截的支持。</p><h3 id="1）Interceptor-新增一个一元客户端拦截器："><a href="#1）Interceptor-新增一个一元客户端拦截器：" class="headerlink" title="1）Interceptor 新增一个一元客户端拦截器："></a>1）Interceptor 新增一个一元客户端拦截器：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UnaryClientInterceptorTwo</span><span class="hljs-params">()</span></span> grpc.UnaryClientInterceptor &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, method <span class="hljs-type">string</span>, req, reply <span class="hljs-keyword">interface</span>&#123;&#125;,</span></span><br><span class="hljs-params"><span class="hljs-function">cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption)</span></span> <span class="hljs-type">error</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;我是第二个拦截器&quot;</span>)<br><span class="hljs-comment">// 可以看做是当前 RPC 方法，一般在拦截器中调用 invoker 能达到调用 RPC 方法的效果，当然底层也是 gRPC 在处理。</span><br><span class="hljs-comment">// 调用RPC方法(invoking RPC method)</span><br>_ = invoker(ctx, method, req, reply, cc, opts...)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）Client-使用go-grpc-middleware实现链式拦截器："><a href="#2）Client-使用go-grpc-middleware实现链式拦截器：" class="headerlink" title="2）Client 使用go-grpc-middleware实现链式拦截器："></a>2）Client 使用go-grpc-middleware实现链式拦截器：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">conn, err := grpc.Dial(<span class="hljs-string">&quot;:&quot;</span>+PORT, grpc.WithInsecure(),<br>grpc.WithUnaryInterceptor(<br><span class="hljs-comment">// 按照顺序依次执行截取器</span><br>grpc_middleware.ChainUnaryClient(Interceptor.UnaryClientInterceptor(),<br>Interceptor.UnaryClientInterceptorTwo()),<br>))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;grpc.Dial err: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br></code></pre></td></tr></table></figure><h3 id="3）启动-amp-请求-2"><a href="#3）启动-amp-请求-2" class="headerlink" title="3）启动 &amp; 请求"></a>3）启动 &amp; 请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"># 启动服务端<br>$ <span class="hljs-keyword">go</span> run server.<span class="hljs-keyword">go</span><br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">55823</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">32</span>:<span class="hljs-number">28</span> RPC: /hello.UserService/SayHi,client-OS: <span class="hljs-string">&#x27;[windows]&#x27;</span> and IP: <span class="hljs-string">&#x27;127.0.0.1:55829&#x27;</span> req:name:<span class="hljs-string">&quot;lin钟一&quot;</span> start time: <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">32</span>:<span class="hljs-number">28</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span><br>, end time: <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">32</span>:<span class="hljs-number">28</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>, err: &lt;<span class="hljs-literal">nil</span>&gt;<br><br># 启动客户端<br>$ <span class="hljs-keyword">go</span> run client.<span class="hljs-keyword">go</span> <br>我是第一个拦截器<br>我是第二个拦截器<br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">07</span> <span class="hljs-number">19</span>:<span class="hljs-number">32</span>:<span class="hljs-number">28</span> RPC: /hello.UserService/SayHi,,client-OS: <span class="hljs-string">&#x27;windows&#x27;</span> req:name:<span class="hljs-string">&quot;lin钟一&quot;</span> start time: <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">32</span>:<span class="hljs-number">28</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>, end time: <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span>T19:<span class="hljs-number">3</span><br><span class="hljs-number">2</span>:<span class="hljs-number">28</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>, err: &lt;<span class="hljs-literal">nil</span>&gt;<br>resp: hi lin钟一--<span class="hljs-number">-2022</span><span class="hljs-number">-11</span><span class="hljs-number">-07</span> <span class="hljs-number">19</span>:<span class="hljs-number">32</span>:<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><h1 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h1><p>1、拦截器分类与定义 gRPC 拦截器可以分为：一元拦截器和流拦截器，服务端拦截器和客户端拦截器。一共有以下4种类型:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">grpc.UnaryServerInterceptor<br>grpc.StreamServerInterceptor<br>grpc.UnaryClientInterceptor<br>grpc.StreamClientInterceptor<br></code></pre></td></tr></table></figure><p><code>拦截器本质上就是一个特定类型的函数，所以实现拦截器只需要实现对应类型方法（方法签名相同）即可。</code></p><p>2、拦截器执行过程</p><p>一元拦截器</p><ul><li>1）预处理</li><li>2）调用RPC方法</li><li>3）后处理</li></ul><p>流拦截器</p><ul><li>1）预处理</li><li>2）调用RPC方法 获取 Streamer</li><li>3）后处理<ul><li>调用 SendMsg 、RecvMsg 之前</li><li>调用 SendMsg 、RecvMsg</li><li>调用 SendMsg 、RecvMsg 之后</li></ul></li></ul><p>3、拦截器使用及执行顺序</p><p>配置多个拦截器时，会按照参数传入顺序依次执行</p><p>所以，如果想配置一个 Recovery 拦截器则必须放在第一个，放在最后则无法捕获前面执行的拦截器中触发的 panic。</p><p>参考：<br><a href="https://www.lixueduan.com/posts/grpc/05-interceptor/#4-streaminterceptor">https://www.lixueduan.com/posts/grpc/05-interceptor/#4-streaminterceptor</a></p>]]></content>
    
    
    <categories>
      
      <category>gRPC学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>微服务</tag>
      
      <tag>grpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gRPC（五）进阶：通过TLS建立安全连接</title>
    <link href="/2022/11/03/grpc-TLS/"/>
    <url>/2022/11/03/grpc-TLS/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>示例代码已经上传到github：<a href="https://github.com/Gopherlinzy/go-grpc-example">点击跳转</a><br>gRPC官方文档：<a href="https://grpc.io/docs/languages/go/basics/">点击跳转</a></p></blockquote><h1 id="一、明文传输"><a href="#一、明文传输" class="headerlink" title="一、明文传输"></a>一、明文传输</h1><p>先前的例子中 gRPC Client&#x2F;Server 都是明文传输的，在明文通讯的情况下，你的请求就是裸奔的，有可能被第三方恶意篡改或者伪造为“非法”的数据。</p><p>我们抓个包查看一下：<br><img src="/img/grpc_TLS/grpc1.png"><br><img src="/img/grpc_TLS/grpc2.png"><br>是明文传输，后面我们开始gRPC通过 TLS 证书建立安全连接，让数据能够加密处理，包括证书制作和CA签名校验等。</p><h1 id="二、TLS概述"><a href="#二、TLS概述" class="headerlink" title="二、TLS概述"></a>二、TLS概述</h1><p>传输层安全 (TLS) 对通过 Internet 发送的数据进行加密，以确保窃听者和黑客无法看到您传输的内容，这对于密码、信用卡号和个人通信等私人和敏感信息特别有用。</p><h2 id="1、什么是TLS？"><a href="#1、什么是TLS？" class="headerlink" title="1、什么是TLS？"></a>1、什么是TLS？</h2><p>传输层安全 (TLS) 是一种 Internet 工程任务组 ( IETF ) 标准协议，可在两个通信计算机应用程序之间提供身份验证、隐私和数据完整性。它是当今使用最广泛部署的安全协议，最适合需要通过网络安全交换数据的 Web 浏览器和其他应用程序。这包括 Web 浏览会话、文件传输、虚拟专用网络 (VPN) 连接、远程桌面会话和 IP 语音 (VoIP)。最近，TLS 被集成到包括 5G 在内的现代蜂窝传输技术中，以保护整个无线电接入网络 ( RAN ) 的核心网络功能。</p><h2 id="2、TLS的工作流程"><a href="#2、TLS的工作流程" class="headerlink" title="2、TLS的工作流程"></a>2、TLS的工作流程</h2><p>TLS 使用客户端-服务器握手机制来建立加密和安全的连接，并确保通信的真实性。</p><ul><li>通信设备交换加密功能。</li><li>使用数字证书进行身份验证过程以帮助证明服务器是它声称的实体。</li><li>发生会话密钥交换。在此过程中，客户端和服务器必须就密钥达成一致，以建立安全会话确实在客户端和服务器之间的事实——而不是在中间试图劫持会话的东西。</li></ul><p><img src="/img/grpc_TLS/grpc3.png"></p><h1 id="三、gRPC建立安全连接"><a href="#三、gRPC建立安全连接" class="headerlink" title="三、gRPC建立安全连接"></a>三、gRPC建立安全连接</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>gRPC建立在HTTP&#x2F;2协议之上，对TLS提供了很好的支持。当不需要证书认证时,可通过grpc.WithInsecure()选项跳过了对服务器证书的验证，没有启用证书的gRPC服务和客户端进行的是明文通信，信息面临被任何第三方监听的风险。为了保证gRPC通信不被第三方监听、篡改或伪造，可以对服务器启动TLS加密特性。</p><p>gRPC 内置了以下 encryption 机制：</p><ul><li>SSL &#x2F; TLS：通过证书进行数据加密；</li><li>ALTS：Google开发的一种双向身份验证和传输加密系统。<ul><li>只有运行在 Google Cloud Platform 才可用，一般不用考虑。</li></ul></li></ul><h2 id="2、gRPC-加密类型"><a href="#2、gRPC-加密类型" class="headerlink" title="2、gRPC 加密类型"></a>2、gRPC 加密类型</h2><ul><li>1）insecure connection：不使用TLS加密</li><li>2）server-side TLS：仅服务端TLS加密</li><li>3）mutual TLS：客户端、服务端都使用TLS加密</li></ul><p>我们前面的例子都是明文传输的，使用的都是 insecure connection，通过指定 WithInsecure option 来建立 insecure connection，不建议在生产环境使用。</p><p>后面我们了解如何使用 TLS 来建立安全连接。</p><h2 id="3、server-side-TLS"><a href="#3、server-side-TLS" class="headerlink" title="3、server-side TLS"></a>3、server-side TLS</h2><h3 id="1）流程"><a href="#1）流程" class="headerlink" title="1）流程"></a>1）流程</h3><p>服务端 TLS 具体包含以下几个步骤：</p><ul><li>制作证书，包含服务端证书和 CA 证书；</li><li>服务端启动时加载证书；</li><li>客户端连接时使用CA 证书校验服务端证书有效性。</li></ul><blockquote><p>也可以不使用 CA证书，即服务端证书自签名。</p></blockquote><h3 id="2）什么是CA？CA证书又是什么？"><a href="#2）什么是CA？CA证书又是什么？" class="headerlink" title="2）什么是CA？CA证书又是什么？"></a>2）什么是CA？CA证书又是什么？</h3><ul><li>CA是Certificate Authority的缩写，也叫<code>“证书授权中心”</code>。它是负责管理和签发证书的第三方机构，作用是检查证书持有者身份的合法性，并签发证书，以防证书被伪造或篡改。</li></ul><blockquote><p>CA实际上是一个机构，负责“证件”印制核发。就像负责颁发身份证的公安局、负责发放行驶证、驾驶证的车管所。</p></blockquote><ul><li><p>CA 证书就是CA颁发的证书。我们常听到的数字证书就是CA证书,CA证书包含信息有:<code>证书拥有者的身份信息，CA机构的签名，公钥和私钥。</code></p><ul><li>身份信息: 用于证明证书持有者的身份</li><li>CA机构的签名: 用于保证身份的真实性</li><li>公钥和私钥: 用于通信过程中加解密，从而保证通讯信息的安全性</li></ul></li></ul><h3 id="3）什么是SAN？"><a href="#3）什么是SAN？" class="headerlink" title="3）什么是SAN？"></a>3）什么是SAN？</h3><p>SAN(Subject Alternative Name)是 SSL 标准 x509 中定义的一个扩展。使用了 SAN 字段的 SSL 证书，可以扩展此证书支持的域名，使得一个证书可以支持多个不同域名的解析。</p><p>我们在用go 1.15版本以上，用gRPC通过TLS建立安全连接时，会出现证书报错问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">panic</span>: rpc <span class="hljs-type">error</span>: code = Unavailable desc = connection <span class="hljs-type">error</span>: desc = <span class="hljs-string">&quot;transport: authentication handshake failed: x509: certificate</span><br><span class="hljs-string">is not valid for any names, but wanted to match localhost&quot;</span><br></code></pre></td></tr></table></figure><p>造成这个panic的原因是从go 1.15 版本开始废弃 CommonName，我们没有使用官方推荐的 SAN 证书（默认是没有开启SAN扩展）而出现的错误，导致客户端和服务端无法建立连接。</p><h3 id="4）目录结构"><a href="#4）目录结构" class="headerlink" title="4）目录结构"></a>4）目录结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span>-grpc-example<br>├── client<br>│  └──TLS_client<br>│   │   └──client.<span class="hljs-keyword">go</span><br>├── conf<br>│   └──ca.conf<br>│   └──server.conf<br>├── proto<br>│   └──search<br>│   │   └──search.proto<br>├── server<br>│  └──TLS_server<br>│   │   └──server.<span class="hljs-keyword">go</span><br>├── Makefile<br></code></pre></td></tr></table></figure><h3 id="5）生成CA根证书"><a href="#5）生成CA根证书" class="headerlink" title="5）生成CA根证书"></a>5）生成CA根证书</h3><p>在ca.conf里写入内容如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">[ req ]<br>default_bits       = <span class="hljs-number">4096</span><br>distinguished_name = req_distinguished_name<br><br>[ req_distinguished_name ]<br>countryName                 = GB<br>countryName_default         = CN<br>stateOrProvinceName         = State or Province Name (full name)<br>stateOrProvinceName_default = ZheJiang<br>localityName                = Locality Name (eg, city)<br>localityName_default        = HuZhou<br>organizationName            = Organization Name (eg, company)<br>organizationName_default    = Step<br>commonName                  = linzyblog.netlify.app<br>commonName_max              = <span class="hljs-number">64</span><br>commonName_default          = linzyblog.netlify.app<br></code></pre></td></tr></table></figure><ol><li>生成ca私钥，得到ca.key</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">openssl genrsa -out ca.key <span class="hljs-number">4096</span><br></code></pre></td></tr></table></figure><blockquote><p>openssl genrsa：生成RSA私钥，命令的最后一个参数，将指定生成密钥的位数，如果没有指定，默认512</p></blockquote><ol start="2"><li>生成ca证书签发请求，得到ca.csr</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">$ openssl req -<span class="hljs-built_in">new</span> -sha256 -out ca.csr -key ca.key -config ca.conf<br>GB [CN]:<br>State or Province Name (full name) [ZheJiang]:<br>Locality Name (eg, city) [HuZhou]:<br>Organization Name (eg, company) [Step]:<br>linzyblog.netlify.app [linzyblog.netlify.app]:<br></code></pre></td></tr></table></figure><blockquote><p>这里一直回车就好了<br>openssl req：生成自签名证书，-new指生成证书请求、-sha256指使用sha256加密、-key指定私钥文件、-x509指输出证书、-days 3650为有效期，此后则输入证书拥有者信息</p></blockquote><ol start="3"><li>生成ca根证书，得到ca.crt</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">openssl x509 -req -days <span class="hljs-number">3650</span> -in ca.csr -signkey ca.key -out ca.crt<br></code></pre></td></tr></table></figure><p><img src="/img/grpc_TLS/grpc4.png"></p><h3 id="6）生成终端用户证书"><a href="#6）生成终端用户证书" class="headerlink" title="6）生成终端用户证书"></a>6）生成终端用户证书</h3><p>在server.conf写入以下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go">[ req ]<br>default_bits       = <span class="hljs-number">2048</span><br>distinguished_name = req_distinguished_name<br><br>[ req_distinguished_name ]<br>countryName                 = Country Name (<span class="hljs-number">2</span> letter code)<br>countryName_default         = CN<br>stateOrProvinceName         = State or Province Name (full name)<br>stateOrProvinceName_default = ZheJiang<br>localityName                = Locality Name (eg, city)<br>localityName_default        = HuZhou<br>organizationName            = Organization Name (eg, company)<br>organizationName_default    = Step<br>commonName                  = CommonName (e.g. server FQDN or YOUR name)<br>commonName_max              = <span class="hljs-number">64</span><br>commonName_default          = linzyblog.netlify.app<br><br>[ req_ext ]<br>subjectAltName = @alt_names<br><br>[alt_names]<br>DNS<span class="hljs-number">.1</span>   = <span class="hljs-keyword">go</span>-grpc-example（这里很重要，客户端需要此字段做匹配）<br>IP      = <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure><ol><li>生成私钥，得到server.key</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">openssl genrsa -out server.key <span class="hljs-number">4096</span><br></code></pre></td></tr></table></figure><ol start="2"><li>生成证书签发请求，得到server.csr</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">openssl req -<span class="hljs-built_in">new</span> -sha256 -out server.csr -key server.key -config server.conf<br></code></pre></td></tr></table></figure><p>这里也一直回车就好。</p><ol start="3"><li>用CA证书生成终端用户证书，得到server.crt</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">openssl x509 -req -days <span class="hljs-number">3650</span> -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.pem -extensions req_ext -extfile server.conf<br></code></pre></td></tr></table></figure><p><img src="/img/grpc_TLS/grpc5.png"></p><h3 id="7）server"><a href="#7）server" class="headerlink" title="7）server"></a>7）server</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> PORT = <span class="hljs-string">&quot;8888&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 根据服务端输入的证书文件和密钥构造 TLS 凭证</span><br>c, err := credentials.NewServerTLSFromFile(<span class="hljs-string">&quot;./conf/server.pem&quot;</span>, <span class="hljs-string">&quot;./conf/server.key&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;credentials.NewServerTLSFromFile err: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 返回一个 ServerOption，用于设置服务器连接的凭据。</span><br><span class="hljs-comment">// 用于 grpc.NewServer(opt ...ServerOption) 为 gRPC Server 设置连接选项</span><br>lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:&quot;</span>+PORT) <span class="hljs-comment">//创建 Listen，监听 TCP 端口</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;credentials.NewServerTLSFromFile err: %v&quot;</span>, err)<br>&#125;<br>search.RegisterSearchServiceServer(s, &amp;service&#123;&#125;)<br><br>s.Serve(lis)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8）client"><a href="#8）client" class="headerlink" title="8）client"></a>8）client</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> PORT = <span class="hljs-string">&quot;8888&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 根据客户端输入的证书文件和密钥构造 TLS 凭证。</span><br><span class="hljs-comment">// 第二个参数 serverNameOverride 为服务名称。</span><br>c, err := credentials.NewClientTLSFromFile(<span class="hljs-string">&quot;./conf/server.pem&quot;</span>, <span class="hljs-string">&quot;go-grpc-example&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;credentials.NewClientTLSFromFile err: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 返回一个配置连接的 DialOption 选项。</span><br><span class="hljs-comment">// 用于 grpc.Dial(target string, opts ...DialOption) 设置连接选项</span><br>conn, err := grpc.Dial(<span class="hljs-string">&quot;:&quot;</span>+PORT, grpc.WithTransportCredentials(c))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;grpc.Dial err: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br>client := pb.NewSearchServiceClient(conn)<br>resp, err := client.Search(context.Background(), &amp;pb.SearchRequest&#123;<br>Request: <span class="hljs-string">&quot;gRPC&quot;</span>,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;client.Search err: %v&quot;</span>, err)<br>&#125;<br><br>log.Printf(<span class="hljs-string">&quot;resp: %s&quot;</span>, resp.GetResponse())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8）启动-amp-请求"><a href="#8）启动-amp-请求" class="headerlink" title="8）启动 &amp; 请求"></a>8）启动 &amp; 请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"># 启动服务端<br>$ <span class="hljs-keyword">go</span> run server.<span class="hljs-keyword">go</span><br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">53981</span><br><br># 启动客户端<br>$ <span class="hljs-keyword">go</span> run client.<span class="hljs-keyword">go</span> <br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">54328</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">19</span>:<span class="hljs-number">35</span>:<span class="hljs-number">10</span> resp: gRPC Server<br></code></pre></td></tr></table></figure><p>抓个包再看看<br><img src="/img/grpc_TLS/grpc6.png"></p><h2 id="4、mutual-TLS"><a href="#4、mutual-TLS" class="headerlink" title="4、mutual TLS"></a>4、mutual TLS</h2><h3 id="1）生成服务端证书"><a href="#1）生成服务端证书" class="headerlink" title="1）生成服务端证书"></a>1）生成服务端证书</h3><p>新增server.conf</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go">[ req ]<br>default_bits       = <span class="hljs-number">2048</span><br>distinguished_name = req_distinguished_name<br><br>[ req_distinguished_name ]<br>countryName                 = Country Name (<span class="hljs-number">2</span> letter code)<br>countryName_default         = CN<br>stateOrProvinceName         = State or Province Name (full name)<br>stateOrProvinceName_default = ZheJiang<br>localityName                = Locality Name (eg, city)<br>localityName_default        = HuZhou<br>organizationName            = Organization Name (eg, company)<br>organizationName_default    = Step<br>commonName                  = CommonName (e.g. server FQDN or YOUR name)<br>commonName_max              = <span class="hljs-number">64</span><br>commonName_default          = linzyblog.netlify.app<br><br>[ req_ext ]<br>subjectAltName = @alt_names<br><br>[alt_names]<br>DNS<span class="hljs-number">.1</span>   = <span class="hljs-keyword">go</span>-grpc-example（这里很重要，客户端需要此字段做匹配）<br>IP      = <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 1. 生成私钥，得到server.key</span><br>openssl genrsa -out server.key <span class="hljs-number">2048</span><br><br><span class="hljs-comment">//2. 生成证书签发请求，得到server.csr</span><br>openssl req -<span class="hljs-built_in">new</span> -sha256 -out server.csr -key server.key -config server.conf<br><br><span class="hljs-comment">//3. 用CA证书生成终端用户证书，得到server.crt</span><br>openssl x509 -req -sha256 -CA ca.crt -CAkey ca.key -CAcreateserial -days <span class="hljs-number">365</span> -in server.csr -out se<br>rver.crt -extensions req_ext -extfile server.conf<br></code></pre></td></tr></table></figure><h3 id="2）生成客户端证书"><a href="#2）生成客户端证书" class="headerlink" title="2）生成客户端证书"></a>2）生成客户端证书</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 1. 生成私钥，得到client.key</span><br>openssl genrsa -out client.key <span class="hljs-number">2048</span><br><br><span class="hljs-comment">//2. 生成证书签发请求，得到client.csr</span><br>openssl req -<span class="hljs-built_in">new</span> -key client.key -out client.csr <br><br><br><span class="hljs-comment">//3. 用CA证书生成客户端证书，得到client.crt</span><br> openssl x509 -req -sha256 -CA ca.crt -CAkey ca.key -CAcreateserial -days <span class="hljs-number">365</span>  -in client.csr -out client.crt<br></code></pre></td></tr></table></figure><p><img src="/img/grpc_TLS/grpc7.png"></p><h3 id="3）整理目录"><a href="#3）整理目录" class="headerlink" title="3）整理目录"></a>3）整理目录</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">conf<br>├── ca.conf<br>├── ca.crt<br>├── ca.csr<br>├── ca.key<br>├── client<br>│   ├── client.csr<br>│   ├── client.key<br>│   └── client.pem<br>├── server<br>│   ├── server.conf<br>|   └── server.crt<br>│   ├── server.csr<br>|   ├── server.key<br>└─server_side_TLS<br></code></pre></td></tr></table></figure><h3 id="4）server"><a href="#4）server" class="headerlink" title="4）server"></a>4）server</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> PORT = <span class="hljs-string">&quot;8888&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 公钥中读取和解析公钥/私钥对</span><br>cert, err := tls.LoadX509KeyPair(<span class="hljs-string">&quot;./conf/server/server.crt&quot;</span>, <span class="hljs-string">&quot;./conf/server/server.key&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;LoadX509KeyPair error&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 创建一组根证书</span><br>certPool := x509.NewCertPool()<br>ca, err := ioutil.ReadFile(<span class="hljs-string">&quot;./conf/ca.crt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;read ca pem error &quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 解析证书</span><br><span class="hljs-keyword">if</span> ok := certPool.AppendCertsFromPEM(ca); !ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;AppendCertsFromPEM error &quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>c := credentials.NewTLS(&amp;tls.Config&#123;<br><span class="hljs-comment">//设置证书链，允许包含一个或多个</span><br>Certificates: []tls.Certificate&#123;cert&#125;,<br><span class="hljs-comment">//要求必须校验客户端的证书</span><br>ClientAuth: tls.RequireAndVerifyClientCert,<br><span class="hljs-comment">//设置根证书的集合，校验方式使用ClientAuth设定的模式</span><br>ClientCAs: certPool,<br>&#125;)<br>s := grpc.NewServer(grpc.Creds(c))<br>lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:&quot;</span>+PORT) <span class="hljs-comment">//创建 Listen，监听 TCP 端口</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;credentials.NewServerTLSFromFile err: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">//将 SearchService（其包含需要被调用的服务端接口）注册到 gRPC Server 的内部注册中心。</span><br><span class="hljs-comment">//这样可以在接受到请求时，通过内部的服务发现，发现该服务端接口并转接进行逻辑处理</span><br>search.RegisterSearchServiceServer(s, &amp;service&#123;&#125;)<br><br><span class="hljs-comment">//gRPC Server 开始 lis.Accept，直到 Stop 或 GracefulStop</span><br>s.Serve(lis)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5）client"><a href="#5）client" class="headerlink" title="5）client"></a>5）client</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> PORT = <span class="hljs-string">&quot;8888&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 公钥中读取和解析公钥/私钥对</span><br>cert, err := tls.LoadX509KeyPair(<span class="hljs-string">&quot;./conf/client/client.crt&quot;</span>, <span class="hljs-string">&quot;./conf/client/client.key&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;LoadX509KeyPair error &quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 创建一组根证书</span><br>certPool := x509.NewCertPool()<br>ca, err := ioutil.ReadFile(<span class="hljs-string">&quot;./conf/ca.crt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;ReadFile ca.crt error &quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 解析证书</span><br><span class="hljs-keyword">if</span> ok := certPool.AppendCertsFromPEM(ca); !ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;certPool.AppendCertsFromPEM error &quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>c := credentials.NewTLS(&amp;tls.Config&#123;<br>Certificates: []tls.Certificate&#123;cert&#125;,<br>ServerName:   <span class="hljs-string">&quot;go-grpc-example&quot;</span>,<br>RootCAs:      certPool,<br>&#125;)<br><br>conn, err := grpc.Dial(<span class="hljs-string">&quot;:&quot;</span>+PORT, grpc.WithTransportCredentials(c))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;grpc.Dial err: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br>client := pb.NewSearchServiceClient(conn)<br>resp, err := client.Search(context.Background(), &amp;pb.SearchRequest&#123;<br>Request: <span class="hljs-string">&quot;gRPC&quot;</span>,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;client.Search err: %v&quot;</span>, err)<br>&#125;<br><br>log.Printf(<span class="hljs-string">&quot;resp: %s&quot;</span>, resp.GetResponse())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6）启动-amp-请求"><a href="#6）启动-amp-请求" class="headerlink" title="6）启动 &amp; 请求"></a>6）启动 &amp; 请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"># 启动服务端<br>$ <span class="hljs-keyword">go</span> run server.<span class="hljs-keyword">go</span><br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">56036</span><br><br># 启动客户端<br>$ <span class="hljs-keyword">go</span> run client.<span class="hljs-keyword">go</span> <br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">56364</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">20</span>:<span class="hljs-number">21</span>:<span class="hljs-number">55</span> resp: gRPC Server<br><br># 更改ServerName为linzy<br>$ <span class="hljs-keyword">go</span> run client.<span class="hljs-keyword">go</span> <br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">56424</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">20</span>:<span class="hljs-number">23</span>:<span class="hljs-number">17</span> client.Search err: rpc <span class="hljs-type">error</span>: code = Unavailable desc = connection <span class="hljs-type">error</span>: desc = <span class="hljs-string">&quot;transport: authentication handshake failed: x509: cer</span><br><span class="hljs-string">tificate is valid for go-grpc-example, not linzy&quot;</span><br></code></pre></td></tr></table></figure><p>抓个包看看<br><img src="/img/grpc_TLS/grpc8.png"><br><img src="/img/grpc_TLS/grpc9.png"></p>]]></content>
    
    
    <categories>
      
      <category>gRPC学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>微服务</tag>
      
      <tag>grpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gRPC（四）基础：gRPC流</title>
    <link href="/2022/11/03/grpc-stream/"/>
    <url>/2022/11/03/grpc-stream/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>这章的内容需要安装好插件和protoc，建议阅读我的上一篇<a href="https://linzyblog.netlify.app/2022/11/01/grpc-use/">grpc使用篇</a><br>示例代码已经上传到github：<a href="https://github.com/Gopherlinzy/go-grpc-example">点击跳转</a><br>gRPC官方文档：<a href="https://grpc.io/docs/languages/go/basics/">点击跳转</a></p></blockquote><h1 id="一、gRPC的请求模型"><a href="#一、gRPC的请求模型" class="headerlink" title="一、gRPC的请求模型"></a>一、gRPC的请求模型</h1><p>gRPC 有两种类型的请求模型：</p><ul><li>一元 - 直接的请求响应映射在 <code>HTTP/2</code> 请求响应之上。<ul><li>简单来说一元就是一个简单的 RPC，其中客户端使用存根向服务器发送请求并等待响应返回，就像正常的函数调用一样。</li></ul></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">rpc <span class="hljs-title">SayHi</span>(<span class="hljs-params">Request</span>) <span class="hljs-title">returns</span> (<span class="hljs-params">Response</span>)</span>;<br></code></pre></td></tr></table></figure><ul><li>流式传输——多个请求和响应通过长寿命  <code>HTTP/2</code> 流进行交换，可以是单向或双向的。<br><img src="/img/grpc_stream/grpc1.png"><ul><li>其中许多进程可以通过 <code>HTTP/2 的多路复用能力</code>（通过单个 TCP 连接一起发送多个响应或接收多个请求）在单个请求中发生。</li><li><code>Server-side streaming RPC</code>—— 客户端向服务器发送单个请求并接收回数据序列流（读回一系列消息）。客户端从返回的流中读取，直到没有更多消息为止。</li><li><code>Client-side streaming RPC</code>—— 客户端向服务器发送数据序列流（写入一系列消息），一旦客户端完成了消息的写入，它会等待服务器读取所有消息并返回其响应结果。</li><li><code>Bidirectional streaming RPC</code>—— 它是双向流式传输，客户端和服务器使用读写流发送一系列消息。两个流独立运行；因此，因此客户端和服务器可以按照他们喜欢的任何顺序读取和写入。保留每个流中消息的顺序。例如，服务器可以在写入响应之前等待接收所有客户端消息，或者它可以交替读取消息然后写入消息，或其他一些读取和写入的组合。</li></ul></li></ul><blockquote><p>Server-side streaming RPC：服务器端流式 RPC<br>Client-side streaming RPC：客户端流式 RPC<br>Bidirectional streaming RPC：双向流式 RPC<br><code>stream</code>可以通过将关键字放在请求类型之前来指定流式处理方法。</p></blockquote><h1 id="二、HTTP-x2F-2"><a href="#二、HTTP-x2F-2" class="headerlink" title="二、HTTP&#x2F;2"></a>二、HTTP&#x2F;2</h1><p>gRPC 是基于HTTP&#x2F;2开发的，该协议于 2015 年发布，以克服 HTTP&#x2F;1.1 的限制。在兼容 HTTP&#x2F;1.1 的同时，我们来了解一下HTTP&#x2F;2 带来了许多高级功能，例如：</p><ul><li>二进制分帧层 —— 与 HTTP&#x2F;1.1 不同，HTTP&#x2F;2 请求&#x2F;响应分为小消息并以二进制格式分帧，使消息传输高效。<code>通过二进制帧，HTTP/2 协议使请求/响应多路复用成为可能，而不会阻塞网络资源。</code></li><li>流式传输 —— 客户端可以请求并且服务器可以同时响应的<code>双向全双工流式传输</code>。</li><li><code>流控制</code> —— HTTP&#x2F;2 中使用流控制机制，可以对用于缓冲动态消息的内存进行详细控制。</li><li>标头压缩 —— HTTP&#x2F;2 中的所有内容，包括标头，都在发送前进行编码，显着提高了整体性能。使用 <code>HPACK</code> 压缩方式，HTTP&#x2F;2 只共享与之前的 HTTP 头包不同的值。</li><li>处理 —— 使用 HTTP&#x2F;2，gRPC 支持同步和异步处理，可用于执行不同类型的交互和流式 RPC。</li></ul><p><img src="/img/grpc_stream/grpc2.png"></p><p>HTTP&#x2F;2 的所有这些特性使 gRPC 能够使用更少的资源，从而减少在云中运行的应用程序和服务之间的响应时间，并延长运行移动设备的客户端的电池寿命。</p><h1 id="三、gRPC-Streaming-Client-and-Server"><a href="#三、gRPC-Streaming-Client-and-Server" class="headerlink" title="三、gRPC Streaming, Client and Server"></a>三、gRPC Streaming, Client and Server</h1><h2 id="1、为什么我们要用流式传输，简单的一元RPC不行么？"><a href="#1、为什么我们要用流式传输，简单的一元RPC不行么？" class="headerlink" title="1、为什么我们要用流式传输，简单的一元RPC不行么？"></a>1、为什么我们要用流式传输，简单的一元RPC不行么？</h2><p>流式为什么要存在呢？我们在使用一元请求的时候可能会遇到以下问题：</p><ul><li>数据包过大会造成的瞬时压力。</li><li>接收数据包时，需要所有数据包都接受成功且正确后，才能够回调响应，进行业务处理（无法客户端边发送，服务端边处理）</li></ul><p>而流式传输却可以：</p><ul><li><p>HTTP2 通过长期 TCP 连接多路复用流，因此新请求没有 TCP 连接开销。HTTP2 成帧允许在单个 TCP 数据包中发送多个 gRPC 消息。</p></li><li><p>对于长期连接，流式请求应该在每条消息的基础上具有最佳性能。<code>一元请求需要为每个请求建立一个新的 HTTP2 流，包括通过网络发送的附加标头帧。一旦建立，通过流式请求发送的每条新消息只需要通过连接发送消息的数据帧。</code></p></li></ul><h2 id="2、目录结构"><a href="#2、目录结构" class="headerlink" title="2、目录结构"></a>2、目录结构</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp">go-grpc-example<br>├── client<br>│   └──hello_client<br>│   │   └── client.go<br>│   └── stream_client<br>│       └── client.go<br>├── proto<br>│   └──hello<br>│   │   └── hello.proto<br>│   └──stream<br>│   │   └── stream.proto<br>├── server<br>│   └──hello_server<br>│   │   └── server.go<br>│   └──stream_server<br>│   │   └── server.go<br>├── Makefile<br></code></pre></td></tr></table></figure><p>增加 <code>stream_server、stream_client</code> 存放服务端和客户端文件，<code>proto/stream/stream.proto</code> 用于编写 IDL</p><h2 id="3、编写IDL"><a href="#3、编写IDL" class="headerlink" title="3、编写IDL"></a>3、编写IDL</h2><p>在 proto&#x2F;stream 文件夹下的 stream.proto 文件中，写入如下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br>option go_package=<span class="hljs-string">&quot;./proto/stream;stream&quot;</span>;<br><span class="hljs-keyword">package</span> proto;<br><br>service StreamService &#123;<br>  <span class="hljs-comment">//List：服务器端流式 RPC</span><br>  rpc List(StreamRequest) returns (stream StreamResponse) &#123;&#125;;<br>  <span class="hljs-comment">//Record：客户端流式 RPC</span><br>  rpc Record(stream StreamRequest) returns (StreamResponse) &#123;&#125;;<br>  <span class="hljs-comment">//Route：双向流式 RPC</span><br>  rpc Route(stream StreamRequest) returns (stream StreamResponse) &#123;&#125;;<br>&#125;<br><br><br>message StreamPoint &#123;<br>  <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int32</span> value = <span class="hljs-number">2</span>;<br>&#125;<br><br>message StreamRequest &#123;<br>  StreamPoint pt = <span class="hljs-number">1</span>;<br>&#125;<br><br>message StreamResponse &#123;<br>  StreamPoint pt = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意关键字 stream，声明其为一个流方法。这里共涉及三个方法，对应关系为</p><ul><li>List：服务器端流式 RPC</li><li>Record：客户端流式 RPC</li><li>Route：双向流式 RPC</li></ul><h2 id="4、Makefile"><a href="#4、Makefile" class="headerlink" title="4、Makefile"></a>4、Makefile</h2><p>这是我拖了很久的关于Makefile的用法，感觉Makefile更适合在项目使用中穿插讲解一下。</p><p>有一篇很不错的Makefile文档：<a href="https://makefiletutorial.com/#makefile-cookbook">点击跳转</a></p><p>作用：Makefile 用于帮助决定大型程序的哪些部分需要重新编译。</p><p>这里我们用<code>make gen</code>指令代替proto插件从我们的.proto 服务定义中生成 gRPC 客户端和服务器接口。</p><p>在Makefile文件中写入：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">gen:<br>protoc --go_out=. --go-grpc_out=. ./proto/stream<span class="hljs-comment">/*.proto</span><br></code></pre></td></tr></table></figure><p>用<code>make gen</code>指令生成Go代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">➜ make gen<br>protoc --go_out=. --go-grpc_out=. ./proto/stream<span class="hljs-comment">/*.proto</span><br></code></pre></td></tr></table></figure><p><img src="/img/grpc_stream/grpc3.png"></p><blockquote><p>注意使用Makefile生成的时候，要注意<code>.proto</code>文件 go_package 指定生成的位置。</p></blockquote><h2 id="5、写出基础模板和空定义"><a href="#5、写出基础模板和空定义" class="headerlink" title="5、写出基础模板和空定义"></a>5、写出基础模板和空定义</h2><p>我们先把基础的模板和空定义写出来在进行完善，不太懂的看我上一篇文章</p><h3 id="1）server-go"><a href="#1）server-go" class="headerlink" title="1）server.go"></a>1）server.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StreamService <span class="hljs-keyword">struct</span> &#123;<br>pb.UnimplementedStreamServiceServer<br>&#125;<br><br><span class="hljs-keyword">const</span> PORT = <span class="hljs-string">&quot;8888&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>server := grpc.NewServer() <span class="hljs-comment">//创建 gRPC Server 对象</span><br>pb.RegisterStreamServiceServer(server, &amp;StreamService&#123;&#125;)<br><br>lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:&quot;</span>+PORT)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;net.Listen err: %v&quot;</span>, err)<br>&#125;<br><br>server.Serve(lis)<br>&#125;<br><br><span class="hljs-comment">//服务端流式RPC，Server是Stream，Client为普通RPC请求</span><br><span class="hljs-comment">//客户端发送一次普通的RPC请求，服务端通过流式响应多次发送数据集</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *StreamService)</span></span> List(r *pb.StreamRequest, stream pb.StreamService_ListServer) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">//客户端流式RPC，单向流</span><br><span class="hljs-comment">//客户端通过流式多次发送RPC请求给服务端，服务端发送一次普通的RPC请求给客户端</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *StreamService)</span></span> Record(stream pb.StreamService_RecordServer) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">//双向流，由客户端发起流式的RPC方法请求，服务端以同样的流式RPC方法响应请求</span><br><span class="hljs-comment">//首个请求一定是client发起，具体交互方法（谁先谁后，一次发多少，响应多少，什么时候关闭）根据程序编写方式来确定（可以结合协程）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *StreamService)</span></span> Route(stream pb.StreamService_RouteServer) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）client-go"><a href="#2）client-go" class="headerlink" title="2）client.go"></a>2）client.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> PORT = <span class="hljs-string">&quot;8888&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := grpc.Dial(<span class="hljs-string">&quot;:&quot;</span>+PORT, grpc.WithInsecure())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;grpc.Dial err: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br>client := pb.NewStreamServiceClient(conn)<br><br>err = printLists(client, &amp;pb.StreamRequest&#123;Pt: &amp;pb.StreamPoint&#123;Name: <span class="hljs-string">&quot;gRPC Stream Client: List&quot;</span>, Value: <span class="hljs-number">1234</span>&#125;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;printLists.err: %v&quot;</span>, err)<br>&#125;<br><br>err = printRecord(client, &amp;pb.StreamRequest&#123;Pt: &amp;pb.StreamPoint&#123;Name: <span class="hljs-string">&quot;gRPC Stream Client: Record&quot;</span>, Value: <span class="hljs-number">9999</span>&#125;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;printRecord.err: %v&quot;</span>, err)<br>&#125;<br><br>err = printRoute(client, &amp;pb.StreamRequest&#123;Pt: &amp;pb.StreamPoint&#123;Name: <span class="hljs-string">&quot;gRPC Stream Client: Route&quot;</span>, Value: <span class="hljs-number">1111</span>&#125;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;printRoute.err: %v&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printLists</span><span class="hljs-params">(client pb.StreamServiceClient, r *pb.StreamRequest)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printRecord</span><span class="hljs-params">(client pb.StreamServiceClient, r *pb.StreamRequest)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printRoute</span><span class="hljs-params">(client pb.StreamServiceClient, r *pb.StreamRequest)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6、Server-side-streaming-RPC：服务器端流式-RPC"><a href="#6、Server-side-streaming-RPC：服务器端流式-RPC" class="headerlink" title="6、Server-side streaming RPC：服务器端流式 RPC"></a>6、Server-side streaming RPC：服务器端流式 RPC</h2><p>服务端流式RPC，Server是Stream，Client为普通RPC请求，客户端发送一次普通的RPC请求，服务端通过流式响应多次发送数据集。</p><p><img src="/img/grpc_stream/grpc4.png"></p><h3 id="1）server"><a href="#1）server" class="headerlink" title="1）server"></a>1）server</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. 建立连接 获取client</span><br><span class="hljs-comment">2. 通过 client 获取stream</span><br><span class="hljs-comment">3. for循环中通过stream.Recv()依次获取服务端推送的消息</span><br><span class="hljs-comment">4. err==io.EOF则表示服务端关闭stream了</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *StreamService)</span></span> List(r *pb.StreamRequest, stream pb.StreamService_ListServer) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 具体返回多少个response根据业务逻辑调整</span><br><span class="hljs-keyword">for</span> n := <span class="hljs-number">0</span>; n &lt;= <span class="hljs-number">6</span>; n++ &#123;<br><span class="hljs-comment">// 通过 send 方法不断推送数据</span><br>err := stream.Send(&amp;pb.StreamResponse&#123;<br>Pt: &amp;pb.StreamPoint&#123;<br>Name:  r.Pt.Name,<br>Value: r.Pt.Value + <span class="hljs-type">int32</span>(n),<br>&#125;,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>time.Sleep(time.Second)<br>&#125;<br><span class="hljs-comment">// 返回nil表示已经完成响应</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 Server，主要留意 stream.Send 方法。它看上去能发送 N 次？有没有大小限制？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StreamService_ListServer <span class="hljs-keyword">interface</span> &#123;<br>Send(*StreamResponse) <span class="hljs-type">error</span><br>grpc.ServerStream<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *streamServiceListServer)</span></span> Send(m *StreamResponse) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> x.ServerStream.SendMsg(m)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过阅读源码，可得知是 protoc 在生成时，根据定义生成了各式各样符合标准的接口方法。最终再统一调度内部的 SendMsg 方法，该方法涉及以下过程:</p><ul><li>消息体（对象）序列化</li><li>压缩序列化后的消息体</li><li>对正在传输的消息体增加 5 个字节的 header</li><li>判断压缩+序列化后的消息体总字节长度是否大于预设的 maxSendMessageSize（预设值为 math.MaxInt32），若超出则提示错误</li><li>写入给流的数据集</li></ul><h3 id="2）client"><a href="#2）client" class="headerlink" title="2）client"></a>2）client</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. 建立连接 获取client</span><br><span class="hljs-comment">2. 通过 client 获取stream</span><br><span class="hljs-comment">3. for循环中通过stream.Recv()依次获取服务端推送的消息</span><br><span class="hljs-comment">4. err==io.EOF则表示服务端关闭stream了</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printLists</span><span class="hljs-params">(client pb.StreamServiceClient, r *pb.StreamRequest)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 调用获取stream</span><br>stream, err := client.List(context.Background(), r)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-comment">// for循环获取服务端推送的消息</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 通过 Recv() 不断获取服务端send()推送的消息</span><br>resp, err := stream.Recv()<br><span class="hljs-comment">// err==io.EOF则表示服务端关闭stream了</span><br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;resp: pj.name: %s, pt.value: %d&quot;</span>, resp.Pt.Name, resp.Pt.Value)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 Client，主要留意 stream.Recv() 方法。什么情况下 io.EOF ？什么情况下存在错误信息呢?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StreamService_ListClient <span class="hljs-keyword">interface</span> &#123;<br>Recv() (*StreamResponse, <span class="hljs-type">error</span>)<br>grpc.ClientStream<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *streamServiceListClient)</span></span> Recv() (*StreamResponse, <span class="hljs-type">error</span>) &#123;<br>m := <span class="hljs-built_in">new</span>(StreamResponse)<br><span class="hljs-keyword">if</span> err := x.ClientStream.RecvMsg(m); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> m, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>RecvMsg 会从流中读取完整的 gRPC 消息体，另外通过阅读源码可得知：</p><p>（1）RecvMsg 是阻塞等待的</p><p>（2）RecvMsg 当流成功&#x2F;结束（调用了 Close）时，会返回 io.EOF</p><p>（3）RecvMsg 当流出现任何错误时，流会被中止，错误信息会包含 RPC 错误码。而在 RecvMsg 中可能出现如下错误：</p><ul><li>io.EOF</li><li>io.ErrUnexpectedEOF</li><li>transport.ConnectionError</li><li>google.golang.org&#x2F;grpc&#x2F;codes</li></ul><h3 id="3）启动-amp-请求"><a href="#3）启动-amp-请求" class="headerlink" title="3）启动 &amp; 请求"></a>3）启动 &amp; 请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"># 启动服务端<br>$ <span class="hljs-keyword">go</span> run server.<span class="hljs-keyword">go</span><br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">55149</span><br><br># 启动客户端<br>$ <span class="hljs-keyword">go</span> run client.<span class="hljs-keyword">go</span> <br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">55158</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">09</span>:<span class="hljs-number">35</span>:<span class="hljs-number">03</span> resp: pj.name: gRPC Stream Client: List, pt.value: <span class="hljs-number">1234</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">09</span>:<span class="hljs-number">35</span>:<span class="hljs-number">04</span> resp: pj.name: gRPC Stream Client: List, pt.value: <span class="hljs-number">1235</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">09</span>:<span class="hljs-number">35</span>:<span class="hljs-number">05</span> resp: pj.name: gRPC Stream Client: List, pt.value: <span class="hljs-number">1236</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">09</span>:<span class="hljs-number">35</span>:<span class="hljs-number">06</span> resp: pj.name: gRPC Stream Client: List, pt.value: <span class="hljs-number">1237</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">09</span>:<span class="hljs-number">35</span>:<span class="hljs-number">07</span> resp: pj.name: gRPC Stream Client: List, pt.value: <span class="hljs-number">1238</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">09</span>:<span class="hljs-number">35</span>:<span class="hljs-number">08</span> resp: pj.name: gRPC Stream Client: List, pt.value: <span class="hljs-number">1239</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">09</span>:<span class="hljs-number">35</span>:<span class="hljs-number">09</span> resp: pj.name: gRPC Stream Client: List, pt.value: <span class="hljs-number">1240</span><br></code></pre></td></tr></table></figure><blockquote><p>服务器流式 RPC 类似于一元 RPC，除了服务器返回消息流以响应客户端的请求。发送所有消息后，服务器的状态详细信息（状态代码和可选状态消息）和可选尾随元数据将发送到客户端。这样就完成了服务器端的处理。客户端在拥有服务器的所有消息后完成。</p></blockquote><h2 id="7、Client-side-streaming-RPC：客户端流式-RPC"><a href="#7、Client-side-streaming-RPC：客户端流式-RPC" class="headerlink" title="7、Client-side streaming RPC：客户端流式 RPC"></a>7、Client-side streaming RPC：客户端流式 RPC</h2><p>客户端通过流式多次发送RPC请求给服务端，服务端发送一次响应给客户端。<br><img src="/img/grpc_stream/grpc5.png"></p><h3 id="1）server-1"><a href="#1）server-1" class="headerlink" title="1）server"></a>1）server</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. for循环中通过stream.Recv()不断接收client传来的数据</span><br><span class="hljs-comment">2. err == io.EOF表示客户端已经发送完毕关闭连接了,此时在等待服务端处理完并返回消息</span><br><span class="hljs-comment">3. stream.SendAndClose() 发送消息并关闭连接(虽然在客户端流里服务器这边并不需要关闭 但是方法还是叫的这个名字，内部也只会调用Send())</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *StreamService)</span></span> Record(stream pb.StreamService_RecordServer) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// for循环接收客户端发送的消息</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 通过 Recv() 不断获取客户端 send()推送的消息</span><br>r, err := stream.Recv()<br><span class="hljs-comment">// err == io.EOF表示已经获取全部数据</span><br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-comment">// SendAndClose 返回并关闭连接</span><br><span class="hljs-comment">// 在客户端发送完毕后服务端即可返回响应</span><br><span class="hljs-keyword">return</span> stream.SendAndClose(&amp;pb.StreamResponse&#123;Pt: &amp;pb.StreamPoint&#123;Name: <span class="hljs-string">&quot;gRPC Stream Server: Record&quot;</span>, Value: <span class="hljs-number">1</span>&#125;&#125;)<br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;stream.Recv pt.name: %s, pt.value: %d&quot;</span>, r.Pt.Name, r.Pt.Value)<br>time.Sleep(time.Second)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>stream.SendAndClose</code>：我们对每一个 Recv 都进行了处理，当发现 io.EOF (流关闭) 后，需要将最终的响应结果发送给客户端，同时关闭正在另外一侧等待的 Recv</p></blockquote><h3 id="2）client-1"><a href="#2）client-1" class="headerlink" title="2）client"></a>2）client</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. 建立连接并获取client</span><br><span class="hljs-comment">2. 获取 stream 并通过 Send 方法不断推送数据到服务端</span><br><span class="hljs-comment">3. 发送完成后通过stream.CloseAndRecv() 关闭stream并接收服务端返回结果</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printRecord</span><span class="hljs-params">(client pb.StreamServiceClient, r *pb.StreamRequest)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 获取 stream</span><br>stream, err := client.Record(context.Background())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; i++ &#123;<br><span class="hljs-comment">// 通过 Send 方法不断推送数据到服务端</span><br>err := stream.Send(r)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 发送完成后通过stream.CloseAndRecv() 关闭stream并接收服务端返回结果</span><br><span class="hljs-comment">// (服务端则根据err==io.EOF来判断client是否关闭stream)</span><br>resp, err := stream.CloseAndRecv()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;resp: pj.name: %s, pt.value: %d&quot;</span>, resp.Pt.Name, resp.Pt.Value)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>stream.CloseAndRecv 和 stream.SendAndClose 是配套使用的流方法</p></blockquote><h3 id="3）启动-amp-请求-1"><a href="#3）启动-amp-请求-1" class="headerlink" title="3）启动 &amp; 请求"></a>3）启动 &amp; 请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"># 启动服务端<br>$ <span class="hljs-keyword">go</span> run server.<span class="hljs-keyword">go</span><br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">57789</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">11</span>:<span class="hljs-number">59</span>:<span class="hljs-number">31</span> stream.Recv pt.name: gRPC Stream Client: Record, pt.value: <span class="hljs-number">9999</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">11</span>:<span class="hljs-number">59</span>:<span class="hljs-number">32</span> stream.Recv pt.name: gRPC Stream Client: Record, pt.value: <span class="hljs-number">9999</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">11</span>:<span class="hljs-number">59</span>:<span class="hljs-number">33</span> stream.Recv pt.name: gRPC Stream Client: Record, pt.value: <span class="hljs-number">9999</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">11</span>:<span class="hljs-number">59</span>:<span class="hljs-number">34</span> stream.Recv pt.name: gRPC Stream Client: Record, pt.value: <span class="hljs-number">9999</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">11</span>:<span class="hljs-number">59</span>:<span class="hljs-number">35</span> stream.Recv pt.name: gRPC Stream Client: Record, pt.value: <span class="hljs-number">9999</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">11</span>:<span class="hljs-number">59</span>:<span class="hljs-number">36</span> stream.Recv pt.name: gRPC Stream Client: Record, pt.value: <span class="hljs-number">9999</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">11</span>:<span class="hljs-number">59</span>:<span class="hljs-number">37</span> stream.Recv pt.name: gRPC Stream Client: Record, pt.value: <span class="hljs-number">9999</span><br><br># 启动客户端<br>$ <span class="hljs-keyword">go</span> run client.<span class="hljs-keyword">go</span> <br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">57793</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">11</span>:<span class="hljs-number">59</span>:<span class="hljs-number">38</span> resp: pj.name: gRPC Stream Server: Record, pt.value: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="8、Bidirectional-streaming-RPC：双向流式-RPC"><a href="#8、Bidirectional-streaming-RPC：双向流式-RPC" class="headerlink" title="8、Bidirectional streaming RPC：双向流式 RPC"></a>8、Bidirectional streaming RPC：双向流式 RPC</h2><p>双向流，由客户端发起流式的RPC方法请求，服务端以同样的流式RPC方法响应请求 首个请求一定是client发起，具体交互方法（谁先谁后，一次发多少，响应多少，什么时候关闭）根据程序编写方式来确定（可以结合协程）。<br><img src="/img/grpc_stream/grpc6.png"></p><h3 id="1）server-2"><a href="#1）server-2" class="headerlink" title="1）server"></a>1）server</h3><blockquote><p>一般是使用两个 Goroutine，一个接收数据，一个推送数据。最后通过 return nil 表示已经完成响应。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// 1. 建立连接 获取client</span><br><span class="hljs-comment">// 2. 通过client调用方法获取stream</span><br><span class="hljs-comment">// 3. 开两个goroutine（使用 chan 传递数据） 分别用于Recv()和Send()</span><br><span class="hljs-comment">// 3.1 一直Recv()到err==io.EOF(即客户端关闭stream)</span><br><span class="hljs-comment">// 3.2 Send()则自己控制什么时候Close 服务端stream没有close 只要跳出循环就算close了。 具体见https://github.com/grpc/grpc-go/issues/444</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *StreamService)</span></span> Route(stream pb.StreamService_RouteServer) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">var</span> (<br>wg    sync.WaitGroup <span class="hljs-comment">//任务编排</span><br>msgCh = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *pb.StreamPoint)<br>)<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>n := <span class="hljs-number">0</span><br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> msgCh &#123;<br>err := stream.Send(&amp;pb.StreamResponse&#123;<br>Pt: &amp;pb.StreamPoint&#123;<br>Name:  v.GetName(),<br>Value: <span class="hljs-type">int32</span>(n),<br>&#125;,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Send error :&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>n++<br>&#125;<br>&#125;()<br><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> &#123;<br>r, err := stream.Recv()<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;recv error :%v&quot;</span>, err)<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;stream.Recv pt.name: %s, pt.value: %d&quot;</span>, r.Pt.Name, r.Pt.Value)<br>msgCh &lt;- &amp;pb.StreamPoint&#123;<br>Name: <span class="hljs-string">&quot;gRPC Stream Server: Route&quot;</span>,<br>&#125;<br>&#125;<br><span class="hljs-built_in">close</span>(msgCh)<br>&#125;()<br><br>wg.Wait() <span class="hljs-comment">//等待任务结束</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）client-2"><a href="#2）client-2" class="headerlink" title="2）client"></a>2）client</h3><blockquote><p>和服务端类似，不过客户端推送结束后需要主动调用 stream.CloseSend() 函数来关闭Stream。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. 建立连接 获取client</span><br><span class="hljs-comment">2. 通过client获取stream</span><br><span class="hljs-comment">3. 开两个goroutine 分别用于Recv()和Send()</span><br><span class="hljs-comment">3.1 一直Recv()到err==io.EOF(即服务端关闭stream)</span><br><span class="hljs-comment">3.2 Send()则由自己控制</span><br><span class="hljs-comment">4. 发送完毕调用 stream.CloseSend()关闭stream 必须调用关闭 否则Server会一直尝试接收数据 一直报错...</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printRoute</span><span class="hljs-params">(client pb.StreamServiceClient, r *pb.StreamRequest)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-comment">// 调用方法获取stream</span><br>stream, err := client.Route(context.Background())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// 开两个goroutine 分别用于Recv()和Send()</span><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> &#123;<br>resp, err := stream.Recv()<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br>fmt.Println(<span class="hljs-string">&quot;Server Closed&quot;</span>)<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>log.Printf(<span class="hljs-string">&quot;resp: pj.name: %s, pt.value: %d&quot;</span>, resp.Pt.Name, resp.Pt.Value)<br>&#125;<br>&#125;()<br><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><br><span class="hljs-keyword">for</span> n := <span class="hljs-number">0</span>; n &lt;= <span class="hljs-number">6</span>; n++ &#123;<br>err := stream.Send(r)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;send error:%v\n&quot;</span>, err)<br>&#125;<br>time.Sleep(time.Second)<br>&#125;<br><br><span class="hljs-comment">// 发送完毕关闭stream</span><br>err = stream.CloseSend()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;Send error:%v\n&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;()<br><br>wg.Wait()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3）启动-amp-请求-2"><a href="#3）启动-amp-请求-2" class="headerlink" title="3）启动 &amp; 请求"></a>3）启动 &amp; 请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"># 启动服务端<br>$ <span class="hljs-keyword">go</span> run server.<span class="hljs-keyword">go</span><br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">55108</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">12</span>:<span class="hljs-number">29</span>:<span class="hljs-number">35</span> stream.Recv pt.name: gRPC Stream Client: Route, pt.value: <span class="hljs-number">1111</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">12</span>:<span class="hljs-number">29</span>:<span class="hljs-number">36</span> stream.Recv pt.name: gRPC Stream Client: Route, pt.value: <span class="hljs-number">1111</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">12</span>:<span class="hljs-number">29</span>:<span class="hljs-number">37</span> stream.Recv pt.name: gRPC Stream Client: Route, pt.value: <span class="hljs-number">1111</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">12</span>:<span class="hljs-number">29</span>:<span class="hljs-number">38</span> stream.Recv pt.name: gRPC Stream Client: Route, pt.value: <span class="hljs-number">1111</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">12</span>:<span class="hljs-number">29</span>:<span class="hljs-number">39</span> stream.Recv pt.name: gRPC Stream Client: Route, pt.value: <span class="hljs-number">1111</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">12</span>:<span class="hljs-number">29</span>:<span class="hljs-number">40</span> stream.Recv pt.name: gRPC Stream Client: Route, pt.value: <span class="hljs-number">1111</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">12</span>:<span class="hljs-number">29</span>:<span class="hljs-number">41</span> stream.Recv pt.name: gRPC Stream Client: Route, pt.value: <span class="hljs-number">1111</span><br><br># 启动客户端<br>$ <span class="hljs-keyword">go</span> run client.<span class="hljs-keyword">go</span> <br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">55113</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">12</span>:<span class="hljs-number">29</span>:<span class="hljs-number">35</span> resp: pj.name: gRPC Stream Server: Route, pt.value: <span class="hljs-number">0</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">12</span>:<span class="hljs-number">29</span>:<span class="hljs-number">36</span> resp: pj.name: gRPC Stream Server: Route, pt.value: <span class="hljs-number">1</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">12</span>:<span class="hljs-number">29</span>:<span class="hljs-number">37</span> resp: pj.name: gRPC Stream Server: Route, pt.value: <span class="hljs-number">2</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">12</span>:<span class="hljs-number">29</span>:<span class="hljs-number">38</span> resp: pj.name: gRPC Stream Server: Route, pt.value: <span class="hljs-number">3</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">12</span>:<span class="hljs-number">29</span>:<span class="hljs-number">39</span> resp: pj.name: gRPC Stream Server: Route, pt.value: <span class="hljs-number">4</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">12</span>:<span class="hljs-number">29</span>:<span class="hljs-number">40</span> resp: pj.name: gRPC Stream Server: Route, pt.value: <span class="hljs-number">5</span><br><span class="hljs-number">2022</span>/<span class="hljs-number">11</span>/<span class="hljs-number">03</span> <span class="hljs-number">12</span>:<span class="hljs-number">29</span>:<span class="hljs-number">41</span> resp: pj.name: gRPC Stream Server: Route, pt.value: <span class="hljs-number">6</span><br>Server Closed<br></code></pre></td></tr></table></figure><h1 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h1><p>客户端或者服务端都有对应的 推送或者 接收对象，我们只要 不断循环 <code>Recv()</code>或者 <code>Send()</code> 就能接收或者推送了！</p><blockquote><p>gRPC Stream 和 goroutine 配合简直完美。通过 Stream 我们可以更加灵活的实现自己的业务。如 订阅，大数据传输等。</p></blockquote><p>Client发送完成后需要手动调用Close()或者CloseSend()方法关闭stream，Server端则return nil就会自动 Close。</p><p>1）<strong>ServerStream</strong></p><ul><li>服务端处理完成后return nil代表响应完成</li><li>客户端通过 err &#x3D;&#x3D; io.EOF判断服务端是否响应完成</li></ul><p>2）<strong>ClientStream</strong></p><ul><li>客户端发送完毕通过<code>CloseAndRecv</code>关闭stream 并接收服务端响应</li><li>服务端通过 <code>err == io.EOF</code>判断客户端是否发送完毕，完毕后使用SendAndClose关闭 stream并返回响应。</li></ul><p>3）<strong>BidirectionalStream</strong></p><ul><li>客户端服务端都通过stream向对方推送数据</li><li>客户端推送完成后通过CloseSend关闭流，通过<code>err == io.EOF</code>判断服务端是否响应完成</li><li>服务端通过<code>err == io.EOF</code>判断客户端是否响应完成,通过return nil表示已经完成响应<br>通过<code>err == io.EOF</code>来判定是否把对方推送的数据全部获取到了。</li></ul><p>客户端通过CloseAndRecv或者CloseSend关闭 Stream，服务端则通过SendAndClose或者直接 return nil来返回响应。</p><p>参考文章：<br><a href="https://www.lixueduan.com/posts/grpc/03-stream/#4-serverstream">https://www.lixueduan.com/posts/grpc/03-stream/#4-serverstream</a></p>]]></content>
    
    
    <categories>
      
      <category>gRPC学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>微服务</tag>
      
      <tag>grpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gRPC（三）基础：gRPC快速入门</title>
    <link href="/2022/11/01/grpc-use/"/>
    <url>/2022/11/01/grpc-use/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>示例代码已经上传到github：<a href="https://github.com/Gopherlinzy/go-grpc-example">点击跳转</a><br>gRPC官方文档：<a href="https://grpc.io/docs/what-is-grpc/">点击跳转</a></p></blockquote><h1 id="一、gRPC概述"><a href="#一、gRPC概述" class="headerlink" title="一、gRPC概述"></a>一、gRPC概述</h1><h2 id="1、什么是gRPC？"><a href="#1、什么是gRPC？" class="headerlink" title="1、什么是gRPC？"></a>1、什么是gRPC？</h2><p>gRPC 是一个强大的开源 RPC（远程过程调用）框架，用于构建可扩展且快速的 API。它允许客户端和服务器应用程序透明地通信并开发连接的系统。gRPC框架依赖 <code>HTTP/2</code>、协议缓冲区和其他现代技术堆栈来确保最大的 API 安全性、性能和可扩展性。</p><p>在 gRPC 中，客户端应用程序可以直接调用不同机器上的服务器应用程序上的方法，就像是本地对象一样，更容易创建<code>分布式应用程序和服务</code>。</p><p>与许多 RPC 系统一样，gRPC 基于定义服务的思想，指定可以远程调用的方法及其参数和返回类型。在服务端，服务端实现这个接口并运行一个 gRPC 服务器来处理客户端调用。在客户端，客户端有一个存根（自动生成的文件），它提供与服务器相同的方法。</p><p><img src="/img/grpc_use/grpc1.png"></p><h2 id="2、gRPC-的历史"><a href="#2、gRPC-的历史" class="headerlink" title="2、gRPC 的历史"></a>2、gRPC 的历史</h2><p>2015 年，Google 开发了 gRPC 作为 RPC 框架的扩展，以链接使用不同技术创建的许多微服务。最初，它与 Google 的内部基础设施密切相关，但后来，它被开源并标准化以供社区使用。在其发布的第一年，顶级组织利用它来支持从微服务到 Web、移动和物联网的用例。并在 2017 年因越来越受欢迎而成为云原生计算基金会（CNCF）孵化项目。</p><h2 id="3、使用Protobuf"><a href="#3、使用Protobuf" class="headerlink" title="3、使用Protobuf"></a>3、使用Protobuf</h2><p>Protobuf 是 Google 的<code>序列化/反序列化协议</code>，可以轻松定义服务和自动生成客户端库。gRPC 使用此协议作为其接口定义语言 (IDL) 和序列化工具集。</p><ul><li>客户端和服务器之间的 gRPC 服务和消息在 proto 文件中定义。</li><li>Protobuf 编译器 <code>protoc</code> 生成客户端和服务器代码，在运行时将 .proto 文件加载到内存中，并使用内存中的模式来<code>序列化/反序列化二进制消息</code>。</li><li>代码生成后，每条消息都会在客户端和远程服务之间进行交换。</li></ul><blockquote><p>为什么使用Protobuf？<br>使用 Protobuf 进行解析需要更少的 CPU 资源，因为数据被转换为二进制格式，并且编码的消息的大小更轻。因此，消息交换速度更快，即使在 CPU 速度较慢的机器（例如移动设备）中也是如此。</p></blockquote><h2 id="4、gRPC架构"><a href="#4、gRPC架构" class="headerlink" title="4、gRPC架构"></a>4、gRPC架构</h2><p>在下面的 gRPC 架构图中，我们有 gRPC 客户端和服务器端。在 gRPC 中，每个客户端服务都包含一个存根（自动生成的文件），类似于包含当前远程过程的接口。</p><p>gRPC工作流程：</p><ul><li>gRPC 客户端将要发送到服务器的参数对存根进行本地过程调用。</li><li>客户端存根使用 Protobuf 使用<code>编组过程序列化参数</code>，并将请求转发到本地机器中的本地客户端时间库。</li><li>操作系统通过 <code>HTTP/2</code> 协议调用远程服务器机器。</li><li>服务器的操作系统接收数据包并调用服务器存根程序，该程序对接收到的参数进行解码并使用 Protobuf 执行相应的程序调用。</li><li>服务器存根将编码响应发送回客户端传输层。客户端存根取回结果消息并解包返回的参数，然后执行返回给调用者。<br><img src="/img/grpc_use/grpc2.png"></li></ul><h1 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h1><p>使用 Go 来编写 gRPC Server 和 Client，让其互相通讯。在此之上会使用到如下库：</p><blockquote><p>下面示例是在 <code>windows</code>环境中安装。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">google.golang.org/grpc<br>google.golang.org/protobuf/cmd/protoc-gen-go<br>google.golang.org/grpc/cmd/protoc-gen-go-grpc<br></code></pre></td></tr></table></figure><ol><li>初始化项目<code>go mod init 项目名称</code>模块管理依赖项</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> mod init <span class="hljs-keyword">go</span>-grpc-examle<br></code></pre></td></tr></table></figure><ol start="2"><li>安装protoc：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜ go get -u google.golang.org/grpc<br></code></pre></td></tr></table></figure><p>通过<code>--version</code>命令查看是否安装成功:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜ protoc --version<br>libprotoc 3.20.1<br></code></pre></td></tr></table></figure><ol start="2"><li>使用以下命令为 Go 安装协议编译器插件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28<br>➜ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2<br></code></pre></td></tr></table></figure><p>验证插件是否安装成功:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜ protoc-gen-go --version<br>protoc-gen-go.exe v1.28.1<br><br>➜ protoc-gen-go-grpc --version<br>protoc-gen-go-grpc 1.2.0<br></code></pre></td></tr></table></figure><ol start="3"><li>更新你的PATH，以便protoc编译器可以找到插件（你不在gopath下创建的项目，这里自行百度改一下PATH）</li></ol><h1 id="三、编写gRPC-Client-and-Server"><a href="#三、编写gRPC-Client-and-Server" class="headerlink" title="三、编写gRPC Client and Server"></a>三、编写gRPC Client and Server</h1><h2 id="1、目录结构"><a href="#1、目录结构" class="headerlink" title="1、目录结构"></a>1、目录结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">go-grpc-example<br>├── client<br>│   └──hello_client<br>│   └── client.go<br>├── proto<br>│   └──hello<br>│   └── hello.proto<br>├── server<br>│   └──hello_server<br>│   └── server.go<br></code></pre></td></tr></table></figure><h2 id="2、编写-proto-文件"><a href="#2、编写-proto-文件" class="headerlink" title="2、编写 .proto 文件"></a>2、编写 .proto 文件</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-comment">// 定义go生成后的包名</span><br>option go_package = <span class="hljs-string">&quot;./;hello&quot;</span>;<br><span class="hljs-keyword">package</span> proto;<br><br><span class="hljs-comment">// 定义入参</span><br>message Request &#123;<br>  <span class="hljs-type">string</span> name =<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 定义返回</span><br>message Response &#123;<br>  <span class="hljs-type">string</span> result = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义接口</span><br>service UserService &#123;<br>  rpc Say(Request) returns (Response);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、生成Go代码"><a href="#3、生成Go代码" class="headerlink" title="3、生成Go代码"></a>3、生成Go代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 同时生成hello.pb.go 和 hello_grpc.pb.go</span><br>➜ protoc --go-grpc_out=. --go_out=. hello.proto<br></code></pre></td></tr></table></figure><p>当前目录下可以看到生成两个文件：<br><img src="/img/grpc_use/grpc3.png"></p><h2 id="4、编写-Server-服务端代码"><a href="#4、编写-Server-服务端代码" class="headerlink" title="4、编写 Server 服务端代码"></a>4、编写 Server 服务端代码</h2><p>编写 gRPC Server 的基础模板，完成一个方法的调用。对 server.go 写入如下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> HelloService <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 必须嵌入UnimplementedUserServiceServer</span><br>hello.UnimplementedUserServiceServer<br>&#125;<br><br><span class="hljs-comment">// 实现SayHi方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HelloService)</span></span> SayHi(ctx context.Context, req *hello.Request) (res *hello.Response, err <span class="hljs-type">error</span>) &#123;<br>format := time.Now().Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>)<br><span class="hljs-keyword">return</span> &amp;hello.Response&#123;Result: <span class="hljs-string">&quot;hi &quot;</span> + req.GetName() + <span class="hljs-string">&quot;---&quot;</span> + format&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">const</span> PORT = <span class="hljs-string">&quot;8888&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建grpc服务</span><br>server := grpc.NewServer()<br><span class="hljs-comment">// 注册服务</span><br>hello.RegisterUserServiceServer(server, &amp;HelloService&#123;&#125;)<br><br><span class="hljs-comment">// 监听端口</span><br>lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:&quot;</span>+PORT)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;net.Listen err: %v&quot;</span>, err)<br>&#125;<br><br>server.Serve(lis)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、编写-Client-客户端代码"><a href="#5、编写-Client-客户端代码" class="headerlink" title="5、编写 Client 客户端代码"></a>5、编写 Client 客户端代码</h2><p>接下来编写 gRPC Go Client 的基础模板，打开 hello_client&#x2F;client.go 文件，写入以下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> PORT = <span class="hljs-string">&quot;8888&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 建立链接</span><br>conn, err := grpc.Dial(<span class="hljs-string">&quot;:&quot;</span>+PORT, grpc.WithInsecure())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;grpc.Dial err: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 一定要记得关闭链接</span><br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-comment">// 实例化客户端</span><br>client := hello.NewUserServiceClient(conn)<br><span class="hljs-comment">// 发起请求</span><br>response, err := client.SayHi(context.Background(), &amp;hello.Request&#123;Name: <span class="hljs-string">&quot;lin钟一&quot;</span>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;client.SayHi err: %v&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;resp: %s&quot;</span>, response.GetResult())<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6、启动-amp-请求"><a href="#6、启动-amp-请求" class="headerlink" title="6、启动 &amp; 请求"></a>6、启动 &amp; 请求</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"># 启动服务端<br>$ <span class="hljs-keyword">go</span> run server.<span class="hljs-keyword">go</span><br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">50970</span><br><br># 启动客户端<br>$ <span class="hljs-keyword">go</span> run client.<span class="hljs-keyword">go</span> <br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">51040</span><br>resp: hi lin钟一--<span class="hljs-number">-2022</span><span class="hljs-number">-11</span><span class="hljs-number">-01</span> <span class="hljs-number">14</span>:<span class="hljs-number">54</span>:<span class="hljs-number">01</span><br></code></pre></td></tr></table></figure><h1 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h1><p>在本文，我们对 gRPC Client&#x2F;Server 进行了介绍和了解。希望你结合第一章写的rpc请求的方法对文中讲述内容再写一个 Demo 进行深入了解。</p><p>下一篇关于gRPC Streaming的内容，gRPC 三种类型的流式。</p><ul><li>Server-side streaming RPC：服务器端流式 RPC</li><li>Client-side streaming RPC：客户端流式 RPC</li><li>Bidirectional streaming RPC：双向流式 RPC</li></ul>]]></content>
    
    
    <categories>
      
      <category>gRPC学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>微服务</tag>
      
      <tag>grpc</tag>
      
      <tag>rpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gRPC（二）入门：Protobuf入门</title>
    <link href="/2022/10/31/grpc-protobuf/"/>
    <url>/2022/10/31/grpc-protobuf/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>通过protubuf文档先了解一下protobuf语法。<br>示例代码已经上传到github：<a href="https://github.com/Gopherlinzy/go-grpc-example">点击跳转</a></p></blockquote><h1 id="一、Protobuf"><a href="#一、Protobuf" class="headerlink" title="一、Protobuf"></a>一、Protobuf</h1><h2 id="1、什么是protobuf？"><a href="#1、什么是protobuf？" class="headerlink" title="1、什么是protobuf？"></a>1、什么是protobuf？</h2><p>Protocol Buffers ( Protobuf ) 是一种免费的开源 跨平台数据格式，用于序列化结构化数据。它是谷歌公司开发的一种数据描述语言，并于2008年开源。Protobuf刚开源时的定位类似于<code>XML、JSON</code>等数据描述语言，通过附带工具生成代码并实现将结构化数据序列化的功能。</p><p>Protocol Buffers 是一种与语言、平台无关，可扩展的序列化结构化数据的方法，常用于通信协议，数据存储等等。相较于 JSON、XML，它更小、更快、更简单，因此也更受开发人员的青眯。</p><p>protobuf官方文档：<a href="https://developers.google.com/protocol-buffers/docs/overview">点击跳转</a></p><h2 id="2、JSON、XML、Protobuf选择"><a href="#2、JSON、XML、Protobuf选择" class="headerlink" title="2、JSON、XML、Protobuf选择"></a>2、JSON、XML、Protobuf选择</h2><h3 id="1）什么是序列化和反序列化"><a href="#1）什么是序列化和反序列化" class="headerlink" title="1）什么是序列化和反序列化"></a>1）什么是序列化和反序列化</h3><ul><li>序列化是将数据结构或对象状态转换为格式（xml&#x2F;json&#x2F;protobuf）的过程可以存储或传输。</li><li>反序列化是从表示的格式（xml&#x2F;json&#x2F;protobuf）构造数据结构&#x2F;对象状态的过程</li></ul><p><img src="/img/grpc_protobuf/grpc1.png"></p><h3 id="2）JSON、XML、Protobuf对比"><a href="#2）JSON、XML、Protobuf对比" class="headerlink" title="2）JSON、XML、Protobuf对比"></a>2）JSON、XML、Protobuf对比</h3><p><strong>JSON</strong>：最流行的主要还是json。因为浏览器对于json数据支持非常好，有很多内建的函数支持。</p><ul><li>具有可读性&#x2F;可编辑性</li><li>无需预先知道模式即可解析</li><li>优秀的浏览器支持</li><li>比 XML 更简洁</li></ul><p>JSON数据格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br><span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;Protobuf article&quot;</span>,<br><span class="hljs-string">&quot;status&quot;</span>:<span class="hljs-string">&quot;DRAFT&quot;</span>,<br><span class="hljs-string">&quot;members&quot;</span> : [<br>    &#123;<br>      <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Molecule Man&quot;</span>,<br>      <span class="hljs-string">&quot;age&quot;</span> : 29,<br>      <span class="hljs-string">&quot;secretIdentity&quot;</span> : <span class="hljs-string">&quot;Dan Jukes&quot;</span>,<br>      <span class="hljs-string">&quot;powers&quot;</span> : [<br>        <span class="hljs-string">&quot;Radiation resistance&quot;</span>,<br>        <span class="hljs-string">&quot;Turning tiny&quot;</span>,<br>        <span class="hljs-string">&quot;Radiation blast&quot;</span><br>      ]<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>XML</strong>：现在基本很少使用XML。json使用了键值对的方式，不仅压缩了一定的数据空间，同时也具有可读性。</p><ul><li>具有可读性&#x2F;可编辑性</li><li>无需预先知道模式即可解析</li><li>SOAP等标准</li><li>良好的工具支持（xsd、xslt、sax、dom 等）</li><li>相当冗长</li></ul><p>XML数据格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">medium</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Protobuf article<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">status</span>&gt;</span>DRAFT<span class="hljs-tag">&lt;/<span class="hljs-name">status</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">medium</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Protobuf</strong>：适合高性能，对响应速度有要求的数据传输场景。因为<code>profobuf是二进制数据格式，需要编码和解码</code>。数据本身不具有可读性。因此只有在反序列化之后得到真正可读的数据。</p><ul><li>非常密集的数据（输出小）</li><li>在不知道架构的情况下很难稳健地解码（数据格式在内部是模棱两可的，需要架构来解释）</li><li>处理速度非常快</li><li>不具有可读性&#x2F;可编辑性（密集的二进制数据）</li></ul><p>Protobuf数据格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">##.proto file<br>message Medium &#123;<br>  required <span class="hljs-type">string</span> title = <span class="hljs-number">1</span>;<br>  enum StatusType &#123;<br>    DRAFT = <span class="hljs-number">0</span>;<br>    PUBLISHED = <span class="hljs-number">1</span>;<br>  &#125;<br>  <br>  message Status &#123;<br>      required StatusType <span class="hljs-keyword">type</span> = <span class="hljs-number">0</span>[<span class="hljs-keyword">default</span> = DRAFT];<br>  &#125;<br>  required Status status = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>数据格式</th><th>数据保存方式</th><th>可读性&#x2F;可编辑性</th><th>解析速度</th><th>语言支持</th><th>使用范围</th></tr></thead><tbody><tr><td>JSON</td><td>文本</td><td>好</td><td>一般</td><td>所有语言</td><td>文件存储、数据交互</td></tr><tr><td>XML</td><td>文本</td><td>好</td><td>慢</td><td>所有语言</td><td>文件存储、数据交互</td></tr><tr><td>Protobuf</td><td>二进制</td><td>不可读</td><td>快</td><td>所有语言</td><td>文件存储、数据交互</td></tr></tbody></table><h3 id="3）使用Protobuf替代XML-x2F-JSON的好处"><a href="#3）使用Protobuf替代XML-x2F-JSON的好处" class="headerlink" title="3）使用Protobuf替代XML&#x2F;JSON的好处"></a>3）使用Protobuf替代XML&#x2F;JSON的好处</h3><ul><li>与xml&#x2F;json相比，Protobuf格式在表示数据结构方面更小、更快。</li><li>xml&#x2F;Json以字符串形式交换数据，然后在使用<code>解析器</code>检索时解析它们，这个过程在处理和内存消耗方面可能非常昂贵。但是使用protobuf，它使用预定义模式，使得解析逻辑高效而简单。</li><li>解析json字符串、数组和对象需要顺序扫描，这意味着没有元素大小或体头的计数。多层次xml文档也是如此。</li></ul><p>当然也不能一味的使用Protobuf，JSON适用的场景远远大于Protobuf，在有些时候Protocol Buffers 仍然沒有 JSON 要来的方便。</p><ul><li>与xml&#x2F;json相比，protobuf的学习曲线略高。</li><li>当你的数据是需要别人可读的。</li><li>你不打算直接处理接收的数据，而是从数据中取你想要的部分处理。</li><li>不想经过特殊处理，直接能从浏览器中解读的。</li><li>在web服务还没有准备好将数据模型绑定到特定模式的场景中，protobuf没有多大用处。</li></ul><h3 id="4）Protobuf使用场景"><a href="#4）Protobuf使用场景" class="headerlink" title="4）Protobuf使用场景"></a>4）Protobuf使用场景</h3><ul><li>在考虑将 Protobuf 用于web服务之间的通信(比如不与客户端浏览器解析引擎交互)</li><li>当文档大小在MB左右，且数据类型混合时，protobuf将在性能方面优于xml&#x2F;json，protobuf在网络上对数据的编码和解码速度更快。如果数据是巨大的GB，那么无论选择什么编码技术栈(如protobug&#x2F;json&#x2F;xml)，都需要压缩。</li><li>在需要双重解码的场景中(比如威胁搜索对同一命令行进行多次解码)，protobuf比JSON要快得多。</li><li>当web服务过渡到使用gRPC而不是传统的REST框架时，protobuf是推荐使用的标准。</li></ul><h1 id="二、proto3语法"><a href="#二、proto3语法" class="headerlink" title="二、proto3语法"></a>二、proto3语法</h1><h2 id="1、简单示例"><a href="#1、简单示例" class="headerlink" title="1、简单示例"></a>1、简单示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 指明当前使用proto3语法，如果不指定，编译器会使用proto2</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-comment">// package声明符，用来防止消息类型有命名冲突</span><br><span class="hljs-keyword">package</span> msg;<br><span class="hljs-comment">// 选项信息，对应go的包路径</span><br>option go_package = <span class="hljs-string">&quot;server/msg&quot;</span>;<br><span class="hljs-comment">// message关键字，像go中的结构体</span><br>message FirstMsg &#123;<br>  <span class="hljs-comment">// 类型 字段名 标识号</span><br>  <span class="hljs-type">int32</span> id = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">string</span> name=<span class="hljs-number">2</span>;<br>  <span class="hljs-type">string</span> age=<span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>syntax</code>: 用来标记当前使用proto的哪个版本。如果不指定，编译器会使用proto2。<br> <code>package</code>: 指定包名，用来防止消息类型命名冲突。<br> <code>option go_package</code>: 选项信息，代表生成后的go代码包路径。在生成 gRPC 代码时，必须指明。<br> <code>message</code>: 声明消息的关键字，类似Go语言中的struct。</p><p> FirstMsg 消息定义指定了三个字段（名称&#x2F;值对），每个字段都有一个名称和一个类型。<br>定义字段语法格式: <code>类型 字段名 编号</code>，例如repeated int32 nums &#x3D; 1;在生成gRPC代码时会自动生成数组[]int32类型。</p><blockquote><p>分配字段编号说明:</p><ul><li>消息定义中的每个字段都有一个唯一的编号。这些字段编号用于在 消息二进制格式中标识您的字段，并且在使用消息类型后不应更改。</li><li><code>[1, 15]之内的标识号在编码的时候会占用一个字节。[16, 2047]之内的标识号则占用2个字节。</code></li><li>最小的标识号可以从1开始，最大到2^29 - 1, or 536,870,911。不可以使用其中的[19000－19999],因为是预留信息，如果使用，编译时会报错。</li></ul></blockquote><h2 id="2、proto数据类型与Go数据类型对应"><a href="#2、proto数据类型与Go数据类型对应" class="headerlink" title="2、proto数据类型与Go数据类型对应"></a>2、proto数据类型与Go数据类型对应</h2><table><thead><tr><th>.proto Type</th><th>Go Type</th><th align="left">Notes</th></tr></thead><tbody><tr><td>double</td><td>float64</td><td align="left"></td></tr><tr><td>float</td><td>float32</td><td align="left"></td></tr><tr><td>int32</td><td>int32</td><td align="left">使用变长编码。对于负值的效率很低，如果有负值,使用sint32</td></tr><tr><td>int64</td><td>int64</td><td align="left">使用变长编码。对于负值的效率很低，如果有负值,使用sint64</td></tr><tr><td>uint32</td><td>uint32</td><td align="left">使用变长编码</td></tr><tr><td>uint64</td><td>uint64</td><td align="left">使用变长编码</td></tr><tr><td>sint32</td><td>int32</td><td align="left">使用变长编码，负值时比int32高效的多</td></tr><tr><td>sint64</td><td>int64</td><td align="left">使用变长编码，有符号的整型值。编码时比通常的int64高效。</td></tr><tr><td>fixed32</td><td>uint32</td><td align="left">总是4个字节，如果数值比2^28^大的话，这个类型会比uint32高效。</td></tr><tr><td>fixed64</td><td>uint64</td><td align="left">总是8个字节，如果数值比2^56^大的话，这个类型会比uint64高效。</td></tr><tr><td>bool</td><td>bool</td><td align="left"></td></tr><tr><td>string</td><td>string</td><td align="left">字符串必须包含UTF-8编码或7位ASCII文本，且长度不能超过2^32^。</td></tr><tr><td>bytes</td><td>[]byte</td><td align="left">可以包含不超过2^32^的任意字节序列。</td></tr></tbody></table><h2 id="3、指定消息字段规则"><a href="#3、指定消息字段规则" class="headerlink" title="3、指定消息字段规则"></a>3、指定消息字段规则</h2><ul><li>singular：消息中<code>至多</code>存在一个该字段的数据。使用 proto3 语法时，当没有为给定字段指定其他字段规则时，这是默认字段规则。</li><li>optional：与 singular 类似，不同之处在于可以检查该值是否已经显式设置了值。字段有两种可能的状态:<ul><li>该字段已设置，并包含从连接中显式设置或解析的值。它将被序列化到连接上。</li><li>该字段未设置，将返回默认值。它不会被序列化。</li></ul></li><li>repeated：该字段类型可以在消息中可以重复设置多次，重复值的顺序将被保留。（设置成为数组类型）</li><li>map：成对的键&#x2F;值字段类型。</li></ul><h2 id="4、保留标示符-reserved"><a href="#4、保留标示符-reserved" class="headerlink" title="4、保留标示符 reserved"></a>4、保留标示符 reserved</h2><p><code> 什么是保留标示符？reserved 标记的编号、字段名，都不能在当前消息中使用。</code></p><blockquote><p>保留标识符的作用：对于特殊的字段名或者编号通过完全删除字段或将其注释掉来更新消息类型，如果后面出现其他用户对该消息进行更新重用了特殊的字段名或者编号，可能会导致严重的错误，包括数据损坏、出现隐私漏洞等。<br>为了确保这种情况不会发生的一种方法就是用保留标识符指定保留已删除的字段名或者编号。如果有其他用户试图重用这些字段名或编号，protobuf则会报错预警。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">package</span> demo;<br><br><span class="hljs-comment">// 在这个消息中标记</span><br>message DemoMsg &#123;<br>  <span class="hljs-comment">// 标示号：1，2，10，11，12，13 都不能用</span><br>  reserved <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span> to <span class="hljs-number">13</span>;<br>  <span class="hljs-comment">// 字段名 test、name 不能用</span><br>  reserved <span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>;<br>  <span class="hljs-comment">// 不能使用字段名，提示:Field name &#x27;name&#x27; is reserved</span><br>  <span class="hljs-type">string</span> name = <span class="hljs-number">3</span>;<br>  <span class="hljs-comment">// 不能使用标示号,提示:Field &#x27;id&#x27; uses reserved number 11</span><br>  <span class="hljs-type">int32</span> id = <span class="hljs-number">11</span>;<br>&#125;<br><br><span class="hljs-comment">// 另外一个消息还是可以正常使用</span><br>message Demo2Msg &#123;<br>  <span class="hljs-comment">// 标示号可以正常使用</span><br>  <span class="hljs-type">int32</span> id = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 字段名可以正常使用</span><br>  <span class="hljs-type">string</span> name = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：不能在同一 reserved 语句中混合字段名称和字段编号。</p></blockquote><h2 id="5、枚举类型"><a href="#5、枚举类型" class="headerlink" title="5、枚举类型"></a>5、枚举类型</h2><p>枚举：在定义消息类型时，希望其中一个字段只是预定义值列表中的一个值。<br>例如，假设您想为每个<code>SearchRequest</code>添加一个Corpus 字段，其中枚举预定义值可以是UNIVERSAL、WEB、IMAGES、LOCAL、NEWS、PRODUCTS或VIDEO。您可以通过在消息定义中添加一个枚举，为每个可能的值添加一个常量。</p><p>在下面的示例中，我们添加了一个包含所有可能值的 enum 调用Corpus，以及一个 type 字段Corpus：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">enum Corpus &#123;<br>  CORPUS_UNSPECIFIED = <span class="hljs-number">0</span>;<br>  CORPUS_UNIVERSAL = <span class="hljs-number">1</span>;<br>  CORPUS_WEB = <span class="hljs-number">2</span>;<br>  CORPUS_IMAGES = <span class="hljs-number">3</span>;<br>  CORPUS_LOCAL = <span class="hljs-number">4</span>;<br>  CORPUS_NEWS = <span class="hljs-number">5</span>;<br>  CORPUS_PRODUCTS = <span class="hljs-number">6</span>;<br>  CORPUS_VIDEO = <span class="hljs-number">7</span>;<br>&#125;<br>message SearchRequest &#123;<br>  <span class="hljs-type">string</span> query = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int32</span> page_number = <span class="hljs-number">2</span>;<br>  <span class="hljs-type">int32</span> result_per_page = <span class="hljs-number">3</span>;<br>  Corpus corpus = <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>每个枚举类型必须将其第一个类型映射为编号0, 原因有两个：</p><ul><li>必须有一个零值，以便我们可以使用 0 作为数字 默认值。</li><li>零值必须是第一个元素，以便与第一个枚举值始终为默认值的<code>proto2</code>语义兼容 。</li></ul></blockquote><p>可以对相同的编号分配给不同的枚举常量来定义别名。只需要将<code>allow_alias选项设置为true</code>，否则协议编译器将在找到别名时生成错误消息。尽管所有别名值在反序列化期间都有效，但在序列化时始终使用第一个值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">enum EnumAllowingAlias &#123;<br>  option allow_alias = <span class="hljs-literal">true</span>;<br>  EAA_UNSPECIFIED = <span class="hljs-number">0</span>;<br>  EAA_STARTED = <span class="hljs-number">1</span>;<br>  EAA_RUNNING = <span class="hljs-number">1</span>;<br>  EAA_FINISHED = <span class="hljs-number">2</span>;<br>&#125;<br>enum EnumNotAllowingAlias &#123;<br>  ENAA_UNSPECIFIED = <span class="hljs-number">0</span>;<br>  ENAA_STARTED = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// ENAA_RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.</span><br>  ENAA_FINISHED = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>枚举器常量必须在 32 位整数范围内。</li><li>枚举类型同样可以使用保留标识符。</li></ul></blockquote><h2 id="6、引入其他proto文件消息类型"><a href="#6、引入其他proto文件消息类型" class="headerlink" title="6、引入其他proto文件消息类型"></a>6、引入其他proto文件消息类型</h2><h3 id="1）被引入文件class-proto"><a href="#1）被引入文件class-proto" class="headerlink" title="1）被引入文件class.proto"></a>1）被引入文件class.proto</h3><p>文件位置:proto&#x2F;class.proto</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">syntax=<span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-comment">// 包名</span><br><span class="hljs-keyword">package</span> dto;<br><span class="hljs-comment">// 生成go后的文件路径</span><br>option go_package = <span class="hljs-string">&quot;grpc/server/dto&quot;</span>;<br><br>message ClassMsg &#123;<br>  <span class="hljs-type">int32</span>  classId = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">string</span> className = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）使用引入文件user-proto"><a href="#2）使用引入文件user-proto" class="headerlink" title="2）使用引入文件user.proto"></a>2）使用引入文件user.proto</h3><p>文件位置:proto&#x2F;user.proto</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-comment">// 导入其他proto文件</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;proto/class.proto&quot;</span>;<br><br>option go_package=<span class="hljs-string">&quot;grpc/server/dto&quot;</span>;<br><br><span class="hljs-keyword">package</span> dto;<br><br><span class="hljs-comment">// 用户信息</span><br>message UserDetail&#123;<br>  <span class="hljs-type">int32</span> id = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">string</span> name = <span class="hljs-number">2</span>;<br>  <span class="hljs-type">string</span> address = <span class="hljs-number">3</span>;<br>  repeated <span class="hljs-type">string</span> likes = <span class="hljs-number">4</span>;<br>  <span class="hljs-comment">// 所属班级</span><br>  ClassMsg classInfo = <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>如果Goland提示:Cannot resolve import...</code><br><img src="/img/grpc_protobuf/grpc2.png"></p><h2 id="7、嵌套消息类型"><a href="#7、嵌套消息类型" class="headerlink" title="7、嵌套消息类型"></a>7、嵌套消息类型</h2><p>可以使用其他消息类型作为字段类型，也可以在其他消息类型中定义和使用消息类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br>option go_package = <span class="hljs-string">&quot;server/nested&quot;</span>;<br><span class="hljs-comment">// 学员信息</span><br>message UserInfo &#123;<br>  <span class="hljs-type">int32</span> userId = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">string</span> userName = <span class="hljs-number">2</span>;<br>&#125;<br>message Common &#123;<br>  <span class="hljs-comment">// 班级信息</span><br>  message CLassInfo&#123;<br>    <span class="hljs-type">int32</span> classId = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">string</span> className = <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 嵌套信息</span><br>message NestedDemoMsg &#123;<br>  <span class="hljs-comment">// 学员信息 (直接使用消息类型)</span><br>  UserInfo userInfo = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 班级信息 (通过Parent.Type，调某个消息类型的子类型)</span><br>  Common.CLassInfo classInfo =<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8、map类型消息"><a href="#8、map类型消息" class="headerlink" title="8、map类型消息"></a>8、map类型消息</h2><p>创建关联映射作为数据定义的一部分，map数据结构格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">map</span>&lt;key_type, value_type&gt; map_field = N;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>key_type只能是任何整数或字符串类型(除浮点类型和任何标量bytes类型)。</li><li>enum 不能作为key_type和value_type定义的类型。</li><li>map字段不能是repeated。</li></ul></blockquote><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//protobuf源码</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br>option go_package = <span class="hljs-string">&quot;server/demo&quot;</span>;<br><br><span class="hljs-comment">// map消息</span><br>message DemoMapMsg &#123;<br>  <span class="hljs-type">int32</span> userId = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">map</span>&lt;<span class="hljs-type">string</span>,<span class="hljs-type">string</span>&gt; like =<span class="hljs-number">2</span>;<br>&#125;<br><br><br><span class="hljs-comment">//生成Go代码</span><br><span class="hljs-keyword">type</span> DemoMapMsg <span class="hljs-keyword">struct</span> &#123;<br> state         protoimpl.MessageState<br> sizeCache     protoimpl.SizeCache<br> unknownFields protoimpl.UnknownFields<br><br> UserId <span class="hljs-type">int32</span>             <span class="hljs-string">`protobuf:&quot;varint,1,opt,name=userId,proto3&quot; json:&quot;userId,omitempty&quot;`</span><br> Like   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span> <span class="hljs-string">`protobuf:&quot;bytes,2,rep,name=like,proto3&quot; json:&quot;like,omitempty&quot; protobuf_key:&quot;bytes,1,opt,name=key,proto3&quot; protobuf_val:&quot;bytes,2,opt,name=value,proto3&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>向后兼容性</strong><br>map 语法等效于以下内容，因此不支持 map 的Protobuf实现仍然可以处理你的数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">message MapFieldEntry &#123;<br>  key_type key = <span class="hljs-number">1</span>;<br>  value_type value = <span class="hljs-number">2</span>;<br>&#125;<br><br>repeated MapFieldEntry map_field = N;<br></code></pre></td></tr></table></figure><p>任何支持映射的Protobuf实现都必须生成和接受上述定义可以接受的数据。</p><h2 id="9、切片-数组-字段类型"><a href="#9、切片-数组-字段类型" class="headerlink" title="9、切片(数组)字段类型"></a>9、切片(数组)字段类型</h2><p>需要创建切片(数组)字段类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//protobuf源码</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br>option go_package = <span class="hljs-string">&quot;server/demo&quot;</span>;<br><br><span class="hljs-comment">// repeated允许字段重复，对于Go语言来说，它会编译成数组(slice of type)类型的格式</span><br>message DemoSliceMsg &#123;<br>  <span class="hljs-comment">// 会生成 []int32</span><br>  repeated <span class="hljs-type">int32</span> id = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 会生成 []string</span><br>  repeated <span class="hljs-type">string</span> name = <span class="hljs-number">2</span>;<br>  <span class="hljs-comment">// 会生成 []float32</span><br>  repeated float price = <span class="hljs-number">3</span>;<br>  <span class="hljs-comment">// 会生成 []float64</span><br>  repeated double money = <span class="hljs-number">4</span>;<br>&#125;<br><br><br><span class="hljs-comment">//生成Go代码</span><br><span class="hljs-comment">// repeated允许字段重复，对于Go语言来说，它会编译成数组(slice of type)类型的格式</span><br><span class="hljs-keyword">type</span> DemoSliceMsg <span class="hljs-keyword">struct</span> &#123;<br> state         protoimpl.MessageState<br> sizeCache     protoimpl.SizeCache<br> unknownFields protoimpl.UnknownFields<br><br> <span class="hljs-comment">// 会生成 []int32</span><br> Id []<span class="hljs-type">int32</span> <span class="hljs-string">`protobuf:&quot;varint,1,rep,packed,name=id,proto3&quot; json:&quot;id,omitempty&quot;`</span><br> <span class="hljs-comment">// 会生成 []string</span><br> Name []<span class="hljs-type">string</span> <span class="hljs-string">`protobuf:&quot;bytes,2,rep,name=name,proto3&quot; json:&quot;name,omitempty&quot;`</span><br> <span class="hljs-comment">// 会生成 []float32</span><br> Price []<span class="hljs-type">float32</span> <span class="hljs-string">`protobuf:&quot;fixed32,3,rep,packed,name=price,proto3&quot; json:&quot;price,omitempty&quot;`</span><br> Money []<span class="hljs-type">float64</span> <span class="hljs-string">`protobuf:&quot;fixed64,4,rep,packed,name=money,proto3&quot; json:&quot;money,omitempty&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10、oneof-只能选择一个"><a href="#10、oneof-只能选择一个" class="headerlink" title="10、oneof(只能选择一个)"></a>10、oneof(只能选择一个)</h2><p>如果需要一条包含多个字段的消息，并且最多同时设置一个字段，可以强制执行此行为并使用 oneof 功能节省内存。</p><p>oneof 字段与常规字段一样，在 oneof 共享内存中的所有字段，最多可以同时设置一个字段。设置 oneof 的任何成员会自动清除所有其他成员。</p><p>如果设置了多个值，则由 proto 中的 order 确定的最后一个设置的值将覆盖所有以前的设置值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">message SampleMessage &#123;<br>  oneof test_oneof &#123;<br>    <span class="hljs-type">string</span> name = <span class="hljs-number">4</span>;<br>    SubMessage sub_message = <span class="hljs-number">9</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在生成的代码中，oneof 字段具有与常规字段相同的 getter 和 setter。还可以获得一种特殊的方法来检查 oneof 中设置了哪个值（如果有）。</p><h2 id="11、Any-任何类型"><a href="#11、Any-任何类型" class="headerlink" title="11、Any 任何类型"></a>11、Any 任何类型</h2><p>Any消息类型允许您将消息作为嵌入类型使用，而不需要它们的.proto定义。</p><p>Any以字节的形式包含任意序列化的消息，以及作为该消息类型的全局唯一标识符并解析为该消息类型的URL。要使用Any类型，您需要 <code>import google/protobuf/any.proto</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/protobuf/any.proto&quot;</span>;<br><br>message ErrorStatus &#123;<br>  <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>  repeated google.protobuf.Any details = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h1><p>本章我们了解proto3的语法，下一章我会详细介绍gRPC以及如何加载 protoc-gen-go 插件达到生成 Go 代码的目的。</p>]]></content>
    
    
    <categories>
      
      <category>gRPC学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>微服务</tag>
      
      <tag>rpc</tag>
      
      <tag>protobuf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gRPC（一）入门：什么是RPC？</title>
    <link href="/2022/10/31/grpc-rpc/"/>
    <url>/2022/10/31/grpc-rpc/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文作为Grpc的开篇，通过文档先了解一下rpc。<br>示例代码已经上传到github：<a href="https://github.com/Gopherlinzy/go-grpc-example">点击跳转</a></p></blockquote><h1 id="一、RPC"><a href="#一、RPC" class="headerlink" title="一、RPC"></a>一、RPC</h1><h2 id="1、什么是RPC？"><a href="#1、什么是RPC？" class="headerlink" title="1、什么是RPC？"></a>1、什么是RPC？</h2><p><code>RPC（Remote Procedure Call 远程过程调用）</code>是一种软件通信协议，一个程序可以使用该协议向位于网络上另一台计算机中的程序请求服务，而无需了解网络的详细信息。RPC 用于调用远程系统上的其他进程，如本地系统。<code>过程调用有时也称为 函数调用或 子程序调用。</code></p><p>RPC是一种客户端-服务器交互形式（调用者是客户端，执行者是服务器），通常通过请求-响应消息传递系统实现。与本地过程调用一样，RPC 是一种 <code>同步</code> 操作，需要<code>阻塞</code>请求程序，直到返回远程过程的结果。但是，使用共享相同地址空间的轻量级进程或 线程 可以同时执行多个 RPC。</p><blockquote><p>通俗的解释：<br>客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。</p></blockquote><p>接口定义语言（IDL）——用于描述软件组件的应用程序编程接口（API）的规范语言——通常用于远程过程调用软件。在这种情况下，<code>IDL 在链路两端的机器之间提供了一座桥梁，这些机器可能使用不同的操作系统 (OS) 和计算机语言。</code></p><p>实际场景：</p><p>有两台服务器，分别是服务器 A、服务器 B。在 服务器 A 上的应用 想要调用服务器 B 上的应用，它们可以直接本地调用吗？</p><p>答案是不能的，但走 RPC 的话，十分方便。因此常有人称使用 RPC，就跟本地调用一个函数一样简单。</p><p><img src="/img/grpc_rpc/grpc1.png"></p><h2 id="2、HTTP和RPC的区别"><a href="#2、HTTP和RPC的区别" class="headerlink" title="2、HTTP和RPC的区别"></a>2、HTTP和RPC的区别</h2><h3 id="1）概念区别"><a href="#1）概念区别" class="headerlink" title="1）概念区别"></a>1）概念区别</h3><p>RPC是一种方法，而HTTP是一种协议。两者都常用于实现服务，在这个层面最本质的区别是RPC服务主要工作在TCP协议之上（也可以在HTTP协议），而HTTP服务工作在HTTP协议之上。由于HTTP协议基于TCP协议，所以RPC服务天然比HTTP更轻量，效率更胜一筹。</p><p>两者都是基于网络实现的，从这一点上，都是基于Client&#x2F;Server架构。</p><h3 id="2）从协议上区分"><a href="#2）从协议上区分" class="headerlink" title="2）从协议上区分"></a>2）从协议上区分</h3><p>RPC是远端过程调用，其调用协议通常包含：<code>传输协议</code> 和 <code>序列化协议</code>。</p><ul><li>传输协议：著名的 grpc，它底层使用的是 http2 协议；还有 dubbo 一类的自定义报文的 tcp 协议。</li><li>序列化协议：基于文本编码的 json 协议；也有二进制编码的 protobuf、hession 等协议；还有针对 java 高性能、高吞吐量的 kryo 和 ftc 等序列化协议。</li></ul><p>HTTP服务工作在HTTP协议之上，而且HTTP协议基于TCP协议。</p><h2 id="3、RPC如何工作的？"><a href="#3、RPC如何工作的？" class="headerlink" title="3、RPC如何工作的？"></a>3、RPC如何工作的？</h2><p>当调用 RPC 时，调用环境被挂起，过程参数通过网络传送到过程执行的环境，然后在该环境中执行过程。</p><p>当过程完成时，结果将被传送回调用环境，在那里继续执行，就像从常规过程调用返回一样。</p><p>在 RPC 期间，将执行以下步骤：</p><ol><li>客户端调用客户端存根。该调用是本地过程调用，参数以正常方式压入堆栈。</li><li>客户端存根将过程参数打包到消息中并进行系统调用以发送消息。过程参数的打包称为<code>编组</code>。</li><li>客户端的本地操作系统将消息从客户端机器发送到远程服务器机器。</li><li>服务器操作系统将传入的数据包传递给服务器存根。</li><li>服务器存根从消息中解包参数——称为<code>解编组</code>。</li><li>当服务器过程完成时，它返回到服务器存根，它将返回值编组为一条消息。然后服务器 存根将消息交给传输层。</li><li>传输层将生成的消息发送回客户端传输层，传输层将消息返回给客户端存根。</li><li>客户端存根解组返回参数，然后执行返回给调用者。</li></ol><blockquote><p> Client （客户端）：服务调用方。<br>Server（服务端）：服务提供方。<br>Client Stub（客户端存根）：存放服务端的地址消息，负责将客户端的请求参数打包成网络消息，然后通过网络发送给服务提供方。<br>Server Stub（服务端存根）：接收客户端发送的消息，再将客户端请求参数打包成网络消息，然后通过网络远程发送给服务方。</p></blockquote><p><img src="/img/grpc_rpc/grpc2.png"></p><h2 id="4、RPC的优缺点"><a href="#4、RPC的优缺点" class="headerlink" title="4、RPC的优缺点"></a>4、RPC的优缺点</h2><p>尽管它拥有广泛的好处，但使用 RPC 的人肯定应该注意一些陷阱。</p><p> RPC 为开发人员和应用程序管理人员提供的一些优势：</p><ul><li>帮助客户端通过传统使用高级语言中的过程调用与服务器进行通信。</li><li>可以在分布式环境中使用，也可以在本地环境中使用。</li><li>支持面向进程和面向线程的模型。</li><li>对用户隐藏内部消息传递机制。</li><li>只需极少的努力即可重写和重新开发代码。</li><li>提供抽象，即网络通信的消息传递特性对用户隐藏。</li><li>省略许多协议层以提高性能。</li></ul><p>另一方面，RPC 的一些缺点包括：</p><ul><li>客户端和服务器各自的例程使用不同的执行环境，资源（如文件）的使用也更加复杂。因此，RPC 系统并不总是适合传输大量数据。</li><li>RPC 极易发生故障，因为它涉及一个通信系统、另一台机器和另一个进程。</li><li>RPC没有统一的标准；它可以通过多种方式实现。</li><li>RPC 只是基于交互的，因此它在硬件架构方面没有提供任何灵活性。</li></ul><h2 id="5、常见的RPC框架"><a href="#5、常见的RPC框架" class="headerlink" title="5、常见的RPC框架"></a>5、常见的RPC框架</h2><h3 id="1）跟语言绑定框架"><a href="#1）跟语言绑定框架" class="headerlink" title="1）跟语言绑定框架"></a>1）跟语言绑定框架</h3><ul><li>Dubbo：国内最早开源的 RPC 框架，由阿里巴巴公司开发并于 2011 年末对外开源，仅支持 Java 语言。</li><li>Motan：微博内部使用的 RPC 框架，于 2016 年对外开源，仅支持 Java 语言。</li><li>Tars：腾讯内部使用的 RPC 框架，于 2017 年对外开源，仅支持 C++ 语言。</li><li>Spring Cloud：国外 Pivotal 公司 2014 年对外开源的 RPC 框架，仅支持 Java 语言。</li></ul><h3 id="2）跨语言开源框架"><a href="#2）跨语言开源框架" class="headerlink" title="2）跨语言开源框架"></a>2）跨语言开源框架</h3><ul><li>gRPC：Google 于 2015 年对外开源的跨语言 RPC 框架，支持多种语言。</li><li>Thrift：最初是由Facebook 开发的内部系统跨语言的 RPC 框架，2007 年贡献给了 Apache 基金，成为 Apache 开源项目之一，支持多种语言。</li><li>Rpcx：是一个类似阿里巴巴 Dubbo和微博 Motan的 RPC 框架，开源，支持多种语言。</li></ul><h1 id="二、RPC快速入门"><a href="#二、RPC快速入门" class="headerlink" title="二、RPC快速入门"></a>二、RPC快速入门</h1><p>Go语言标准包(<code>net/rpc</code>)已经提供了对RPC的支持，而且支持三个级别的RPC：<code>TCP、HTTP和JSONRPC</code>。但Go语言的RPC包是独一无二的RPC，它和传统的RPC系统不同，它只支持Go语言开发的服务器与客户端之间的交互，因为在内部，它们采用了<code>Gob</code>来编码。</p><h2 id="1、简单的RPC示例"><a href="#1、简单的RPC示例" class="headerlink" title="1、简单的RPC示例"></a>1、简单的RPC示例</h2><h3 id="1）服务端实现"><a href="#1）服务端实现" class="headerlink" title="1）服务端实现"></a>1）服务端实现</h3><p> 我们先构造一个 HelloService 类型，其中的 SayHi方法用于实现打印功能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> HelloService <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HelloService)</span></span> SayHi(request <span class="hljs-type">string</span>, response *<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>format := time.Now().Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>)<br>*response = <span class="hljs-string">&quot;hi &quot;</span> + request + <span class="hljs-string">&quot;---&quot;</span> + format<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> Go 语言的 RPC 规则：方法只能有两个可序列化的参数，其中第二个参数是指针类型，并且返回一个 error 类型，同时必须是公开的方法。</p></blockquote><p>将 HelloService 类型的对象注册为一个 RPC 服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//注册服务</span><br>_ = rpc.RegisterName(<span class="hljs-string">&quot;HiLinzy&quot;</span>, <span class="hljs-built_in">new</span>(HelloService))<br><span class="hljs-comment">//监听接口</span><br>lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">//监听请求</span><br>accept, err := lis.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Accept Error: %s&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">//用goroutine为每个TCP连接提供RPC服务</span><br><span class="hljs-keyword">go</span> rpc.ServeConn(accept)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>RegisterName类似于Register，但使用提供的名称作为类型，<code>Register</code> 函数调用会将对象类型中所有满足 RPC 规则的对象方法注册为 RPC 函数，所有注册的方法会放在 “HelloService” 服务空间之下。<br>rpc.ServeConn 函数在该 TCP 连接上为对方提供 RPC 服务。<br>我们的服务支持多个 TCP 连接，然后为每个 TCP 连接提供 RPC 服务。</p></blockquote><h3 id="2）客户端实现"><a href="#2）客户端实现" class="headerlink" title="2）客户端实现"></a>2）客户端实现</h3><p>在客户端请求 HelloService 服务的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//建立连接</span><br>dial, err := rpc.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:8888&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(<span class="hljs-string">&quot;Dial error &quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">var</span> result <span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-comment">//发起请求</span><br>_ = dial.Call(<span class="hljs-string">&quot;HiLinzy.SayHi&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>, &amp;result)<br>fmt.Println(<span class="hljs-string">&quot;rpc service result:&quot;</span>, result)<br>time.Sleep(time.Second)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>rpc.Dial 拨号 RPC 服务，然后通过 dial.Call 调用具体的 RPC 方法。<br>在调用 dial.Call 时，第一个参数是用点号连接的 RPC 服务名字和方法名字，第二和第三个参数分别我们定义 RPC 方法的两个参数，第一个是客服端传递的消息，第二个是由服务端产生返回的结果。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"># 启动服务<br>➜ <span class="hljs-keyword">go</span> run  server.<span class="hljs-keyword">go</span><br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">54096</span><br><br># 启动客户端<br>➜ <span class="hljs-keyword">go</span> run  client.<span class="hljs-keyword">go</span><br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">54100</span><br>rpc service result: hi linzy--<span class="hljs-number">-2022</span><span class="hljs-number">-10</span><span class="hljs-number">-30</span> <span class="hljs-number">15</span>:<span class="hljs-number">52</span>:<span class="hljs-number">39</span><br>rpc service result: hi linzy--<span class="hljs-number">-2022</span><span class="hljs-number">-10</span><span class="hljs-number">-30</span> <span class="hljs-number">15</span>:<span class="hljs-number">52</span>:<span class="hljs-number">40</span><br>rpc service result: hi linzy--<span class="hljs-number">-2022</span><span class="hljs-number">-10</span><span class="hljs-number">-30</span> <span class="hljs-number">15</span>:<span class="hljs-number">52</span>:<span class="hljs-number">41</span><br>rpc service result: hi linzy--<span class="hljs-number">-2022</span><span class="hljs-number">-10</span><span class="hljs-number">-30</span> <span class="hljs-number">15</span>:<span class="hljs-number">52</span>:<span class="hljs-number">42</span><br>rpc service result: hi linzy--<span class="hljs-number">-2022</span><span class="hljs-number">-10</span><span class="hljs-number">-30</span> <span class="hljs-number">15</span>:<span class="hljs-number">52</span>:<span class="hljs-number">43</span><br></code></pre></td></tr></table></figure><h2 id="2、更安全的RPC接口"><a href="#2、更安全的RPC接口" class="headerlink" title="2、更安全的RPC接口"></a>2、更安全的RPC接口</h2><p>在涉及 RPC 的应用中，作为开发人员一般至少有三种角色：首先是服务端实现 RPC 方法的开发人员，其次是客户端调用 RPC 方法的人员，最后也是最重要的是制定服务端和客户端 RPC 接口规范的设计人员。在前面的例子中我们为了简化将以上几种角色的工作全部放到了一起，虽然看似实现简单，但是不利于后期的维护和工作的切割。</p><h3 id="1）服务端重构"><a href="#1）服务端重构" class="headerlink" title="1）服务端重构"></a>1）服务端重构</h3><p>如果要重构 HelloService 服务，第一步需要明确服务的名字和接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> HelloServiceName = <span class="hljs-string">&quot;server/tcp-server/server.HiLinzy&quot;</span><br><br><span class="hljs-keyword">type</span> HelloServiceInterface <span class="hljs-keyword">interface</span> &#123;<br>SayHi(request <span class="hljs-type">string</span>, response *<span class="hljs-type">string</span>) <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-comment">//封装Register</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterHelloService</span><span class="hljs-params">(svc HelloServiceInterface)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> rpc.RegisterName(HelloServiceName, svc)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>我们将 RPC 服务的接口规范分为三个部分：首先是服务的名字，然后是服务要实现的详细方法列表，最后是注册该类型服务的函数。<br>为了避免名字冲突，我们在 RPC 服务的名字中增加了包路径前缀（这个是 RPC 服务抽象的包路径，并非完全等价 Go 语言的包路径）。<br>RegisterHelloService 注册服务时，编译器会要求传入的对象满足 HelloServiceInterface 接口。</p></blockquote><p>基于 RPC 接口规范编写真实的服务端代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> HelloService <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HelloService)</span></span> SayHi(request <span class="hljs-type">string</span>, response *<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>format := time.Now().Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>)<br>*response = <span class="hljs-string">&quot;hi &quot;</span> + request + <span class="hljs-string">&quot;---&quot;</span> + format<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//注册服务</span><br><span class="hljs-comment">//_ = rpc.RegisterName(&quot;HiLinzy&quot;, new(HelloService))</span><br>RegisterHelloService(<span class="hljs-built_in">new</span>(HelloService))<br><span class="hljs-comment">//监听接口</span><br>lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:8888&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">//监听请求</span><br>accept, err := lis.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Accept Error: %s&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">go</span> rpc.ServeConn(accept)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）客户端重构"><a href="#2）客户端重构" class="headerlink" title="2）客户端重构"></a>2）客户端重构</h3><p>为了简化客户端用户调用 RPC 函数，我们在可以在接口规范部分增加对客户端的简单包装：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> HelloServiceName = <span class="hljs-string">&quot;server/tcp-server/server.HiLinzy&quot;</span><br><br><span class="hljs-keyword">type</span> HelloServiceClient <span class="hljs-keyword">struct</span> &#123;<br>*rpc.Client<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DialHelloService</span><span class="hljs-params">(network, address <span class="hljs-type">string</span>)</span></span> (*HelloServiceClient, <span class="hljs-type">error</span>) &#123;<br>c, err := rpc.Dial(network, address)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> &amp;HelloServiceClient&#123;Client: c&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HelloServiceClient)</span></span> SayHi(request <span class="hljs-type">string</span>, response *<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">//client.Call 的第一个参数用 HelloServiceName+&quot;.SayHi&quot; 代替了 &quot;HiLinzy.SayHi&quot;。</span><br><span class="hljs-keyword">return</span> h.Client.Call(HelloServiceName+<span class="hljs-string">&quot;.SayHi&quot;</span>, request, &amp;response)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>提供了一个 DialHelloService 方法，直接拨号 HelloService 服务。</p></blockquote><p>基于新的客户端接口，我们可以简化客户端用户的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//建立连接</span><br><span class="hljs-comment">//dial, err := rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:8888&quot;)</span><br>client, err := DialHelloService(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:8888&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(<span class="hljs-string">&quot;dialing:&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">var</span> result <span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-comment">//发起请求</span><br><span class="hljs-comment">//_ = dial.Call(&quot;HiLinzy.SayHi&quot;, &quot;linzy&quot;, &amp;result)</span><br>err = client.SayHi(<span class="hljs-string">&quot;linzy&quot;</span>, &amp;result)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;rpc service result:&quot;</span>, result)<br>time.Sleep(time.Second)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>现在客户端用户不用再担心 RPC 方法名字或参数类型不匹配等低级错误的发生。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"># 启动服务<br>➜ <span class="hljs-keyword">go</span> run  server.<span class="hljs-keyword">go</span><br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">56990</span><br><br># 启动客户端<br>➜ <span class="hljs-keyword">go</span> run  client.<span class="hljs-keyword">go</span><br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">57188</span><br>rpc service result: hi linzy--<span class="hljs-number">-2022</span><span class="hljs-number">-10</span><span class="hljs-number">-30</span> <span class="hljs-number">16</span>:<span class="hljs-number">55</span>:<span class="hljs-number">12</span><br>rpc service result: hi linzy--<span class="hljs-number">-2022</span><span class="hljs-number">-10</span><span class="hljs-number">-30</span> <span class="hljs-number">16</span>:<span class="hljs-number">55</span>:<span class="hljs-number">13</span><br>rpc service result: hi linzy--<span class="hljs-number">-2022</span><span class="hljs-number">-10</span><span class="hljs-number">-30</span> <span class="hljs-number">16</span>:<span class="hljs-number">55</span>:<span class="hljs-number">14</span><br>rpc service result: hi linzy--<span class="hljs-number">-2022</span><span class="hljs-number">-10</span><span class="hljs-number">-30</span> <span class="hljs-number">16</span>:<span class="hljs-number">55</span>:<span class="hljs-number">15</span><br>rpc service result: hi linzy--<span class="hljs-number">-2022</span><span class="hljs-number">-10</span><span class="hljs-number">-30</span> <span class="hljs-number">16</span>:<span class="hljs-number">55</span>:<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><blockquote><p>在新的 RPC 服务端实现中，我们用 RegisterHelloService 函数来注册函数，这样不仅可以避免命名服务名称的工作，同时也保证了传入的服务对象满足了 RPC 接口的定义。</p></blockquote><h2 id="3、跨语言的-RPC"><a href="#3、跨语言的-RPC" class="headerlink" title="3、跨语言的 RPC"></a>3、跨语言的 RPC</h2><p>标准库的RPC默认采用 Go 语言特有的 gob 编码，因此从其他语言调用 Go 语言实现的 RPC 服务将比较困难。在互联网的微服务时代，每个 RPC 以及服务的使用者都可能采用不同的编程语言，因此跨语言是互联网时代 RPC 的一个首要条件。得益于 RPC 的框架设计，Go 语言的 RPC 其实也是很容易实现跨语言支持的。</p><p>Go 语言的 RPC 框架有两个比较有特色的设计：</p><ul><li>RPC 数据打包时可以通过插件实现自定义的编码和解码。</li><li>RPC 建立在抽象的 io.ReadWriterCloser 接口之上的，我们可以将 RPC 架设在不同的通信协议之上。</li></ul><p>这里我们使用Go官方自带的 <code>net/rpc/jsonrpc</code> 扩展实现一个跨语言的rpc。</p><h3 id="1）服务端实现-1"><a href="#1）服务端实现-1" class="headerlink" title="1）服务端实现"></a>1）服务端实现</h3><p>首先是基于 json 编码重新实现 RPC 服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//注册服务</span><br><span class="hljs-comment">//_ = rpc.RegisterName(&quot;HiLinzy&quot;, new(HelloService))</span><br>RegisterHelloService(<span class="hljs-built_in">new</span>(HelloService))<br><span class="hljs-comment">//监听接口</span><br>lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:8888&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">//监听请求</span><br>accept, err := lis.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Accept Error: %s&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">//go rpc.ServeConn(accept)</span><br><span class="hljs-keyword">go</span> rpc.ServeCodec(jsonrpc.NewServerCodec(accept))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码中最大的变化是用 rpc.ServeCodec 函数替代了 rpc.ServeConn 函数，传入的参数是针对服务端的 json 编解码器。</p></blockquote><h3 id="2）客户端实现-1"><a href="#2）客户端实现-1" class="headerlink" title="2）客户端实现"></a>2）客户端实现</h3><p>实现 json 版本的客户端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//建立TCP连接</span><br>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:8888&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(<span class="hljs-string">&quot;net.Dial:&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">//建立针对客户端的json编解码器</span><br>client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))<br><br><span class="hljs-keyword">var</span> result <span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-comment">//发起请求</span><br><span class="hljs-comment">//err = client.SayHi(&quot;linzy&quot;, &amp;result)</span><br>client.Call(HelloServiceName+<span class="hljs-string">&quot;.SayHi&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>, &amp;result)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;rpc service result:&quot;</span>, result)<br>time.Sleep(time.Second)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"># 启动服务<br>➜ <span class="hljs-keyword">go</span> run  server.<span class="hljs-keyword">go</span><br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">59409</span><br><br># 启动客户端<br>➜ <span class="hljs-keyword">go</span> run  client.<span class="hljs-keyword">go</span><br>API server listening at: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">59514</span><br>rpc service result: hi linzy--<span class="hljs-number">-2022</span><span class="hljs-number">-10</span><span class="hljs-number">-30</span> <span class="hljs-number">19</span>:<span class="hljs-number">09</span>:<span class="hljs-number">52</span><br>rpc service result: hi linzy--<span class="hljs-number">-2022</span><span class="hljs-number">-10</span><span class="hljs-number">-30</span> <span class="hljs-number">19</span>:<span class="hljs-number">09</span>:<span class="hljs-number">53</span><br>rpc service result: hi linzy--<span class="hljs-number">-2022</span><span class="hljs-number">-10</span><span class="hljs-number">-30</span> <span class="hljs-number">19</span>:<span class="hljs-number">09</span>:<span class="hljs-number">54</span><br>rpc service result: hi linzy--<span class="hljs-number">-2022</span><span class="hljs-number">-10</span><span class="hljs-number">-30</span> <span class="hljs-number">19</span>:<span class="hljs-number">09</span>:<span class="hljs-number">55</span><br>rpc service result: hi linzy--<span class="hljs-number">-2022</span><span class="hljs-number">-10</span><span class="hljs-number">-30</span> <span class="hljs-number">19</span>:<span class="hljs-number">09</span>:<span class="hljs-number">56</span><br></code></pre></td></tr></table></figure><blockquote><p>我们先手工调用 net.Dial 函数建立 TCP 连接，然后基于该连接建立针对客户端的 json 编解码器。<br>在确保客户端可以正常调用 RPC 服务的方法之后，我们用一个普通的 TCP 服务代替 Go 语言版本的 RPC 服务，这样可以查看客户端调用时发送的数据格式。</p></blockquote><h3 id="3）分析数据格式"><a href="#3）分析数据格式" class="headerlink" title="3）分析数据格式"></a>3）分析数据格式</h3><p>我们用Wireshark抓个包看看我们直接传递的数据格式：<br><img src="/img/grpc_rpc/grpc3.png"><br>这是一个 json 编码的数据，其中 method 部分对应要调用的 rpc 服务和方法组合成的名字，params 部分的第一个元素为参数，id 是由调用端维护的一个唯一的调用编号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">&#123;<span class="hljs-string">&quot;method&quot;</span>:<span class="hljs-string">&quot;server/tcp-server/server.HiLinzy.SayHi&quot;</span>,<span class="hljs-string">&quot;params&quot;</span>:[<span class="hljs-string">&quot;linzy&quot;</span>],<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><p>请求的 json 数据对象在内部对应两个结构体：客户端是 clientRequest，服务端是 serverRequest。clientRequest 和 serverRequest 结构体的内容基本是一致的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> clientRequest <span class="hljs-keyword">struct</span> &#123;<br>    Method <span class="hljs-type">string</span>         <span class="hljs-string">`json:&quot;method&quot;`</span><br>    Params [<span class="hljs-number">1</span>]<span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-string">`json:&quot;params&quot;`</span><br>    Id     <span class="hljs-type">uint64</span>         <span class="hljs-string">`json:&quot;id&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> serverRequest <span class="hljs-keyword">struct</span> &#123;<br>    Method <span class="hljs-type">string</span>           <span class="hljs-string">`json:&quot;method&quot;`</span><br>    Params *json.RawMessage <span class="hljs-string">`json:&quot;params&quot;`</span><br>    Id     *json.RawMessage <span class="hljs-string">`json:&quot;id&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来查看服务端响应的结果的数据结构：<br><img src="/img/grpc_rpc/grpc4.png"><br>返回的结果也是一个 json 格式的数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;result&quot;</span>:<span class="hljs-string">&quot;hilinzy---2022-10-30 19:09:52&quot;</span>,<span class="hljs-string">&quot;error&quot;</span>:null&#125;.<br></code></pre></td></tr></table></figure><p>其中 id 对应输入的 id 参数，result 为返回的结果，error 部分在出问题时表示错误信息。对于顺序调用来说，id 不是必须的。但是 Go 语言的 RPC 框架支持<code>异步调用</code>，当返回结果的顺序和调用的顺序不一致时，可以通过 id 来识别对应的调用。</p><p>返回的 json 数据也是对应内部的两个结构体：客户端是 clientResponse，服务端是 serverResponse。两个结构体的内容同样也是类似的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> clientResponse <span class="hljs-keyword">struct</span> &#123;<br>    Id     <span class="hljs-type">uint64</span>           <span class="hljs-string">`json:&quot;id&quot;`</span><br>    Result *json.RawMessage <span class="hljs-string">`json:&quot;result&quot;`</span><br>    Error  <span class="hljs-keyword">interface</span>&#123;&#125;      <span class="hljs-string">`json:&quot;error&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> serverResponse <span class="hljs-keyword">struct</span> &#123;<br>    Id     *json.RawMessage <span class="hljs-string">`json:&quot;id&quot;`</span><br>    Result <span class="hljs-keyword">interface</span>&#123;&#125;      <span class="hljs-string">`json:&quot;result&quot;`</span><br>    Error  <span class="hljs-keyword">interface</span>&#123;&#125;      <span class="hljs-string">`json:&quot;error&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因此无论采用何种语言，只要遵循同样的 json 结构，以同样的流程就可以和 Go 语言编写的 RPC 服务进行通信。这样我们就实现了跨语言的 RPC。</p><h2 id="4、HTTP-上的-RPC"><a href="#4、HTTP-上的-RPC" class="headerlink" title="4、HTTP 上的 RPC"></a>4、HTTP 上的 RPC</h2><p>Go 语言内在的 RPC 框架已经支持在 HTTP 协议上提供 RPC 服务。但是框架的 HTTP 服务同样采用了内置的 gob 协议，并且没有提供采用其它协议的接口，因此<code>从其它语言依然无法访问的</code>。</p><p>在前面的例子中，我们已经实现了在 TCP 协议之上运行 jsonrpc 服务，并且通过Wireshark抓包分析传递的数据 json 数据格式。现在我们尝试在 http 协议上提供 jsonrpc 服务。</p><p>新的 RPC 服务其实是一个类似 REST 规范的接口，接收请求并采用相应处理流程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> HelloServiceName = <span class="hljs-string">&quot;server/tcp-server/server.HiLinzy&quot;</span><br><br><span class="hljs-keyword">type</span> HelloService <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HelloService)</span></span> SayHi(request <span class="hljs-type">string</span>, response *<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>format := time.Now().Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>)<br>*response = <span class="hljs-string">&quot;hi &quot;</span> + request + <span class="hljs-string">&quot;---&quot;</span> + format<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//注册服务</span><br>rpc.RegisterName(HelloServiceName, <span class="hljs-built_in">new</span>(HelloService))<br><br>http.HandleFunc(<span class="hljs-string">&quot;/jsonrpc&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-keyword">var</span> conn io.ReadWriteCloser = <span class="hljs-keyword">struct</span> &#123;<br>io.Writer<br>io.ReadCloser<br>&#125;&#123;<br>ReadCloser: r.Body,<br>Writer:     w,<br>&#125;<br><br>rpc.ServeRequest(jsonrpc.NewServerCodec(conn))<br>&#125;)<br><br>http.ListenAndServe(<span class="hljs-string">&quot;:8888&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>RPC 的服务架设在 “&#x2F;jsonrpc” 路径，在处理函数中基于 http.ResponseWriter 和 http.Request 类型的参数构造一个 io.ReadWriteCloser 类型的 conn 通道。<br>然后基于 conn 构建针对服务端的 json 编码解码器。最后通过 rpc.ServeRequest 函数为每次请求处理一次 RPC 方法调用。</p></blockquote><p>用Postman模拟RPC调用过程，向连接<code>localhost:8888/jsonrpc</code>发送一条 json 字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">&#123;<span class="hljs-string">&quot;method&quot;</span>:<span class="hljs-string">&quot;server/tcp-server/server.HiLinzy.SayHi&quot;</span>,<span class="hljs-string">&quot;params&quot;</span>:[<span class="hljs-string">&quot;linzy&quot;</span>],<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/grpc_rpc/grpc5.png"><br>这样我们就可用很方便的从不同的语言或者不同的方式来访问RPC服务了。</p><p>参考文章：<br><a href="https://www.techtarget.com/searchapparchitecture/definition/Remote-Procedure-Call-RPC">https://www.techtarget.com/searchapparchitecture/definition/Remote-Procedure-Call-RPC</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI5MDAzNTAxMQ==&mid=2455917150&idx=1&sn=8a8325b09e6e2a0e34bf86609967f28c&scene=19#wechat_redirect">https://mp.weixin.qq.com/s__biz&#x3D;MzI5MDAzNTAxMQ&#x3D;&#x3D;&amp;mid&#x3D;2455917150&amp;idx&#x3D;1&amp;sn&#x3D;8a8325b09e6e2a0e34bf86609967f28c&amp;scene&#x3D;19#wechat_redirect</a></p><p><a href="https://chai2010.cn/advanced-go-programming-book/ch4-rpc/ch4-01-rpc-intro.html">https://chai2010.cn/advanced-go-programming-book/ch4-rpc/ch4-01-rpc-intro.html</a></p>]]></content>
    
    
    <categories>
      
      <category>gRPC学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>微服务</tag>
      
      <tag>rpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go高性能编程-Go中的类型对齐保证</title>
    <link href="/2022/10/25/go-memory-layout/"/>
    <url>/2022/10/25/go-memory-layout/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文将介绍Go中的各种字段类型的字节数和对齐保证。</p></blockquote><h1 id="一、内存对齐"><a href="#一、内存对齐" class="headerlink" title="一、内存对齐"></a>一、内存对齐</h1><h2 id="1、什么是内存对齐？"><a href="#1、什么是内存对齐？" class="headerlink" title="1、什么是内存对齐？"></a>1、什么是内存对齐？</h2><p>元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。从结构体存储的首地址开始，每个元素放置到内存中时，它都会认为<code>内存是按照自己的大小（通常它为4字节(32位)或8字节(64位)）来划分的</code>，因此元素放置的位置一定会在自己宽度的整数倍上开始，这就是所谓的内存对齐。</p><h2 id="2、为什么需要内存对齐？"><a href="#2、为什么需要内存对齐？" class="headerlink" title="2、为什么需要内存对齐？"></a>2、为什么需要内存对齐？</h2><p>CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如 32 位的 CPU ，字长为 4 字节，那么 CPU 访问内存的单位也是 4 字节。64位 CPU 访问内存的单位是8个字节。</p><p>这么设计的目的，是减少 CPU 访问内存的次数，加大 CPU 访问内存的吞吐量。比如同样读取 8 个字节的数据，一次读取 4 个字节那么只需要读取 2 次。<code>CPU 始终以字长访问内存</code>。</p><p>提出设想如果我们不进行内存对齐，而是按照类型字节长度紧密对齐呢？</p><p>变量 a、b 各占据 3 字节的空间，我们使用32位 CPU 访问内存读取变量，例如：</p><p><img src="/img/go_memory_layout/go1.png"></p><ul><li>内存对齐后，a、b 占据 4 字节空间，CPU 读取 b 变量的值只需要进行一次内存访问。</li><li>不进行内存对齐，CPU 读取 b 变量的值需要进行 2 次内存访问。第一次访问得到 b 变量的第 1 个字节，第二次访问得到 b 变量的后两个字节，最后在寄存器中将剩余的数据合并得到我们想要变量 b 的数据。</li></ul><p>从这个例子中也可以看到，内存对齐对实现变量的原子性操作也是有好处的，每次内存访问是原子的，如果变量的大小不超过字长，那么内存对齐后，对该变量的访问就是原子的，这个特性在并发场景下至关重要。</p><p><code>简言之：合理的内存对齐可以提高内存读写的性能，并且便于实现变量操作的原子性。</code></p><blockquote><p>内存对齐是为了减少访问内存的次数，提高CPU读取内存数据的效率，如果内存不对齐，访问相同的数据需要更多的访问内存次数。</p></blockquote><h1 id="二、Go中的类型对齐保证"><a href="#二、Go中的类型对齐保证" class="headerlink" title="二、Go中的类型对齐保证"></a>二、Go中的类型对齐保证</h1><p>为了充分利用CPU指令来达到最佳程序性能，为一个特定类型的值开辟的内存块的起始地址必须为某个整数N的倍数，N被称为此类型的值地址对齐保证，或者简单地称为此类型的对齐保证。 我们也可以说此类型的值的地址保证为N字节对齐的。</p><h2 id="1、数据类型的大小和对齐保证"><a href="#1、数据类型的大小和对齐保证" class="headerlink" title="1、数据类型的大小和对齐保证"></a>1、数据类型的大小和对齐保证</h2><p>对于当前的标准 Go 编译器（版本 1.19），字段对齐保证和类型的一般对齐保证是相等的。</p><p>对于不同的类型，对应的对齐保证大小和占用的内存大小：</p><table><thead><tr><th align="left">类型</th><th>对齐保证（字节数）</th><th>占用的内存大小（字节数）</th></tr></thead><tbody><tr><td align="left">byte, uint8, int8</td><td>1</td><td>1</td></tr><tr><td align="left">uint16, int16</td><td>2</td><td>2</td></tr><tr><td align="left">uint32, int32, float32</td><td>4</td><td>4</td></tr><tr><td align="left">uint64, int64, float64, complex64</td><td>8</td><td>8</td></tr><tr><td align="left">complex128</td><td>16</td><td>16</td></tr><tr><td align="left">string</td><td>8</td><td>16</td></tr><tr><td align="left">array</td><td>取决于元素类型</td><td></td></tr><tr><td align="left">struct</td><td>取决于各个字段类型</td><td></td></tr><tr><td align="left">uint, int</td><td></td><td>取决于编译器实现。通常在32位架构上为4字节，在64位架构上为8字节。</td></tr><tr><td align="left">uintptr</td><td></td><td>取决于编译器实现。但必须能够存下任一个内存地址。</td></tr></tbody></table><p>Go白皮书仅列出了一些<a href="https://golang.google.cn/ref/spec#Numeric_types">类型对齐保证要求</a>，一个合格的Go编译器必须保证：</p><ol><li>对于任何类型的变量x，<code>unsafe.Alignof(x)</code>的结果最小为1。</li><li>对于一个结构体类型的变量x，<code>unsafe.Alignof(x)</code>的结果为x的所有字段的对齐保证unsafe.Alignof(x.f)中的最大值（但是最小为1）。</li><li>对于一个数组类型的变量x，<code>unsafe.Alignof(x)</code>的结果和此数组的元素类型的一个变量的对齐保证相等。</li></ol><blockquote><p>如果结构或数组类型不包含内存大小大于零的字段（或元素），则其大小为零。两个不同的零大小变量在内存中可能具有相同的地址。</p></blockquote><h2 id="2、Go实现内存对齐"><a href="#2、Go实现内存对齐" class="headerlink" title="2、Go实现内存对齐"></a>2、Go实现内存对齐</h2><p>Go的unsafe包中有三个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sizeof</span><span class="hljs-params">(x ArbitraryType)</span></span> <span class="hljs-type">uintptr</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Offsetof</span><span class="hljs-params">(x ArbitraryType)</span></span> <span class="hljs-type">uintptr</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Alignof</span><span class="hljs-params">(x ArbitraryType)</span></span> <span class="hljs-type">uintptr</span><br></code></pre></td></tr></table></figure><p><code>unsafe.Sizeof 返回变量x的占用字节数，但不包含它所指向内容的大小</code>，对于一个string类型的变量它的大小是16字节，一个指针类型的变量大小是8字节<br><code>unsafe.Alignof 返回变量x需要的对齐保证</code>，它可以被x地址整除。(一般取结构体数据类型对齐保证的最大值)<br><code>unsafe.Offsetof 返回结构体成员地址相对于结构体首地址相差的字节数，称为偏移量</code></p><p>在 Go 语言中，我们可以使用 unsafe.Sizeof 计算出一个数据类型实例需要占用的字节数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T1 <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">int8</span>  <span class="hljs-comment">//1字节</span><br>b <span class="hljs-type">int64</span> <span class="hljs-comment">//8字节</span><br>c <span class="hljs-type">int16</span> <span class="hljs-comment">//2字节</span><br>&#125;<br><br><span class="hljs-keyword">type</span> T2 <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">int8</span><br>c <span class="hljs-type">int16</span><br>b <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-keyword">type</span> T3 <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">int8</span>  <span class="hljs-comment">//1字节</span><br>b <span class="hljs-type">int32</span> <span class="hljs-comment">//4字节</span><br>c <span class="hljs-type">int16</span> <span class="hljs-comment">//2字节</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;T1结构体内存占用：&quot;</span>, unsafe.Sizeof(T1&#123;&#125;))<br>fmt.Println(<span class="hljs-string">&quot;T2结构体内存占用：&quot;</span>, unsafe.Sizeof(T2&#123;&#125;))<br><br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br>fmt.Printf(<span class="hljs-string">&quot;string类型的内存占用大小%v, 对齐保证%v\n&quot;</span>, unsafe.Sizeof(s), unsafe.Alignof(s))<br>fmt.Println(<span class="hljs-string">&quot;T1结构体对齐保证：&quot;</span>, unsafe.Alignof(T2&#123;&#125;))<br>fmt.Println(<span class="hljs-string">&quot;T2结构体对齐保证：&quot;</span>, unsafe.Alignof(T3&#123;&#125;))<br><br><span class="hljs-keyword">var</span> t1 T1<br><span class="hljs-keyword">var</span> t2 T2<br>fmt.Println(<span class="hljs-string">&quot;T1成员b地址相对于结构体首地址相差的字节数：&quot;</span>, unsafe.Offsetof(t1.b))<br>fmt.Println(<span class="hljs-string">&quot;T2成员c地址相对于结构体首地址相差的字节数：&quot;</span>, unsafe.Offsetof(t2.c))<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/img/go_memory_layout/go2.png"></p><h3 id="1）内存对齐规则"><a href="#1）内存对齐规则" class="headerlink" title="1）内存对齐规则"></a>1）内存对齐规则</h3><p><strong>内存对齐的规则，这里只介绍结构体的内存对齐：</strong></p><ul><li>规则一：结构体第一个字段偏移量为0，后面的字段的偏移量等于成员数据类型大小和字段对齐保证两者取最小值的最小整数倍，如果不满足规则，编译器会在前面填充值为0的字节空间</li><li>规则二：结构体本身也需要内存对齐，其大小等于各字段类型占用内存最大的和编译器默认对齐保证两者取最小值的最小整数倍</li></ul><h3 id="2）计算结构体内存占用大小"><a href="#2）计算结构体内存占用大小" class="headerlink" title="2）计算结构体内存占用大小"></a>2）计算结构体内存占用大小</h3><p>为什么这里明明结构体内字段类型和数量都是一样，但是内存大小却不一样？</p><h4 id="a、T1为什么是24字节？"><a href="#a、T1为什么是24字节？" class="headerlink" title="a、T1为什么是24字节？"></a>a、T1为什么是24字节？</h4><ul><li>a是int8类型占1字节，对齐保证是1字节。<ul><li>因为是第一个成员，偏移量为0，所有不需要填充，直接排在内存空间的第一位。</li></ul></li><li>b是int64类型占8字节，对齐保证是8字节。<ul><li>当前偏移量为2，根据规则一，其偏移量为两者中最小值，所以调整后的偏移量为8。</li><li>在64位架构上，为了让字段b的地址为8字节对齐，需在这里填充7个字节，从第9位开始占用8个字节空间。</li><li>在32位架构上，为了让字段b的地址为4字节对齐，需在这里填充3个字节，从第5位开始占用8个字节空间。</li></ul></li><li>c是int16类型占2字节，对齐保证2字节。<ul><li>当前偏移量为16，根据规则一，其偏移量为两者中最小值，所以调整后的偏移量为2。</li><li>在64位架构上需在这里填充6个字节，从第17位开始占用2个字节空间。</li><li>在32位架构上需在这里填充2个字节，从第13位开始占用2个字节空间。</li></ul></li></ul><p><img src="/img/go_memory_layout/go3.png"></p><p>第一条规则算下来结构体T1在64位架构上占用大小为 1+7+8+2&#x3D;18，在32位架构上占用大小为 1+3+8+2&#x3D;14</p><blockquote><p>我们再来根据第二条规则计算：<br>结构体最大字段内存大小为8字节，</p><ul><li>结构体T1的内存大小在64位架构上，取两者最小值8的最小整数倍，因本身结构体当前大小为18，所以最后结构体大小&#x3D;3*8&#x3D;24，为24个字节。</li><li>结构体T1的内存大小在32位架构上，取两者最小值4的最小整数倍，因本身结构体当前大小为14，所以最后结构体大小&#x3D;4*4&#x3D;16，为16个字节。</li></ul></blockquote><h4 id="b、T2为什么是16字节？"><a href="#b、T2为什么是16字节？" class="headerlink" title="b、T2为什么是16字节？"></a>b、T2为什么是16字节？</h4><ul><li>a是int8类型占1字节，对齐保证是1字节。<ul><li>因为是第一个成员，偏移量为0，所有不需要填充，直接排在内存空间的第一位。</li></ul></li><li>c是int16类型占2个字节，对齐保证2字节。<ul><li>当前偏移量为2，根据规则一，其偏移量为两者中最小值，所以调整后的偏移量为2。</li><li>为了让字段c的地址为2字节对齐，需在这里填充1个字节，从第3位开始占用2个字节空间。</li></ul></li><li>b是int64类型占8个字节，对齐保证是8字节。<ul><li>当前偏移量为4，根据规则一，其偏移量为两者中最小值，所以调整后的偏移量为8。</li><li>在64位架构上，为了让字段b的地址为8字节对齐，需在这里填充4个字节，从第9位开始占用8个字节空间。</li><li>在32位架构上，为了让字段b的地址为4字节对齐，不需要填充，从第5位开始占用8个字节空间。</li><li>字节可以保证字段b的地址为4字节对齐的。</li></ul></li></ul><p><img src="/img/go_memory_layout/go4.png"></p><p>第一条规则算下来<br>结构体T1在64位架构上占用大小为 1+1+2+4+8&#x3D;16<br>结构体T1在32位架构上占用大小为 1+1+2+8&#x3D;12</p><blockquote><p>我们再来根据第二条规则计算：<br>结构体最大字段内存大小为8字节，</p><ul><li>结构体T1的内存大小在64位架构上，取两者最小值8的最小整数倍，因本身结构体当前大小为16，所以最后结构体大小&#x3D;2*8&#x3D;16，为16个字节。</li><li>结构体T1的内存大小在32位架构上，取两者最小值4的最小整数倍，因本身结构体当前大小为12，所以最后结构体大小&#x3D;3*4&#x3D;12，为12个字节。</li></ul></blockquote><h3 id="3）struct-内存对齐的技巧"><a href="#3）struct-内存对齐的技巧" class="headerlink" title="3）struct 内存对齐的技巧"></a>3）struct 内存对齐的技巧</h3><p>我们通过上面两个结构体，因为字段数据类型顺序不一样，导致内存占用也不同。</p><p>每个字段按照自身的对齐倍数来确定在内存中的偏移量，字段排列顺序不同，上一个字段因偏移而浪费的大小也不同。</p><p><code>因此，在对内存特别敏感的结构体的设计上，我们可以通过调整字段的顺序，减少内存的占用。</code></p><h3 id="4）空-struct-的作用"><a href="#4）空-struct-的作用" class="headerlink" title="4）空 struct{} 的作用"></a>4）空 struct{} 的作用</h3><p>空 struct{} 大小为 0，作为其他 struct 的字段时，一般不需要内存对齐。但是有一种情况除外：<code>即当 struct&#123;&#125; 作为结构体最后一个字段时，需要内存对齐</code>。</p><p>因为如果有指针指向该字段, 返回的地址将在结构体之外，如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放）。</p><p>因此，当 struct{} 作为其他 struct 最后一个字段时，需要填充额外的内存保证安全。我们做个试验，验证下这种情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> demo1 <span class="hljs-keyword">struct</span> &#123;<br>c <span class="hljs-type">int32</span><br>a <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> demo2 <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-keyword">struct</span>&#123;&#125;<br>c <span class="hljs-type">int32</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(unsafe.Sizeof(demo1&#123;&#125;)) <span class="hljs-comment">// 8</span><br>fmt.Println(unsafe.Sizeof(demo2&#123;&#125;)) <span class="hljs-comment">// 4</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/go_memory_layout/go5.png"></p><blockquote><p>可以看到，demo2{} 的大小为 4 字节，与字段 c 占据空间一致，而 demo1{} 的大小为 8 字节，即额外填充了 4 字节的空间。</p></blockquote><h2 id="3、64位字原子操作的地址对齐保证要求"><a href="#3、64位字原子操作的地址对齐保证要求" class="headerlink" title="3、64位字原子操作的地址对齐保证要求"></a>3、64位字原子操作的地址对齐保证要求</h2><p>一个64位字的原子操作要求此64位字的地址必须是8字节对齐的。 这对于标准编译器目前支持的64位架构来说并不是一个问题，因为标准编译器保证任何一个64位字的地址在64位架构上都是8字节对齐的。</p><p>然而，在32位架构上，标准编译器为64位字做出的地址对齐保证仅为4个字节。 对一个不是8字节对齐的64位字进行64位原子操作将在运行时刻产生一个恐慌，需要分别读取两次合并。 更糟的是，一些非常老旧的架构并不支持64位原子操作需要的基本指令。</p><p><a href="https://golang.google.cn/pkg/sync/atomic/#pkg-note-BUG">sync&#x2F;atomic标准库包文档的末尾</a>提到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">On <span class="hljs-number">386</span>, the <span class="hljs-number">64</span>-bit functions use instructions unavailable before the Pentium MMX.<br><br>On non-Linux ARM, the <span class="hljs-number">64</span>-bit functions use instructions unavailable before the ARMv6k core.<br><br>On ARM, <span class="hljs-number">386</span>, and <span class="hljs-number">32</span>-bit MIPS, it is the caller<span class="hljs-string">&#x27;s responsibility to arrange for 64-bit alignment of 64-bit words </span><br><span class="hljs-string">accessed atomically via the primitive atomic functions (types Int64 and Uint64 are automatically aligned). The </span><br><span class="hljs-string">first word in an allocated struct, array, or slice; in a global variable; or in a local variable</span><br><span class="hljs-string">(because the subject of all atomic operations will escape to the heap) can be relied upon to be 64-bit aligned.</span><br></code></pre></td></tr></table></figure><p>所以大致意思意思：</p><ol><li>这些非常老旧的架构在今日已经相当的不主流了。 如果一个程序需要在这些架构上对64位字进行原子操作，还有很多其它同步技术可用。</li><li>对其它不是很老旧的32位架构，有一些方法可以保证在这些架构上对一些64位字的原子操作是安全的。</li></ol><p>这里的方法是<code>已分配结构、数组或切片中的第一个（64位）字(元素)可以被认为是8字节对齐的</code>。</p><p>这里的已分配解读为一个声明的变量、内置函数make的调用返回值，或者内置函数new的调用返回值所引用的值。如果一个切片是从一个已分配数组派生出来的并且此切片和此数组共享第一个元素，则我们也可以将此切片看作是一个已分配的值。</p><p>这里对哪些64位字可以在32位架构上被安全地原子访问的描述是有些保守的。 有很多描述并未包括的64位字在32位架构上也是可以被安全地原子访问的。</p><p> 比如，如果一个元素类型为64位字的数组或者切片的第一个元素可以被安全地进行64位原子访问，则此数组或切片中的所有元素都可以被安全地进行64位原子访问。 只是因为很难用三言两语将所有在32位架构上可以被安全地原子访问的64位字都罗列出来，所以官方文档采取了一种保守的描述。</p><p>下面是一个展示了哪些64位字在32位架构上可以和哪些不可以被安全地原子访问的例子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> (<br>T1 <span class="hljs-keyword">struct</span> &#123;<br>v <span class="hljs-type">uint64</span><br>&#125;<br><br>T2 <span class="hljs-keyword">struct</span> &#123;<br>_ <span class="hljs-type">int16</span><br>x T1<br>y *T1<br>&#125;<br><br>T3 <span class="hljs-keyword">struct</span> &#123;<br>_ <span class="hljs-type">int16</span><br>x [<span class="hljs-number">6</span>]<span class="hljs-type">int64</span><br>y *[<span class="hljs-number">6</span>]<span class="hljs-type">int64</span><br>&#125;<br>)<br><br><span class="hljs-keyword">var</span> a <span class="hljs-type">int64</span>    <span class="hljs-comment">// a可以安全地被原子访问</span><br><span class="hljs-keyword">var</span> b T1       <span class="hljs-comment">// b.v可以安全地被原子访问</span><br><span class="hljs-keyword">var</span> c [<span class="hljs-number">6</span>]<span class="hljs-type">int64</span> <span class="hljs-comment">// c[0]可以安全地被原子访问</span><br><br><span class="hljs-keyword">var</span> d T2 <span class="hljs-comment">// d.x.v不能被安全地被原子访问</span><br><span class="hljs-keyword">var</span> e T3 <span class="hljs-comment">// e.x[0]不能被安全地被原子访问</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> f <span class="hljs-type">int64</span>           <span class="hljs-comment">// f可以安全地被原子访问</span><br><span class="hljs-keyword">var</span> g = []<span class="hljs-type">int64</span>&#123;<span class="hljs-number">5</span>: <span class="hljs-number">0</span>&#125; <span class="hljs-comment">// g[0]可以安全地被原子访问</span><br><br><span class="hljs-keyword">var</span> h = e.x[:] <span class="hljs-comment">// h[0]可以安全地被原子访问</span><br><br><span class="hljs-comment">// 这里，d.y.v和e.y[0]都可以安全地被原子访问，</span><br><span class="hljs-comment">// 因为*d.y和*e.y都是开辟出来的。</span><br>d.y = <span class="hljs-built_in">new</span>(T1)<br>e.y = &amp;[<span class="hljs-number">6</span>]<span class="hljs-type">int64</span>&#123;&#125;<br><br>_, _, _ = f, g, h<br>&#125;<br><br><span class="hljs-comment">// 事实上，c、g和e.y.v的所有以元素都可以被安全地原子访问。</span><br><span class="hljs-comment">// 只不过官方文档没有明确地做出保证。</span><br></code></pre></td></tr></table></figure><p>如果一个结构体类型的某个64位字的字段（通常为第一个字段）在代码中需要被原子访问，为了保证此字段值在各种架构上都可以被原子访问，我们应该总是使用此结构体的开辟值。 当此结构体类型被用做另一个结构体类型的一个字段的类型时，此字段应该（尽量）被安排为另一个结构体类型的第一个字段，并且总是使用另一个结构体类型的开辟值。</p><p>如果一个结构体含有需要一个被原子访问的字段，并且我们希望此结构体可以自由地用做其它结构体的任何字段（可能非第一个字段）的类型，则我们可以用一个[15]byte值来模拟此64位值，并在运行时刻动态地决定此64位值的地址。 比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">struct</span> &#123;<br>x [<span class="hljs-number">15</span>]<span class="hljs-type">byte</span> <span class="hljs-comment">// 模拟：x uint64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counter)</span></span> xAddr() *<span class="hljs-type">uint64</span> &#123;<br><span class="hljs-comment">// 此返回结果总是8字节对齐的。</span><br><span class="hljs-keyword">return</span> (*<span class="hljs-type">uint64</span>)(unsafe.Pointer(<br>(<span class="hljs-type">uintptr</span>(unsafe.Pointer(&amp;c.x)) + <span class="hljs-number">7</span>)/<span class="hljs-number">8</span>*<span class="hljs-number">8</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counter)</span></span> Add(delta <span class="hljs-type">uint64</span>) &#123;<br>p := c.xAddr()<br>atomic.AddUint64(p, delta)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counter)</span></span> Value() <span class="hljs-type">uint64</span> &#123;<br><span class="hljs-keyword">return</span> atomic.LoadUint64(c.xAddr())<br>&#125;<br></code></pre></td></tr></table></figure><p>通过采用此方法，<code>Counter</code>类型可以自由地用做其它结构体的任何字段的类型，而无需担心此类型中维护的64位字段值可能不是8字节对齐的。 此方法的缺点是，对于每个Counter类型的值，都有7个字节浪费了。而且此方法使用了非类型安全指针。</p><p><code>Go 1.19</code>引入了一种更为优雅的方法来保证一些值的地址对齐保证为8字节。 Go 1.19在sync&#x2F;atomic标准库包中加入了几个原子类型。 这些类型包括atomic.Int64和atomic.Uint64。 这两个类型的值在内存中总是8字节对齐的，即使在32位架构上也是如此。 我们可以利用这个事实来确保一些64位字在32位架构上总是8字节对齐的。 比如，无论在32位架构还是64位架构上，下面的代码所示的T类型的x字段在任何情形下总是8字节对齐的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>_ [<span class="hljs-number">0</span>]atomic.Int64<br>x <span class="hljs-type">int64</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h1><p>这里主要是验证内存对齐规则对实际存储空间的影响,并验证了内存对齐的规则.平时工作中不需要关心值地址的对齐保证,编译器已经自动完成了相关的工作.除非打算优化下内存消耗.特别是定义结构体时,可以参照下上面的结论.</p><p>参考文章：<a href="https://gfw.go101.org/article/memory-layout.html">点击跳转</a></p>]]></content>
    
    
    <categories>
      
      <category>Go高性能编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>后端</tag>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gorm学习（五）进阶：多态关联、关联标签以及事务</title>
    <link href="/2022/10/11/gorm-transaction/"/>
    <url>/2022/10/11/gorm-transaction/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>感谢开源项目<a href="https://www.gin-vue-admin.com/">gin-vue-admin</a>，以及<a href="https://www.bilibili.com/video/BV12i4y1x7AG?spm_id_from=333.999.0.0">1010工作室的视频教程</a></p></blockquote><h1 id="一、多态关联"><a href="#一、多态关联" class="headerlink" title="一、多态关联"></a>一、多态关联</h1><h2 id="1、多态关联概述"><a href="#1、多态关联概述" class="headerlink" title="1、多态关联概述"></a>1、多态关联概述</h2><ul><li><p>什么是多态？</p><p>  多态的概念：通俗来说，就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。</p></li><li><p>什么是多态表？<br>  假设我们有一张地址表，其中的地址可能是来自User中的，也可能是来自Orders中的。而区分不同的对象则用type字段。如：type&#x3D;User时对象是文章表。</p></li></ul><p><img src="/img/gorm_transaction/gorm1.png"></p><ul><li>什么是多态关联？<br>  多态关联就是多态表和对象表之间的关联性。<code>一个多态关联由使用同一外键发生的两个(或多个)关联组成.</code></li></ul><h2 id="2、为什么用多态关联？"><a href="#2、为什么用多态关联？" class="headerlink" title="2、为什么用多态关联？"></a>2、为什么用多态关联？</h2><p>出现需要外键引用多个表的情况，不可能删除原来表结构，重新添加一个外键ID再建表，所以我们可以建立一个交叉表。让Addres不再依赖于User表或者Order表。<br><img src="/img/gorm_transaction/gorm2.png"><br><code>has one</code>的情况解决方案，如果我们希望一个给定的地址，只能够在一张交叉表中出现一次，上面的复合主键已经做到了。</p><p><code>has many</code>的情况解决方案,如果希望一个地址可以在一张交叉表中出现多次，可以取消Address的复合主键。</p><h2 id="3、Has-One"><a href="#3、Has-One" class="headerlink" title="3、Has One"></a>3、Has One</h2><p>GORM 为 <code>has one</code> 和 <code>has many</code> 提供了多态关联支持，它会将拥有者实体的表名、主键值都保存到多态类型的字段中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>ID      <span class="hljs-type">int</span><br>Name    <span class="hljs-type">string</span><br><span class="hljs-comment">//polymorphic指定多态类型，比如模型名</span><br>Address Address <span class="hljs-string">`gorm:&quot;polymorphic:Owner;&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Order <span class="hljs-keyword">struct</span> &#123;<br>ID      <span class="hljs-type">int</span><br>Name    <span class="hljs-type">string</span><br>Address Address <span class="hljs-string">`gorm:&quot;polymorphic:Owner;&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> &#123;<br>ID        <span class="hljs-type">int</span><br>Name      <span class="hljs-type">string</span><br>OwnerID   <span class="hljs-type">int</span><br>OwnerType <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db.AutoMigrate(&amp;User&#123;&#125;, &amp;Order&#123;&#125;, &amp;Address&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_transaction/gorm3.png"></p><ul><li>创建记录</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Create(&amp;User&#123;<br>Name: <span class="hljs-string">&quot;linzy&quot;</span>,<br>Address: Address&#123;<br>Name: <span class="hljs-string">&quot;翻斗花园&quot;</span>,<br>&#125;,<br>&#125;)<br>db.Create(&amp;Order&#123;<br>Name: <span class="hljs-string">&quot;忘崽牛奶&quot;</span>,<br>Address: Address&#123;<br>Name: <span class="hljs-string">&quot;火星幼儿园&quot;</span>,<br>&#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_transaction/gorm4.png"><br><img src="/img/gorm_transaction/gorm5.png"><br><img src="/img/gorm_transaction/gorm6.png"></p><blockquote><p>owner_type就是关联的那张表。<br>owner_id就是关联的表的主键。</p></blockquote><h2 id="4、Has-Many"><a href="#4、Has-Many" class="headerlink" title="4、Has Many"></a>4、Has Many</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>ID      <span class="hljs-type">int</span><br>Name    <span class="hljs-type">string</span><br>Address []Address <span class="hljs-string">`gorm:&quot;polymorphic:Owner;&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Order <span class="hljs-keyword">struct</span> &#123;<br>ID      <span class="hljs-type">int</span><br>Name    <span class="hljs-type">string</span><br>Address Address <span class="hljs-string">`gorm:&quot;polymorphic:Owner;&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> &#123;<br>ID        <span class="hljs-type">int</span><br>Name      <span class="hljs-type">string</span><br>OwnerID   <span class="hljs-type">int</span><br>OwnerType <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db.AutoMigrate(&amp;User&#123;&#125;, &amp;Order&#123;&#125;, &amp;Address&#123;&#125;)<br>db.Create(&amp;User&#123;<br>Name: <span class="hljs-string">&quot;linzy&quot;</span>,<br>Address: []Address&#123;<br>&#123;Name: <span class="hljs-string">&quot;翻斗花园&quot;</span>&#125;,<br>&#123;Name: <span class="hljs-string">&quot;杭州西湖&quot;</span>&#125;,<br>&#125;,<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_transaction/gorm7.png"></p><h1 id="二、关联标签"><a href="#二、关联标签" class="headerlink" title="二、关联标签"></a>二、关联标签</h1><h2 id="1、polymorphic-amp-polymorphicValue"><a href="#1、polymorphic-amp-polymorphicValue" class="headerlink" title="1、polymorphic &amp; polymorphicValue"></a>1、polymorphic &amp; polymorphicValue</h2><ul><li>polymorphic：通俗讲用来指定id与type的前缀。</li><li>polymorphicValue用来告诉关联表我是谁，默认都是表名。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">int</span><br>Name <span class="hljs-type">string</span><br><span class="hljs-comment">//polymorphic：通俗讲用来指定id与type的前缀</span><br>Address []Address <span class="hljs-string">`gorm:&quot;polymorphic:Address;&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Order <span class="hljs-keyword">struct</span> &#123;<br>ID      <span class="hljs-type">int</span><br>Name    <span class="hljs-type">string</span><br><span class="hljs-comment">//polymorphicValue用来告诉关联表我是谁，默认都是表名</span><br>Address Address <span class="hljs-string">`gorm:&quot;polymorphic:Address;polymorphicValue:master&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> &#123;<br>ID          <span class="hljs-type">int</span><br>Name        <span class="hljs-type">string</span><br>AddressID   <span class="hljs-type">int</span><br>AddressType <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db.AutoMigrate(&amp;User&#123;&#125;, &amp;Order&#123;&#125;, &amp;Address&#123;&#125;)<br>db.Create(&amp;User&#123;<br>Name: <span class="hljs-string">&quot;linzy&quot;</span>,<br>Address: []Address&#123;<br>&#123;Name: <span class="hljs-string">&quot;翻斗花园&quot;</span>&#125;,<br>&#123;Name: <span class="hljs-string">&quot;杭州西湖&quot;</span>&#125;,<br>&#125;,<br>&#125;)<br><br>db.Create(&amp;Order&#123;<br>Name: <span class="hljs-string">&quot;忘崽牛奶&quot;</span>,<br>Address: Address&#123;<br>Name: <span class="hljs-string">&quot;火星幼儿园&quot;</span>,<br>&#125;,<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><img src="/img/gorm_transaction/gorm8.png"><br><img src="/img/gorm_transaction/gorm9.png"><br><img src="/img/gorm_transaction/gorm10.png"></li></ul><h2 id="2、foreignKey-amp-references"><a href="#2、foreignKey-amp-references" class="headerlink" title="2、foreignKey &amp; references"></a>2、foreignKey &amp; references</h2><ul><li>foreignKey：用来指定连接表的外键。</li><li>references：用来指定引用表的列名与连接表的外键映射。</li></ul><p>GORM里默认是连接表和引用表的主键来作为做外键以及外键映射的。</p><p>Has One的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> CreditCard <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>Number <span class="hljs-type">string</span><br><span class="hljs-comment">//外键指向CreditCardNumber</span><br>Info   Info <span class="hljs-string">`gorm:&quot;foreignKey:CreditCardNumber&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Info <span class="hljs-keyword">struct</span> &#123;<br>ID               <span class="hljs-type">uint</span><br>Name             <span class="hljs-type">string</span><br>Age              <span class="hljs-type">int</span><br>CreditCardNumber <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db.AutoMigrate(&amp;CreditCard&#123;&#125;, &amp;Info&#123;&#125;)<br>db.Create(&amp;CreditCard&#123;<br>Number: <span class="hljs-string">&quot;123456&quot;</span>,<br>Info: Info&#123;<br>Name: <span class="hljs-string">&quot;linzy&quot;</span>,<br>Age:  <span class="hljs-number">18</span>,<br>&#125;,<br>&#125;)<br><br>db.Create(&amp;CreditCard&#123;<br>Number: <span class="hljs-string">&quot;456789&quot;</span>,<br>Info: Info&#123;<br>Name: <span class="hljs-string">&quot;slyyy&quot;</span>,<br>Age:  <span class="hljs-number">66</span>,<br>&#125;,<br>&#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/img/gorm_transaction/gorm11.png"></p><p><img src="/img/gorm_transaction/gorm12.png"></p><blockquote><p>注意：credit_card_number并没有自动指向creditcard表里的number字段，他还是会默认指向引用表里的主键，所以在用<code>foreignKey</code>的时候最好类型相同或者使用<code>references</code>搭配使用。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> CreditCard <span class="hljs-keyword">struct</span> &#123;<br>ID <span class="hljs-type">uint</span><br><span class="hljs-comment">//设置唯一和固定长度</span><br>Number <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;index:unique;size:255&quot;`</span><br>Info   Info   <span class="hljs-string">`gorm:&quot;foreignKey:CreditCardNumber;references:Number&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Info <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">uint</span><br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int</span><br><span class="hljs-comment">//设置唯一和固定长度</span><br>CreditCardNumber <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;index:unique;size:255&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db.AutoMigrate(&amp;CreditCard&#123;&#125;, &amp;Info&#123;&#125;)<br>db.Create(&amp;CreditCard&#123;<br>ID:     <span class="hljs-number">1</span>,<br>Number: <span class="hljs-string">&quot;123456&quot;</span>,<br>Info: Info&#123;<br><br>Name: <span class="hljs-string">&quot;linzy&quot;</span>,<br>Age:  <span class="hljs-number">18</span>,<br>&#125;,<br>&#125;)<br><br>db.Create(&amp;CreditCard&#123;<br>ID:     <span class="hljs-number">2</span>,<br>Number: <span class="hljs-string">&quot;456789&quot;</span>,<br>Info: Info&#123;<br>Name: <span class="hljs-string">&quot;slyyy&quot;</span>,<br>Age:  <span class="hljs-number">66</span>,<br>&#125;,<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意： 某些数据库只允许在唯一索引字段上创建外键，如果在迁移时会创建外键，则需要指定 <code>index:unique</code> 标签。</p></blockquote><p><img src="/img/gorm_transaction/gorm13.png"><br><img src="/img/gorm_transaction/gorm14.png"></p><blockquote><p>错误：</p><ol><li><code>Error 1170: BLOB/TEXT column &#39;credit_card_number&#39; used in key specification without a key length</code><br>出现这个问题是因为你的外键或者外键映射的字段是text类型也就是不固定长度string类型，不能作为外键或外键映射，必须通过标签<code>size</code>设置固定长度。</li><li><code>Error 1215: Cannot add foreign key constraint</code><br>这个错误是不能创建外键，主要原因可能是你外键映射的字段不是引用表的主键，建议标签设置为唯一 <code>index:unique</code>。</li></ol></blockquote><h2 id="3、Many-to-Many"><a href="#3、Many-to-Many" class="headerlink" title="3、Many to Many"></a>3、Many to Many</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> CreditCard <span class="hljs-keyword">struct</span> &#123;<br>ID     <span class="hljs-type">uint</span><br>Number <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;index:unique;size:255&quot;`</span><br>Infos  []Info <span class="hljs-string">`gorm:&quot;many2many:card_infos;foreignKey:Number;references:Name;&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Info <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">uint</span><br>Name <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;index:unique;size:255&quot;`</span><br>Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db.AutoMigrate(&amp;CreditCard&#123;&#125;, &amp;Info&#123;&#125;)<br>db.Create(&amp;CreditCard&#123;<br>Number: <span class="hljs-string">&quot;123456&quot;</span>,<br>Infos: []Info&#123;<br>&#123;<br>ID:   <span class="hljs-number">1</span>,<br>Name: <span class="hljs-string">&quot;linzy&quot;</span>,<br>Age:  <span class="hljs-number">18</span>,<br>&#125;,<br>&#125;,<br>&#125;)<br><br>db.Create(&amp;CreditCard&#123;<br>Number: <span class="hljs-string">&quot;456789&quot;</span>,<br>Infos: []Info&#123;<br>&#123;<br>ID:   <span class="hljs-number">2</span>,<br>Name: <span class="hljs-string">&quot;slyyy&quot;</span>,<br>Age:  <span class="hljs-number">66</span>,<br>&#125;,<br>&#123;<br>ID:   <span class="hljs-number">3</span>,<br>Name: <span class="hljs-string">&quot;qhgwueiq&quot;</span>,<br>Age:  <span class="hljs-number">1</span>,<br>&#125;,<br>&#125;,<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_transaction/gorm15.png"><br><img src="/img/gorm_transaction/gorm16.png"><br><img src="/img/gorm_transaction/gorm17.png"></p><blockquote><p>注意：在<code>Many to Many</code>的情况下，foreignKey指向的是<code>引用表的外键映射字段</code>，references指向的是<code>关联表的外键字段</code>，一定不要搞混了。</p></blockquote><h2 id="4、joinForeignKey-amp-joinReferences"><a href="#4、joinForeignKey-amp-joinReferences" class="headerlink" title="4、joinForeignKey &amp; joinReferences"></a>4、joinForeignKey &amp; joinReferences</h2><ul><li>joinForeignKey：指定<code>Many to Many</code>产生的连接表中关联外键映射字段的名称。</li><li>joinReferences：指定<code>Many to Many</code>产生的连接表中关联外键字段的名称。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> CreditCard <span class="hljs-keyword">struct</span> &#123;<br>ID     <span class="hljs-type">uint</span><br>Number <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;index:unique;size:255&quot;`</span><br>Infos  []Info <span class="hljs-string">`gorm:&quot;many2many:card_infos;foreignKey:Number;joinForeignKey:card_number;references:Name;joinReferences:name&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Info <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">uint</span><br>Name <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;index:unique;size:255&quot;`</span><br>Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db.AutoMigrate(&amp;CreditCard&#123;&#125;, &amp;Info&#123;&#125;)<br>db.Create(&amp;CreditCard&#123;<br>Number: <span class="hljs-string">&quot;123456&quot;</span>,<br>Infos: []Info&#123;<br>&#123;<br>ID:   <span class="hljs-number">1</span>,<br>Name: <span class="hljs-string">&quot;linzy&quot;</span>,<br>Age:  <span class="hljs-number">18</span>,<br>&#125;,<br>&#125;,<br>&#125;)<br><br>db.Create(&amp;CreditCard&#123;<br>Number: <span class="hljs-string">&quot;456789&quot;</span>,<br>Infos: []Info&#123;<br>&#123;<br>ID:   <span class="hljs-number">2</span>,<br>Name: <span class="hljs-string">&quot;slyyy&quot;</span>,<br>Age:  <span class="hljs-number">66</span>,<br>&#125;,<br>&#123;<br>ID:   <span class="hljs-number">3</span>,<br>Name: <span class="hljs-string">&quot;qhgwueiq&quot;</span>,<br>Age:  <span class="hljs-number">1</span>,<br>&#125;,<br>&#125;,<br>&#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/img/gorm_transaction/gorm18.png"></p><h1 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h1><h2 id="1、事务概述"><a href="#1、事务概述" class="headerlink" title="1、事务概述"></a>1、事务概述</h2><p>数据库事务( transaction)是访问并可能操作各种数据项的一个<code>数据库操作序列</code>，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。 事务由事务开始与事务结束之间执行的全部数据库操作组成。</p><p>数据库事务必须具备的四个特性：</p><ul><li><strong>原子性(Atomicity)</strong><br>事务是数据库的逻辑工作单位，事务中包括的诸操作要么全做，要么全不做。</li><li><strong>一致性(Consistency)</strong><br>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li><li><strong>隔离性(Isolation)</strong><br>一个事务的执行不能被其他事务干扰。</li><li><strong>持续性&#x2F;永久性(Durability)</strong><br>一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。</li></ul><h2 id="2、事务操作"><a href="#2、事务操作" class="headerlink" title="2、事务操作"></a>2、事务操作</h2><p>要在事务中执行一系列操作，一般流程如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db.AutoMigrate(&amp;User&#123;&#125;)<br>db.Transaction(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx *gorm.DB)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 在事务中执行一些 db 操作（从这里开始，应该使用 &#x27;tx&#x27; 而不是 &#x27;db&#x27;）</span><br><span class="hljs-keyword">if</span> err := tx.Create(&amp;User&#123;Name: <span class="hljs-string">&quot;Giraffe&quot;</span>&#125;).Error; err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 返回任何错误都会回滚事务</span><br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">if</span> err := tx.Create(&amp;User&#123;Name: <span class="hljs-string">&quot;Lion&quot;</span>&#125;).Error; err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// 返回 nil 提交事务</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_transaction/gorm19.png"></p><h3 id="1）回滚"><a href="#1）回滚" class="headerlink" title="1）回滚"></a>1）回滚</h3><blockquote><p>注意：返回任何错误都会回滚事务。回滚则事务内的操作一律不执行。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db.AutoMigrate(&amp;User&#123;&#125;)<br>db.Transaction(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx *gorm.DB)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 在事务中执行一些 db 操作（从这里开始，应该使用 &#x27;tx&#x27; 而不是 &#x27;db&#x27;）</span><br><span class="hljs-keyword">if</span> err := tx.Create(&amp;User&#123;Name: <span class="hljs-string">&quot;linzy&quot;</span>&#125;).Error; err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 返回任何错误都会回滚事务</span><br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">if</span> err := tx.Create(&amp;User&#123;Name: <span class="hljs-string">&quot;slyyy&quot;</span>&#125;).Error; err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;回滚&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 返回 nil 提交事务</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_transaction/gorm20.png"></p><h3 id="2）嵌套事务"><a href="#2）嵌套事务" class="headerlink" title="2）嵌套事务"></a>2）嵌套事务</h3><p>嵌套事务的作用在于较大的事务中，你只想回滚一部分操作，例如你去银行转账，已经通过银行卡号和密码登录了，转账的过程是你的银行账户扣去多少钱，同时别人的银行账户加上多少钱，如果中途发生错误，需要回滚，应该回滚到你账号登录后的状态，而不是直接回滚到你账号登录前。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>Name   <span class="hljs-type">string</span><br>Number <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db.AutoMigrate(&amp;User&#123;&#125;)<br>db.Transaction(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx *gorm.DB)</span></span> <span class="hljs-type">error</span> &#123;<br>tx.Create(&amp;User&#123;<br>Name:   <span class="hljs-string">&quot;linzy&quot;</span>,<br>Number: <span class="hljs-number">100</span>,<br>&#125;)<br>tx.Create(&amp;User&#123;<br>Name:   <span class="hljs-string">&quot;slyyy&quot;</span>,<br>Number: <span class="hljs-number">100</span>,<br>&#125;)<br>fmt.Println(<span class="hljs-string">&quot;登陆后&quot;</span>)<br>tx.Transaction(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx2 *gorm.DB)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 在事务中执行一些 db 操作（从这里开始，应该使用 &#x27;tx&#x27; 而不是 &#x27;db&#x27;)</span><br><span class="hljs-keyword">if</span> err := tx2.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>).Update(<span class="hljs-string">&quot;number&quot;</span>, <span class="hljs-number">80</span>).Error; err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 返回任何错误都会回滚事务</span><br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">if</span> err := tx2.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;slyyy&quot;</span>).Update(<span class="hljs-string">&quot;number&quot;</span>, <span class="hljs-number">120</span>).Error; err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br>fmt.Println(<span class="hljs-string">&quot;转账结束&quot;</span>)<br><span class="hljs-comment">// 返回 nil 提交事务</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_transaction/gorm21.png"></p><p><img src="/img/gorm_transaction/gorm22.png"><br>正常的过程应该是这样，如果说嵌套事务发生回滚操作之后的情况呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db.AutoMigrate(&amp;User&#123;&#125;)<br>db.Transaction(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx *gorm.DB)</span></span> <span class="hljs-type">error</span> &#123;<br>tx.Create(&amp;User&#123;<br>Name:   <span class="hljs-string">&quot;linzy&quot;</span>,<br>Number: <span class="hljs-number">100</span>,<br>&#125;)<br>tx.Create(&amp;User&#123;<br>Name:   <span class="hljs-string">&quot;slyyy&quot;</span>,<br>Number: <span class="hljs-number">100</span>,<br>&#125;)<br>fmt.Println(<span class="hljs-string">&quot;登陆后&quot;</span>)<br>tx.Transaction(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(tx2 *gorm.DB)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 在事务中执行一些 db 操作（从这里开始，应该使用 &#x27;tx&#x27; 而不是 &#x27;db&#x27;)</span><br><span class="hljs-keyword">if</span> err := tx2.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>).Update(<span class="hljs-string">&quot;number&quot;</span>, <span class="hljs-number">80</span>).Error; err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 返回任何错误都会回滚事务</span><br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;转账失败，对面是骗子不能转！！&quot;</span>)<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;转账失败&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> err := tx2.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;slyyy&quot;</span>).Update(<span class="hljs-string">&quot;number&quot;</span>, <span class="hljs-number">120</span>).Error; err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br>fmt.Println(<span class="hljs-string">&quot;转账结束&quot;</span>)<br><span class="hljs-comment">// 返回 nil 提交事务</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/img/gorm_transaction/gorm23.png"><br><img src="/img/gorm_transaction/gorm24.png"></p><h2 id="3、手动事务"><a href="#3、手动事务" class="headerlink" title="3、手动事务"></a>3、手动事务</h2><p>Gorm 支持直接调用事务控制方法（commit、rollback），例如：</p><table><thead><tr><th align="left">事务方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">tx :&#x3D; db.Begin()</td><td align="left">开始事务</td></tr><tr><td align="left">tx.（db操作）</td><td align="left">在事务中执行一些 db 操作</td></tr><tr><td align="left">tx.Rollback()</td><td align="left">遇到错误时回滚事务</td></tr><tr><td align="left">tx.SavePoint()</td><td align="left">设置保存点标记</td></tr><tr><td align="left">tx.RollbackTo()</td><td align="left">回滚到保存点标记</td></tr><tr><td align="left">tx.Commit()</td><td align="left">提交事务</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>Name   <span class="hljs-type">string</span><br>Number <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db.AutoMigrate(&amp;User&#123;&#125;)<br><span class="hljs-comment">// 开始事务</span><br>tx := db.Begin()<br><br><span class="hljs-comment">// 在事务中执行一些 db 操作（从这里开始，您应该使用 &#x27;tx&#x27; 而不是 &#x27;db&#x27;）</span><br>tx.Create(&amp;User&#123;<br>Name:   <span class="hljs-string">&quot;linzy&quot;</span>,<br>Number: <span class="hljs-number">100</span>,<br>&#125;)<br>tx.Create(&amp;User&#123;<br>Name:   <span class="hljs-string">&quot;slyyy&quot;</span>,<br>Number: <span class="hljs-number">100</span>,<br>&#125;)<br>fmt.Println(<span class="hljs-string">&quot;登陆后&quot;</span>)<br><span class="hljs-comment">//设置回滚标记</span><br>tx.SavePoint(<span class="hljs-string">&quot;登录了&quot;</span>)<br>flag := <span class="hljs-literal">true</span><br>&#123;<br><span class="hljs-keyword">if</span> err := tx.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>).Update(<span class="hljs-string">&quot;number&quot;</span>, <span class="hljs-number">80</span>).Error; err != <span class="hljs-literal">nil</span> &#123;<br>flag = <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">if</span> err := tx.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;slyyy&quot;</span>).Update(<span class="hljs-string">&quot;number&quot;</span>, <span class="hljs-number">120</span>).Error; err != <span class="hljs-literal">nil</span> &#123;<br>flag = <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">//出现问题了得写在一系列事务之后进行回滚</span><br><span class="hljs-keyword">if</span> flag &#123;<br>fmt.Println(<span class="hljs-string">&quot;转账失败，对面是骗子不能转！！&quot;</span>)<br><span class="hljs-comment">//回滚到指定标记</span><br>tx.RollbackTo(<span class="hljs-string">&quot;登录了&quot;</span>)<br>&#125;<br>&#125;<br><span class="hljs-comment">// 遇到错误时回滚事务</span><br>fmt.Println(<span class="hljs-string">&quot;转账结束&quot;</span>)<br><span class="hljs-comment">// 否则，提交事务</span><br>tx.Commit()<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_transaction/gorm25.png"></p><p>官方示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateAnimals</span><span class="hljs-params">(db *gorm.DB)</span></span> <span class="hljs-type">error</span> &#123;<br>  <span class="hljs-comment">// 再唠叨一下，事务一旦开始，你就应该使用 tx 处理数据</span><br>  tx := db.Begin()<br>  <span class="hljs-comment">//延迟函数一定要写上，因为出现panic错误时事务可能没办法回滚，需要手动再回滚</span><br>  <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>      tx.Rollback()<br>    &#125;<br>  &#125;()<br><br>  <span class="hljs-keyword">if</span> err := tx.Error; err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> err := tx.Create(&amp;Animal&#123;Name: <span class="hljs-string">&quot;Giraffe&quot;</span>&#125;).Error; err != <span class="hljs-literal">nil</span> &#123;<br>     tx.Rollback()<br>     <span class="hljs-keyword">return</span> err<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> err := tx.Create(&amp;Animal&#123;Name: <span class="hljs-string">&quot;Lion&quot;</span>&#125;).Error; err != <span class="hljs-literal">nil</span> &#123;<br>     tx.Rollback()<br>     <span class="hljs-keyword">return</span> err<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> tx.Commit().Error<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、禁用默认事务"><a href="#4、禁用默认事务" class="headerlink" title="4、禁用默认事务"></a>4、禁用默认事务</h2><p>为了确保数据一致性，GORM 会在事务里执行写入操作（创建、更新、删除）。如果没有这方面的要求，您可以在初始化时禁用它，这将获得大约 30%+ 性能提升。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 全局禁用</span><br>db, err := gorm.Open(sqlite.Open(<span class="hljs-string">&quot;gorm.db&quot;</span>), &amp;gorm.Config&#123;<br>  SkipDefaultTransaction: <span class="hljs-literal">true</span>,<br>&#125;)<br><br><span class="hljs-comment">// 持续会话模式</span><br>tx := db.Session(&amp;Session&#123;SkipDefaultTransaction: <span class="hljs-literal">true</span>&#125;)<br>tx.First(&amp;user, <span class="hljs-number">1</span>)<br>tx.Find(&amp;users)<br>tx.Model(&amp;user).Update(<span class="hljs-string">&quot;Age&quot;</span>, <span class="hljs-number">18</span>)<br></code></pre></td></tr></table></figure><h1 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h1><p>本章拓展了GORM对数据库的更多支持，关联标签与事务是很重要的内容。</p><ul><li>关联标签：</li></ul><table><thead><tr><th align="left">标签</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">foreignKey</td><td align="left">指定当前模型的列作为连接表的外键</td></tr><tr><td align="left">references</td><td align="left">指定引用表的列名，其将被映射为连接表外键</td></tr><tr><td align="left">polymorphic</td><td align="left">指定多态类型，比如模型名</td></tr><tr><td align="left">polymorphicValue</td><td align="left">指定多态值、默认表名</td></tr><tr><td align="left">many2many</td><td align="left">指定连接表表名</td></tr><tr><td align="left">joinForeignKey</td><td align="left">指定连接表的外键列名，其将被映射到当前表</td></tr><tr><td align="left">joinReferences</td><td align="left">指定连接表的外键列名，其将被映射到引用表</td></tr></tbody></table><ul><li>事务：</li></ul><p>手动事务适用于小事务操作，出错了直接全部回滚会更好，虽然提供了 <code>SavePoint</code>、<code>Rollbackto</code>方法，来提供保存点以及回滚至保存点功能，但是有一些同步操作操作很不方便。<br>GORM自带事务适用大事务操作，可以使用嵌套事务。</p><blockquote><p>若有写的错误的或者需要改进的地方，希望能直接指出，再次感谢GVA淼哥的教程！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Gorm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>mysql</tag>
      
      <tag>数据库</tag>
      
      <tag>Gorm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gorm学习（四）基础：关联</title>
    <link href="/2022/10/11/gorm-associate/"/>
    <url>/2022/10/11/gorm-associate/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>感谢开源项目<a href="https://www.gin-vue-admin.com/">gin-vue-admin</a>，以及<a href="https://www.bilibili.com/video/BV12i4y1x7AG?spm_id_from=333.999.0.0">1010工作室的视频教程</a></p></blockquote><h1 id="一、One-To-One-一对一"><a href="#一、One-To-One-一对一" class="headerlink" title="一、One To One 一对一"></a>一、One To One 一对一</h1><p>数据库连接例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> db *gorm.DB<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-comment">//我这里用到数据库是mysql，需要配置DSN属性[username[:password]@][protocol[(address)]]/dbname[?param1=value1&amp;...&amp;paramN=valueN]</span><br>dsn := <span class="hljs-string">&quot;root:123456@tcp(127.0.0.1:3306)/go_test?charset=utf8&amp;parseTime=True&quot;</span><br>db, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to connect database&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1、Belongs-To-属于"><a href="#1、Belongs-To-属于" class="headerlink" title="1、Belongs To 属于"></a>1、Belongs To 属于</h2><p>belongs to 会与另一个模型建立了<code>一对一</code>的连接。 这种模型的每一个实例都“属于”另一个模型的一个实例。</p><p>例如：你有两张表 users 表和 companies 表</p><ul><li>users –用户表</li><li>companies –公司表</li></ul><p>user 是属于 company 的，就是每个 user 有且只能对应分配给一个 company。</p><blockquote><p>注意：在 User 对象中，有一个和 Company 一样的 <code>CompanyID</code>。 默认情况下， CompanyID 被隐含地用来在 User 和 Company 之间创建一个<code>外键关系</code>， 因此必须包含在 User 结构体中才能填充 Company 内部结构体。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// `User` 属于 `Company`，`CompanyID` 是外键</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>Name      <span class="hljs-type">string</span><br>CompanyID <span class="hljs-type">int</span> <span class="hljs-comment">// 默认情况下， CompanyID 被隐含地用来在 User 和 Company 之间创建一个外键关系</span><br>Company   Company<br>&#125;<br><br><span class="hljs-keyword">type</span> Company <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">int</span><br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//user 里面有 company表的结构 所以只需要自动迁移user表即可</span><br>db.AutoMigrate(&amp;User&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm1.png"></p><h3 id="1）创建记录"><a href="#1）创建记录" class="headerlink" title="1）创建记录"></a>1）创建记录</h3><p>创建在<code>dachang</code>里的用户<code>linzy</code>的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">c := Company&#123;<br>ID:   <span class="hljs-number">1</span>,<br>Name: <span class="hljs-string">&quot;dachang&quot;</span>,<br>&#125;<br><br>u := User&#123;<br>Name:    <span class="hljs-string">&quot;linzy&quot;</span>,<br>Company: c,<br>&#125;<br>db.Create(&amp;u)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm2.png"><br><img src="/img/gorm_associate/gorm3.png"></p><blockquote><p>不仅 users 表新增记录，companies 表也新增了。这是因为在创建、更新记录时，GORM 会通过 <code>Upsert</code> 自动保存关联及其引用记录。</p></blockquote><h3 id="2）查询记录"><a href="#2）查询记录" class="headerlink" title="2）查询记录"></a>2）查询记录</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> u User<br>db.Model(&amp;User&#123;&#125;).First(&amp;u)<br>fmt.Println(u)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm4.png"></p><blockquote><p>注意：我们发现并没有查出我们关联的 companies 表里面的记录，因为我们在使用CRUD的时候需要所关联的结构时，必须要使用预加载 <code>Preload </code>.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> u User<br>db.Model(&amp;User&#123;&#125;).Preload(<span class="hljs-string">&quot;Company&quot;</span>).First(&amp;u)<br>fmt.Println(u)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm5.png"></p><h3 id="3）重写外键"><a href="#3）重写外键" class="headerlink" title="3）重写外键"></a>3）重写外键</h3><p>要定义一个 belongs to 关系，数据库的表中必须存在外键。默认gorm使用（关联属性类型 + 主键）组成外键名，如上面的例子User + ID 组成UserID，UserID就作为Profile的外键。</p><p>例如我们想自定义外键，就需要用标签<code>foreignKe</code>来指定外键：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  gorm.Model<br>  Name         <span class="hljs-type">string</span><br>  CompanyRefer <span class="hljs-type">int</span><br>  Company      Company <span class="hljs-string">`gorm:&quot;foreignKey:CompanyRefer&quot;`</span><br>  <span class="hljs-comment">// 使用 CompanyRefer 作为外键</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Company <span class="hljs-keyword">struct</span> &#123;<br>  ID   <span class="hljs-type">int</span><br>  Name <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4）重写引用"><a href="#4）重写引用" class="headerlink" title="4）重写引用"></a>4）重写引用</h3><p>对于 belongs to 关系，GORM 通常使用数据库表，主表（拥有者）的<code>主键值作为外键参考。</code>例如上面的例子，User  中 CompanyRefer 属性作为外键，它和Company 中的ID进行关联，这里 Company 的ID就是关联外键。</p><p>我们可以使用标签 references 来更改它，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  gorm.Model<br>  Name      <span class="hljs-type">string</span><br>  CompanyID <span class="hljs-type">string</span><br>  Company   Company <span class="hljs-string">`gorm:&quot;references:Code&quot;`</span> <span class="hljs-comment">// 使用 Code 作为引用</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Company <span class="hljs-keyword">struct</span> &#123;<br>  ID   <span class="hljs-type">int</span><br>  Code <span class="hljs-type">string</span><br>  Name <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5）关联模式"><a href="#5）关联模式" class="headerlink" title="5）关联模式"></a>5）关联模式</h3><h4 id="a、查找关联"><a href="#a、查找关联" class="headerlink" title="a、查找关联"></a>a、查找关联</h4><p>如果我们想查找指定的 user 匹配的关联记录，可以用<code>Association</code>找users表关联的记录:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> user User<br>db.Where(<span class="hljs-string">&quot;id = ?&quot;</span>, <span class="hljs-number">1</span>).Take(&amp;user)<br>fmt.Println(user)<br><br><span class="hljs-keyword">var</span> c Company<br><span class="hljs-comment">// `user` 是源模型，它的主键不能为空</span><br><span class="hljs-comment">// 关系的字段名是 `Company`</span><br><span class="hljs-comment">// 如果匹配了上面两个要求，会开始关联模式，否则会返回错误</span><br>db.Model(&amp;user).Association(<span class="hljs-string">&quot;Company&quot;</span>).Find(&amp;c)<br>fmt.Println(c)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm6.png"></p><h4 id="b、删除关联"><a href="#b、删除关联" class="headerlink" title="b、删除关联"></a>b、删除关联</h4><p>user 可以关联 company，同样也可以不关联，但是去库里删很麻烦，用Delete方法删除源模型与参数之间的关系，<code>只会删除引用，不会从数据库中删除这些对象。</code></p><p>删除前：<br><img src="/img/gorm_associate/gorm7.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> user User<br>db.Where(<span class="hljs-string">&quot;id = ?&quot;</span>, <span class="hljs-number">1</span>).First(&amp;user)<br><br><span class="hljs-comment">//一定要指定关联的主键</span><br>db.Model(&amp;user).Association(<span class="hljs-string">&quot;Company&quot;</span>).Delete(&amp;Company&#123;ID: <span class="hljs-number">1</span>&#125;)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm8.png"></p><h4 id="c、添加关联"><a href="#c、添加关联" class="headerlink" title="c、添加关联"></a>c、添加关联</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> user User<br>db.Where(<span class="hljs-string">&quot;id = ?&quot;</span>, <span class="hljs-number">1</span>).First(&amp;user)<br><br><span class="hljs-comment">//一定要指定关联的主键</span><br>db.Model(&amp;user).Association(<span class="hljs-string">&quot;Company&quot;</span>).Append(&amp;Company&#123;ID: <span class="hljs-number">1</span>&#125;)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm9.png"></p><h4 id="d、修改-替换-关联"><a href="#d、修改-替换-关联" class="headerlink" title="d、修改(替换)关联"></a>d、修改(替换)关联</h4><p>修改关联就是删除关联后，再添加新的关联。<br><img src="/img/gorm_associate/gorm10.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> user User<br>db.Where(<span class="hljs-string">&quot;id = ?&quot;</span>, <span class="hljs-number">1</span>).First(&amp;user)<br><br>db.Model(&amp;user).Association(<span class="hljs-string">&quot;Company&quot;</span>).Replace(&amp;Company&#123;ID: <span class="hljs-number">2</span>&#125;)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm11.png"></p><p><img src="/img/gorm_associate/gorm12.png"></p><h2 id="2、Has-One-拥有"><a href="#2、Has-One-拥有" class="headerlink" title="2、Has One 拥有"></a>2、Has One 拥有</h2><p>has one 与另一个模型建立一对一的关联，但它和一对一关系有些许不同。 这种关联表明一个模型的每个实例都包含或拥有另一个模型的一个实例。</p><blockquote><p>提示：Has one很像属于（belongs to）关系，都是一对一关系，区别是<code>Has One关系和Belongs To关系，持有关联Model属性的关系是相反的</code>，例如：A 关联 B，Has One关系通常是A 结构体持有B属性， belongs to关系则是B结构体持有A。</p></blockquote><p>例如：你有两张表 users 表和 credit_cards 表</p><ul><li>users –用户表</li><li>credit_cards –信用卡表</li></ul><p>user 是拥有 creditcard 的，creditcard 有且只能被一个 user 拥有。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// User 有一张 CreditCard，UserID 是外键</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>CreditCard CreditCard<br>&#125;<br><br><span class="hljs-keyword">type</span> CreditCard <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>Number <span class="hljs-type">string</span><br>UserID <span class="hljs-type">uint</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//这里需要先创建users表，再创建credit_cards表</span><br>db.AutoMigrate(&amp;User&#123;&#125;, &amp;CreditCard&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1）创建记录-1"><a href="#1）创建记录-1" class="headerlink" title="1）创建记录"></a>1）创建记录</h3><p>创建用户拥有信用卡号为<code>123456</code>的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">c := CreditCard&#123;<br>Number: <span class="hljs-string">&quot;123456&quot;</span>,<br>&#125;<br><br>u := User&#123;<br>CreditCard: c,<br>&#125;<br>db.Create(&amp;u)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm13.png"><br><img src="/img/gorm_associate/gorm14.png"></p><h3 id="2）查询记录-1"><a href="#2）查询记录-1" class="headerlink" title="2）查询记录"></a>2）查询记录</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> u User<br>db.Model(&amp;User&#123;&#125;).Preload(<span class="hljs-string">&quot;CreditCard&quot;</span>).First(&amp;u)<br>fmt.Println(u)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm15.png"></p><h3 id="3）重写外键-1"><a href="#3）重写外键-1" class="headerlink" title="3）重写外键"></a>3）重写外键</h3><p>对于 has one 关系，同样必须存在外键字段。拥有者将把属于它的模型的主键保存到这个字段。</p><p>默认情况下Has One关系的外键由持有关联属性的类型名 + 主键 组成外键名，如上例，User关联CreditCard的外键就是User + ID &#x3D; UserID。</p><p>如果你想要使用另一个字段来保存该关系，你同样可以使用标签 <code>foreignKey</code> 来更改它，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  gorm.Model<br>  CreditCard CreditCard <span class="hljs-string">`gorm:&quot;foreignKey:UserName&quot;`</span><br>  <span class="hljs-comment">// use UserName as foreign key</span><br>&#125;<br><br><span class="hljs-keyword">type</span> CreditCard <span class="hljs-keyword">struct</span> &#123;<br>  gorm.Model<br>  Number   <span class="hljs-type">string</span><br>  UserName <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4）重写引用-1"><a href="#4）重写引用-1" class="headerlink" title="4）重写引用"></a>4）重写引用</h3><p>默认情况下，保存User的时候，会自动将User的主键保存到外键UserID中，关联查询的时候，也会使用外键和关联外键进行关联进行查询，这里User的ID就是<code>关联外键</code>。</p><p>可以使用标签 <code>references</code> 来更改它，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  gorm.Model<br>  Name       <span class="hljs-type">string</span>     <span class="hljs-string">`gorm:&quot;index&quot;`</span><br>  CreditCard CreditCard <span class="hljs-string">`gorm:&quot;foreignkey:UserName;references:name&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> CreditCard <span class="hljs-keyword">struct</span> &#123;<br>  gorm.Model<br>  Number   <span class="hljs-type">string</span><br>  UserName <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5）关联模式-1"><a href="#5）关联模式-1" class="headerlink" title="5）关联模式"></a>5）关联模式</h3><h4 id="a、查找关联-1"><a href="#a、查找关联-1" class="headerlink" title="a、查找关联"></a>a、查找关联</h4><p>如果我们想查找指定的 user 匹配的关联记录，可以用<code>Association</code>找users表关联的记录:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> user User<br>db.Where(<span class="hljs-string">&quot;id = ?&quot;</span>, <span class="hljs-number">1</span>).Take(&amp;user)<br>fmt.Println(user)<br><br><span class="hljs-keyword">var</span> c CreditCard<br><span class="hljs-comment">// `user` 是源模型，它的主键不能为空</span><br><span class="hljs-comment">// 关系的字段名是 `CreditCard`</span><br><span class="hljs-comment">// 如果匹配了上面两个要求，会开始关联模式，否则会返回错误</span><br>db.Model(&amp;user).Association(<span class="hljs-string">&quot;CreditCard&quot;</span>).Find(&amp;c)<br>fmt.Println(c)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm16.png"></p><h4 id="b、删除关联-1"><a href="#b、删除关联-1" class="headerlink" title="b、删除关联"></a>b、删除关联</h4><p>user 可以关联 CreditCard，同样也可以不关联，但是去库里删很麻烦，用Delete方法删除源模型与参数之间的关系，<code>只会删除引用，不会从数据库中删除这些对象。</code></p><p>删除前：<br><img src="/img/gorm_associate/gorm17.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">user := User&#123;&#125;<br>db.Where(<span class="hljs-string">&quot;id = ?&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>).First(&amp;user)<br><br><span class="hljs-comment">//一定要指定关联的主键</span><br>db.Model(&amp;user).Association(<span class="hljs-string">&quot;CreditCard&quot;</span>).Delete(&amp;CreditCard&#123;<br>Model: gorm.Model&#123;<br>ID: <span class="hljs-number">1</span>,<br>&#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm18.png"></p><h4 id="c、添加关联-1"><a href="#c、添加关联-1" class="headerlink" title="c、添加关联"></a>c、添加关联</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> user User<br>db.Where(<span class="hljs-string">&quot;id = ?&quot;</span>, <span class="hljs-number">1</span>).First(&amp;user)<br><br><span class="hljs-comment">//一定要指定关联的主键</span><br>db.Model(&amp;user).Association(<span class="hljs-string">&quot;CreditCard&quot;</span>).Append(&amp;CreditCard&#123;<br>Model: gorm.Model&#123;<br>ID: <span class="hljs-number">1</span>,<br>&#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm19.png"></p><h4 id="d、修改-替换-关联-1"><a href="#d、修改-替换-关联-1" class="headerlink" title="d、修改(替换)关联"></a>d、修改(替换)关联</h4><p>修改关联就是删除关联后，再添加新的关联。</p><p><img src="/img/gorm_associate/gorm20.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">user := User&#123;&#125;<br>db.Where(<span class="hljs-string">&quot;id = ?&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>).First(&amp;user)<br><br>db.Model(&amp;user).Association(<span class="hljs-string">&quot;CreditCard&quot;</span>).Replace(&amp;CreditCard&#123;<br>Model: gorm.Model&#123;<br>ID: <span class="hljs-number">1</span>,<br>&#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm21.png"></p><h1 id="二、Has-Many-一对多"><a href="#二、Has-Many-一对多" class="headerlink" title="二、Has Many 一对多"></a>二、Has Many 一对多</h1><p><code>has many</code> 与另一个模型建立了一对多的连接。 不同于 has one，拥有者可以有零或多个关联模型。</p><p>例如：你有两张表 users 表和 credit_cards 表</p><ul><li>users –用户表</li><li>credit_cards –信用卡表</li></ul><p>user 是拥有多张 creditcard的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// User 有多张 CreditCard，UserID 是外键</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  gorm.Model<br>  CreditCards []CreditCard<br>&#125;<br><br><span class="hljs-keyword">type</span> CreditCard <span class="hljs-keyword">struct</span> &#123;<br>  gorm.Model<br>  Number <span class="hljs-type">string</span><br>  UserID <span class="hljs-type">uint</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db.AutoMigrate(&amp;User&#123;&#125;, &amp;CreditCard&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1、创建记录"><a href="#1、创建记录" class="headerlink" title="1、创建记录"></a>1、创建记录</h2><p>创建用户拥有两种信用卡的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">c1 := CreditCard&#123;<br>Number: <span class="hljs-string">&quot;123456&quot;</span>,<br>&#125;<br>c2 := CreditCard&#123;<br>Number: <span class="hljs-string">&quot;8791265&quot;</span>,<br>&#125;<br>u := User&#123;<br>CreditCards: []CreditCard&#123;c1, c2&#125;,<br>&#125;<br>db.Create(&amp;u)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm22.png"><br><img src="/img/gorm_associate/gorm23.png"></p><h2 id="2、查询记录"><a href="#2、查询记录" class="headerlink" title="2、查询记录"></a>2、查询记录</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> user User<br>db.Model(&amp;User&#123;&#125;).Preload(<span class="hljs-string">&quot;CreditCards&quot;</span>).Find(&amp;user)<br>fmt.Println(user)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm24.png"></p><h2 id="3、预加载"><a href="#3、预加载" class="headerlink" title="3、预加载"></a>3、预加载</h2><p>GORM 允许在 Preload 的其它 SQL 中直接加载关系</p><h3 id="1）预加载全部"><a href="#1）预加载全部" class="headerlink" title="1）预加载全部"></a>1）预加载全部</h3><p>与创建、更新时使用 Select 类似，<code>clause.Associations</code> 也可以和 <code>Preload</code>一起使用，它可以用来 <code>预加载全部关联</code>，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  gorm.Model<br>  Name       <span class="hljs-type">string</span><br>  CompanyID  <span class="hljs-type">uint</span><br>  Company    Company<br>  Role       Role<br>  Orders     []Order<br>&#125;<br><br>db.Preload(clause.Associations).Find(&amp;users)<br><br></code></pre></td></tr></table></figure><h3 id="2）嵌套预加载"><a href="#2）嵌套预加载" class="headerlink" title="2）嵌套预加载"></a>2）嵌套预加载</h3><p><code>clause.Associations</code> 不会预加载<code>嵌套的关联</code>，如果你在需要用嵌套的关联，你可以使用嵌套预加载 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// User 有多张 CreditCard，UserID 是外键</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>CreditCards []CreditCard<br>&#125;<br><br><span class="hljs-keyword">type</span> CreditCard <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>Number <span class="hljs-type">string</span><br>UserID <span class="hljs-type">uint</span><br>Info   Info<br>&#125;<br><br><span class="hljs-keyword">type</span> Info <span class="hljs-keyword">struct</span> &#123;<br>ID           <span class="hljs-type">uint</span><br>Name         <span class="hljs-type">string</span><br>Age          <span class="hljs-type">int</span><br>CreditCardID <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm25.png"><br><img src="/img/gorm_associate/gorm26.png"><br><img src="/img/gorm_associate/gorm27.png"></p><p>使用之前预加载查询记录查询：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> user User<br>db.Model(&amp;User&#123;&#125;).Preload(<span class="hljs-string">&quot;CreditCards&quot;</span>).Find(&amp;user)<br>fmt.Println(user)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm28.png"></p><blockquote><p>我们只能查到主表对应关联的表结构记录，所以我们这里需要用到<code>嵌套预加载</code>的方式拿到我们需要的数据。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> user User<br><span class="hljs-comment">//CreditCards.Info关联的下层结构</span><br>db.Model(&amp;User&#123;&#125;).Preload(<span class="hljs-string">&quot;CreditCards.Info&quot;</span>).Preload(<span class="hljs-string">&quot;CreditCards&quot;</span>).Find(&amp;user)<br>fmt.Println(user)<br></code></pre></td></tr></table></figure><p>或者 使用 <code>自定义预加载 SQL</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> user User<br>db.Model(&amp;User&#123;&#125;).Preload(<span class="hljs-string">&quot;CreditCards&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(db *gorm.DB)</span></span> *gorm.DB &#123;<br><span class="hljs-keyword">return</span> db.Preload(<span class="hljs-string">&quot;Info&quot;</span>)<br>&#125;).Find(&amp;user)<br>fmt.Println(user)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm29.png"></p><h3 id="3）带条件的预加载"><a href="#3）带条件的预加载" class="headerlink" title="3）带条件的预加载"></a>3）带条件的预加载</h3><p>有时候我们需要查询特定的关联结构记录时，可以使用<code>带条件的 Preload 关联</code>，类似于内联条件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> user User<br><span class="hljs-comment">//找到信用卡号不等于`123456`的记录</span><br>db.Model(&amp;User&#123;&#125;).Preload(<span class="hljs-string">&quot;CreditCards.Info&quot;</span>).Preload(<span class="hljs-string">&quot;CreditCards&quot;</span>, <span class="hljs-string">&quot;Number &lt;&gt; ?&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>).Find(&amp;user)<br>fmt.Println(user)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm30.png"></p><h4 id="a、Joins-预加载"><a href="#a、Joins-预加载" class="headerlink" title="a、Joins  预加载"></a>a、Joins  预加载</h4><p>可以直接查询关联的下层关联结构，但是这时候不能直接使用带条件的 Preload 关联了，例如我要找信用卡用户不是”linzy“的时候：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> user User<br>db.Model(&amp;User&#123;&#125;).Preload(<span class="hljs-string">&quot;CreditCards.Info&quot;</span>, <span class="hljs-string">&quot;name &lt;&gt; ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>).Preload(<span class="hljs-string">&quot;CreditCards&quot;</span>).Find(&amp;user)<br>fmt.Println(user)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm31.png"></p><p>他虽然满足了条件，但不是我们想要的结果，这个时候需要用到<code>自定义加载SQL以及 Joins  预加载</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> user User<br>db.Model(&amp;User&#123;&#125;).Preload(<span class="hljs-string">&quot;CreditCards&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(db *gorm.DB)</span></span> *gorm.DB &#123;<br><span class="hljs-keyword">return</span> db.Joins(<span class="hljs-string">&quot;Info&quot;</span>).Where(<span class="hljs-string">&quot;name &lt;&gt; ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>)<br>&#125;).Find(&amp;user)<br>fmt.Println(user)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm32.png"></p><blockquote><p>注意：<code>Preload</code> 在一个单独查询中加载关联数据。而 <code>Join Preload</code> 会使用 left join 加载关联数据。<br><code>Join Preload 适用于一对一的关系</code>，例如： has one, belongs to。</p></blockquote><h2 id="4、多态关联"><a href="#4、多态关联" class="headerlink" title="4、多态关联"></a>4、多态关联</h2><p>GORM 为 <code>has one</code> 和 <code>has many</code> 提供了多态关联支持，它会将拥有者实体的表名、主键都保存到多态类型的字段中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">int</span><br>Name <span class="hljs-type">string</span><br>Toys []Toy <span class="hljs-string">`gorm:&quot;polymorphic:Owner;&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Toy <span class="hljs-keyword">struct</span> &#123;<br>ID        <span class="hljs-type">int</span><br>Name      <span class="hljs-type">string</span><br>OwnerID   <span class="hljs-type">int</span><br>OwnerType <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db.AutoMigrate(&amp;Dog&#123;&#125;, &amp;Toy&#123;&#125;)<br>db.Create(&amp;Dog&#123;Name: <span class="hljs-string">&quot;dog1&quot;</span>, Toys: []Toy&#123;&#123;Name: <span class="hljs-string">&quot;toy1&quot;</span>&#125;, &#123;Name: <span class="hljs-string">&quot;toy2&quot;</span>&#125;&#125;&#125;)<br><span class="hljs-comment">// INSERT INTO `dogs` (`name`) VALUES (&quot;dog1&quot;)</span><br><span class="hljs-comment">// INSERT INTO `toys` (`name`,`owner_id`,`owner_type`) VALUES (&quot;toy1&quot;,&quot;1&quot;,&quot;dogs&quot;), (&quot;toy2&quot;,&quot;1&quot;,&quot;dogs&quot;)</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm33.png"><br><img src="/img/gorm_associate/gorm34.png"></p><h2 id="5、关联模式"><a href="#5、关联模式" class="headerlink" title="5、关联模式"></a>5、关联模式</h2><p>关联模式下不同关系的CRUD关联都是类似的写法，就不多阐述了。</p><h3 id="1）清空关联"><a href="#1）清空关联" class="headerlink" title="1）清空关联"></a>1）清空关联</h3><p>删除源模型与关联之间的所有引用，但不会删除这些关联。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> user User<br>db.First(&amp;user)<br>db.Model(&amp;user).Association(<span class="hljs-string">&quot;CreditCards&quot;</span>).Clear()<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm35.png"></p><h3 id="2）关联计数"><a href="#2）关联计数" class="headerlink" title="2）关联计数"></a>2）关联计数</h3><p>返回当前关联的总数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> user User<br>db.First(&amp;user)<br><span class="hljs-comment">//添加关联</span><br>db.Model(&amp;user).Association(<span class="hljs-string">&quot;CreditCards&quot;</span>).Append(&amp;CreditCard&#123;<br>Model: gorm.Model&#123;<br>ID: <span class="hljs-number">1</span>,<br>&#125;,<br>&#125;, &amp;CreditCard&#123;<br>Model: gorm.Model&#123;<br>ID: <span class="hljs-number">2</span>,<br>&#125;,<br>&#125;)<br><br><span class="hljs-comment">//关联计数</span><br>count := db.Model(&amp;user).Association(<span class="hljs-string">&quot;CreditCards&quot;</span>).Count()<br>fmt.Println(count)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm36.png"></p><h1 id="三、Many-To-Many-多对多"><a href="#三、Many-To-Many-多对多" class="headerlink" title="三、Many To Many 多对多"></a>三、Many To Many 多对多</h1><p>Many to Many 会在两个 model 中添加一张<code>连接表</code>。<br>例如，你有两张表 users 表和 languages 表</p><ul><li>users –用户表</li><li>languages –语言表</li></ul><p>一个 用户可以说多种 语言，多个 用户也可以说一种 语言。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// User 拥有并属于多种 language，`user_languages` 是连接表</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  gorm.Model<br>  Languages []Language <span class="hljs-string">`gorm:&quot;many2many:user_languages;&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Language <span class="hljs-keyword">struct</span> &#123;<br>  gorm.Model<br>  Name <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>当使用 GORM 的 AutoMigrate 为 User 创建表时，GORM 会自动创建连接表。<br>某种意义上这种其实还是<code>一对多</code>的关系，反向引用的形式才是真正多对多的关系。</p></blockquote><h2 id="1、反向引用"><a href="#1、反向引用" class="headerlink" title="1、反向引用"></a>1、反向引用</h2><p>我既可以用 User 创建多条关联，也可以通过 Language 多条关联。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// User 拥有并属于多种 language，`user_languages` 是连接表</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  gorm.Model<br>  Languages []Language <span class="hljs-string">`gorm:&quot;many2many:user_languages;&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Language <span class="hljs-keyword">struct</span> &#123;<br>  gorm.Model<br>  Name <span class="hljs-type">string</span><br>  Users []User <span class="hljs-string">`gorm:&quot;many2many:user_languages;&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db.AutoMigrate(&amp;User&#123;&#125;, &amp;Language&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm37.png"></p><h2 id="2、创建记录"><a href="#2、创建记录" class="headerlink" title="2、创建记录"></a>2、创建记录</h2><ul><li>创建用户拥有两种语言的记录</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">l1 := Language&#123;<br>Name: <span class="hljs-string">&quot;中文&quot;</span>,<br>&#125;<br>l2 := Language&#123;<br>Name: <span class="hljs-string">&quot;英文&quot;</span>,<br>&#125;<br>u1 := User&#123;<br>Languages: []Language&#123;l1, l2&#125;,<br>&#125;<br>db.Create(&amp;u1)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm38.png"></p><p><img src="/img/gorm_associate/gorm39.png"></p><p><img src="/img/gorm_associate/gorm40.png"></p><ul><li>创建外星语被两个用户所使用的记录：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">u := User&#123;&#125;<br>l := Language&#123;<br>Name:  <span class="hljs-string">&quot;外星语&quot;</span>,<br><span class="hljs-comment">//也可以直接指定创建好的记录的主键</span><br>Users: []User&#123;u, User&#123;Model: gorm.Model&#123;ID: <span class="hljs-number">1</span>&#125;&#125;&#125;,<br>&#125;<br>db.Create(&amp;l)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm41.png"><br><img src="/img/gorm_associate/gorm42.png"><br><img src="/img/gorm_associate/gorm43.png"></p><h2 id="3、查找记录"><a href="#3、查找记录" class="headerlink" title="3、查找记录"></a>3、查找记录</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">u := User&#123;&#125;<br>db.Where(<span class="hljs-string">&quot;id = ?&quot;</span>, <span class="hljs-number">1</span>).Find(&amp;u)<br>db.Model(&amp;User&#123;&#125;).Preload(<span class="hljs-string">&quot;Languages&quot;</span>).Find(&amp;u)<br>fmt.Println(u)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm44.png"></p><h2 id="4、关联模式"><a href="#4、关联模式" class="headerlink" title="4、关联模式"></a>4、关联模式</h2><h3 id="1）查询关联"><a href="#1）查询关联" class="headerlink" title="1）查询关联"></a>1）查询关联</h3><p>查询user 对应的关联记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">u := User&#123;&#125;<br>db.Where(<span class="hljs-string">&quot;id = ?&quot;</span>, <span class="hljs-number">2</span>).Find(&amp;u)<br><span class="hljs-keyword">var</span> l []Language<br>db.Model(&amp;u).Association(<span class="hljs-string">&quot;Languages&quot;</span>).Find(&amp;l)<br>fmt.Println(l)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm45.png"></p><h3 id="2）添加关联"><a href="#2）添加关联" class="headerlink" title="2）添加关联"></a>2）添加关联</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">u := User&#123;&#125;<br>db.Where(<span class="hljs-string">&quot;id = ?&quot;</span>, <span class="hljs-number">2</span>).Find(&amp;u)<br>l1 := Language&#123;<br>Name: <span class="hljs-string">&quot;俄语&quot;</span>,<br>&#125;<br>l2 := Language&#123;<br>Name: <span class="hljs-string">&quot;法语&quot;</span>,<br>&#125;<br>db.Model(&amp;u).Association(<span class="hljs-string">&quot;Languages&quot;</span>).Append(&amp;l1, &amp;l2)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm46.png"></p><p><img src="/img/gorm_associate/gorm47.png"></p><blockquote><p>注意：添加关联的同时，不仅连接表会添加新关联记录，关联的结构表也会添加新的记录，除非指定的是表里已存在数据则不会添加。</p></blockquote><h3 id="3）删除关联"><a href="#3）删除关联" class="headerlink" title="3）删除关联"></a>3）删除关联</h3><p>删除关联并不会删除关联的结构表里面的数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">u := User&#123;&#125;<br>db.Where(<span class="hljs-string">&quot;id = ?&quot;</span>, <span class="hljs-number">2</span>).Find(&amp;u)<br>db.Model(&amp;u).Association(<span class="hljs-string">&quot;Languages&quot;</span>).Delete(&amp;Language&#123;<br>Model: gorm.Model&#123;<br>ID: <span class="hljs-number">3</span>,<br>&#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm48.png"></p><h3 id="4）修改-替换-关联"><a href="#4）修改-替换-关联" class="headerlink" title="4）修改(替换)关联"></a>4）修改(替换)关联</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">u := User&#123;&#125;<br>db.Where(<span class="hljs-string">&quot;id = ?&quot;</span>, <span class="hljs-number">2</span>).Find(&amp;u)<br>db.Model(&amp;u).Association(<span class="hljs-string">&quot;Languages&quot;</span>).Replace(&amp;Language&#123;<br>Model: gorm.Model&#123;<br>ID: <span class="hljs-number">3</span>,<br>&#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p>修改前：<br><img src="/img/gorm_associate/gorm49.png"><br>修改后：<br><img src="/img/gorm_associate/gorm50.png"></p><blockquote><p>注意：在多对多使用修改关联会把连接表里面所有关于<code>主表主键与外键关联的记录</code>全部替换掉，慎用此操作。</p></blockquote><h3 id="5）清空关联"><a href="#5）清空关联" class="headerlink" title="5）清空关联"></a>5）清空关联</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">u := User&#123;&#125;<br>db.Where(<span class="hljs-string">&quot;id = ?&quot;</span>, <span class="hljs-number">2</span>).Find(&amp;u)<br>db.Model(&amp;u).Association(<span class="hljs-string">&quot;Languages&quot;</span>).Clear()<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_associate/gorm51.png"></p><h1 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h1><p>一对一、一对多和多对多关系下的CRUD关联操作，在应对复杂的数据表关系时也能更好的应对，本着以实战操作为学习方法，最好结合官方文档上手是最好最正确的。</p><table><thead><tr><th>关联的类型</th><th align="left">描述</th></tr></thead><tbody><tr><td>一对一</td><td align="left">两个表在关联的每一侧只能具有一个记录。<br><br>每个主键值或者与相关表中的所有记录都无关，或者仅与一个记录相关。<br><br>大多数一对一关联是由业务规则强制的，而不是从数据自然流动。 若没有这样的规则，通常可以将两个表相结合，而不会违反任何规范化规则。</td></tr><tr><td>一对多</td><td align="left">主键表只包含一个记录，其与相关表中零个、一个或多个记录相关。</td></tr><tr><td>多对多</td><td align="left">两个表中的每个记录都可以与另一个表中的零个或任意数目个记录相关。 由于关系系统不能直接适应关联，因此这些关联需要第三个表，其称为关联或链接表。</td></tr></tbody></table><p><img src="/img/gorm_associate/gorm52.png"></p><blockquote><p>关联标签以及自定义SQL预加载内容将留到事务中。<br>若有写的错误的或者需要改进的地方，希望能直接指出，再次感谢GVA淼哥的教程！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Gorm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>mysql</tag>
      
      <tag>数据库</tag>
      
      <tag>Gorm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gorm学习（三）基础：迁移(数据库建表以及字段设置)</title>
    <link href="/2022/10/11/gorm-migrate/"/>
    <url>/2022/10/11/gorm-migrate/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>感谢开源项目<a href="https://www.gin-vue-admin.com/">gin-vue-admin</a>，以及<a href="https://www.bilibili.com/video/BV12i4y1x7AG?spm_id_from=333.999.0.0">1010工作室的视频教程</a></p></blockquote><h1 id="一、迁移概念"><a href="#一、迁移概念" class="headerlink" title="一、迁移概念"></a>一、迁移概念</h1><p>在项目开发中，我们可能会随时调整<code>声明的模型</code>，比如添加字段和索引，使用 GORM 的自动迁移功能，可以始终让我们的<code>数据库表结构</code>保持最新。</p><p>此外，GORM 还提供了一些迁移接口的方法，可以帮助我们方便操作数据库表、字段和索引。</p><h1 id="二、AutoMigrate-自动迁移"><a href="#二、AutoMigrate-自动迁移" class="headerlink" title="二、AutoMigrate 自动迁移"></a>二、AutoMigrate 自动迁移</h1><p>AutoMigrate 用于自动迁移你的 <code>schema(模式)</code>，保持你的 schema(模式) 是最新的。</p><blockquote><p><strong>注意：</strong> AutoMigrate 会创建表、缺失的外键、约束、列和索引。 并且会更改现有列的类型，如果大小、精度、是否为空可以更改。 但不会删除未使用的列，以保护您的数据。(只增不减)</p></blockquote><p>在执行 AutoMigrate时，我们需要先声明模型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">uint</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Product <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>Name  <span class="hljs-type">string</span><br>Price <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Order <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>UserID    <span class="hljs-type">int</span><br>ProductID <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>建立数据库连接后，执行 AutoMigrate：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> db *gorm.DB<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-comment">//我这里用到数据库是mysql，需要配置DSN属性[username[:password]@][protocol[(address)]]/dbname[?param1=value1&amp;...&amp;paramN=valueN]</span><br>dsn := <span class="hljs-string">&quot;root:123456@tcp(127.0.0.1:3306)/go_test?charset=utf8&amp;parseTime=True&quot;</span><br>db, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to connect database&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db.AutoMigrate(&amp;User&#123;&#125;)<br>db.AutoMigrate(&amp;User&#123;&#125;, &amp;Product&#123;&#125;, &amp;Order&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_migrate/gorm1.png"></p><h1 id="三、Migrator-接口"><a href="#三、Migrator-接口" class="headerlink" title="三、Migrator 接口"></a>三、Migrator 接口</h1><p>GORM 提供了 Migrator 接口，该接口为每个数据库提供了统一的 API 接口，可用来为您的数据库构建独立迁移，例如：</p><p>SQLite 不支持 ALTER COLUMN、DROP COLUMN，当你试图修改表结构，GORM 将创建一个新表、复制所有数据、删除旧表、重命名新表。</p><p>一些版本的 MySQL 不支持 rename 列，索引。<code>GORM 将基于使用 MySQL 的版本执行不同 SQL。</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Migrator <span class="hljs-keyword">interface</span> &#123;<br>  <span class="hljs-comment">// AutoMigrate</span><br>  AutoMigrate(dst ...<span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span><br><br>  <span class="hljs-comment">// Database</span><br>  CurrentDatabase() <span class="hljs-type">string</span><br>  FullDataTypeOf(*schema.Field) clause.Expr<br><br>  <span class="hljs-comment">// Tables</span><br>  CreateTable(dst ...<span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span><br>  DropTable(dst ...<span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span><br>  HasTable(dst <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">bool</span><br>  RenameTable(oldName, newName <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span><br>  GetTables() (tableList []<span class="hljs-type">string</span>, err <span class="hljs-type">error</span>)<br><br>  <span class="hljs-comment">// Columns</span><br>  AddColumn(dst <span class="hljs-keyword">interface</span>&#123;&#125;, field <span class="hljs-type">string</span>) <span class="hljs-type">error</span><br>  DropColumn(dst <span class="hljs-keyword">interface</span>&#123;&#125;, field <span class="hljs-type">string</span>) <span class="hljs-type">error</span><br>  AlterColumn(dst <span class="hljs-keyword">interface</span>&#123;&#125;, field <span class="hljs-type">string</span>) <span class="hljs-type">error</span><br>  MigrateColumn(dst <span class="hljs-keyword">interface</span>&#123;&#125;, field *schema.Field, columnType ColumnType) <span class="hljs-type">error</span><br>  HasColumn(dst <span class="hljs-keyword">interface</span>&#123;&#125;, field <span class="hljs-type">string</span>) <span class="hljs-type">bool</span><br>  RenameColumn(dst <span class="hljs-keyword">interface</span>&#123;&#125;, oldName, field <span class="hljs-type">string</span>) <span class="hljs-type">error</span><br>  ColumnTypes(dst <span class="hljs-keyword">interface</span>&#123;&#125;) ([]ColumnType, <span class="hljs-type">error</span>)<br><br>  <span class="hljs-comment">// Constraints</span><br>  CreateConstraint(dst <span class="hljs-keyword">interface</span>&#123;&#125;, name <span class="hljs-type">string</span>) <span class="hljs-type">error</span><br>  DropConstraint(dst <span class="hljs-keyword">interface</span>&#123;&#125;, name <span class="hljs-type">string</span>) <span class="hljs-type">error</span><br>  HasConstraint(dst <span class="hljs-keyword">interface</span>&#123;&#125;, name <span class="hljs-type">string</span>) <span class="hljs-type">bool</span><br><br>  <span class="hljs-comment">// Indexes</span><br>  CreateIndex(dst <span class="hljs-keyword">interface</span>&#123;&#125;, name <span class="hljs-type">string</span>) <span class="hljs-type">error</span><br>  DropIndex(dst <span class="hljs-keyword">interface</span>&#123;&#125;, name <span class="hljs-type">string</span>) <span class="hljs-type">error</span><br>  HasIndex(dst <span class="hljs-keyword">interface</span>&#123;&#125;, name <span class="hljs-type">string</span>) <span class="hljs-type">bool</span><br>  RenameIndex(dst <span class="hljs-keyword">interface</span>&#123;&#125;, oldName, newName <span class="hljs-type">string</span>) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1、数据库接口"><a href="#1、数据库接口" class="headerlink" title="1、数据库接口"></a>1、数据库接口</h2><h3 id="1）CurrentDatabase-返回当前使用的数据库名"><a href="#1）CurrentDatabase-返回当前使用的数据库名" class="headerlink" title="1）CurrentDatabase 返回当前使用的数据库名"></a>1）CurrentDatabase 返回当前使用的<code>数据库名</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Migrator().CurrentDatabase()<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_migrate/gorm2.png"></p><h2 id="2、数据表接口"><a href="#2、数据表接口" class="headerlink" title="2、数据表接口"></a>2、数据表接口</h2><blockquote><p>操作数据库表，必须先声明模型。</p></blockquote><h3 id="1）CreateTable-创建数据表"><a href="#1）CreateTable-创建数据表" class="headerlink" title="1）CreateTable 创建数据表"></a>1）CreateTable 创建数据表</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">err := db.Migrator().CreateTable(&amp;User&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;创建数据库表失败，错误:%s\n&quot;</span>, err)<br>  <span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;创建数据库表成功&quot;</span>)<br></code></pre></td></tr></table></figure><p>创建失败：<br><img src="/img/gorm_migrate/gorm3.png"></p><p>创建成功：<br><img src="/img/gorm_migrate/gorm4.png"></p><blockquote><p> 默认情况下，GORM 会约定使用 ID 作为表的主键，可以通过标签 <code>gorm:&quot;primarykey&quot;</code> 将其它字段设为主键。<br>通过将多个字段设为主键，以达到创建复合主键，整型字段设为主键，默认为启用 AutoIncrement，如果需要禁用，使用标签 <code>autoIncrement:false</code>。<br>GORM 约定使用结构体名的<code>复数形式作为表名</code>，不过也可以根据需求修改，可以实现Tabler 接口来更改默认表名，不过这种方式不支持动态变化，它会被缓存下来以便后续使用，如果想要使用动态表名，可以使用Scopes.<br>GORM 约定使用结构体的字段名作为数据表的字段名,默认GORM 对 struct 字段名使用<code>Snake Case</code>命名风格转换成 MySQL 表字段名(需要转换成小写字母)，也可以通过标签 column 修改。</p></blockquote><h3 id="2）HasTable-检查对应的数据表是否存在"><a href="#2）HasTable-检查对应的数据表是否存在" class="headerlink" title="2）HasTable 检查对应的数据表是否存在"></a>2）HasTable 检查对应的数据表是否存在</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">isExist := db.Migrator().HasTable(&amp;User&#123;&#125;)<br><span class="hljs-comment">//isExist := db.Migrator().HasTable(&quot;users&quot;)</span><br><span class="hljs-keyword">if</span> !isExist &#123;<br>fmt.Printf(<span class="hljs-string">&quot;users 表不存在\n&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;users 表存在\n&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_migrate/gorm5.png"></p><h3 id="3）DropTable-如果存在表则删除（删除时会忽略、删除外键约束"><a href="#3）DropTable-如果存在表则删除（删除时会忽略、删除外键约束" class="headerlink" title="3）DropTable 如果存在表则删除（删除时会忽略、删除外键约束)"></a>3）DropTable 如果存在表则删除（删除时会忽略、删除外键约束)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Migrator().DropTable(&amp;User&#123;&#125;)<br><span class="hljs-comment">// err := db.Migrator().DropTable(&quot;users&quot;)</span><br>fmt.Printf(<span class="hljs-string">&quot;users 表删除成功\n&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_migrate/gorm6.png"></p><h3 id="4）RenameTable-重命名表"><a href="#4）RenameTable-重命名表" class="headerlink" title="4）RenameTable 重命名表"></a>4）RenameTable 重命名表</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// db.Migrator().RenameTable(&quot;users&quot;, &quot;user_infos&quot;)</span><br><span class="hljs-comment">//若是users表存在则改名为user_infos表，反之亦然</span><br><span class="hljs-keyword">if</span> b := db.Migrator().HasTable(&amp;User&#123;&#125;); b &#123;<br>db.Migrator().RenameTable(&amp;User&#123;&#125;, &amp;UserInfo&#123;&#125;)<br>fmt.Printf(<span class="hljs-string">&quot;users 表名修改成功\n&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>db.Migrator().RenameTable(&amp;UserInfo&#123;&#125;, &amp;User&#123;&#125;)<br>fmt.Printf(<span class="hljs-string">&quot;user_infos 表名修改成功\n&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_migrate/gorm7.png"></p><blockquote><p>个人推荐用<code>结构体模型</code>来进行以上操作，数据库的结构可以统一固定，这也是迁移的目的。</p></blockquote><h2 id="3、数据表字段接口"><a href="#3、数据表字段接口" class="headerlink" title="3、数据表字段接口"></a>3、数据表字段接口</h2><blockquote><p>操作数据库表字段，必须先声明模型。</p></blockquote><h3 id="1）AddColumn-添加字段"><a href="#1）AddColumn-添加字段" class="headerlink" title="1）AddColumn 添加字段"></a>1）AddColumn 添加字段</h3><p>注意：<br>-必须先声明模型。<br>-数据表不存在的字段名，且结构体字段存在。</p><p>现在的表结构：<br><img src="/img/gorm_migrate/gorm8.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Sex <span class="hljs-type">bool</span><br>&#125;<br>err := db.Migrator().AddColumn(&amp;User&#123;&#125;, <span class="hljs-string">&quot;Sex&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;添加字段错误,err:%s\n&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_migrate/gorm9.png"></p><h3 id="2）DropColumn-删除字段"><a href="#2）DropColumn-删除字段" class="headerlink" title="2）DropColumn 删除字段"></a>2）DropColumn 删除字段</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">err := db.Migrator().DropColumn(&amp;User&#123;&#125;, <span class="hljs-string">&quot;Age&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;删除字段错误,err:%s\n&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_migrate/gorm10.png"></p><h3 id="3）RenameColumn-修改字段名"><a href="#3）RenameColumn-修改字段名" class="headerlink" title="3）RenameColumn 修改字段名"></a>3）RenameColumn 修改字段名</h3><p>注意：<br>-必须先声明模型。<br>-修改的字段名在对应的数据表必须存在，修改的字段名和修改后的字段名必须定义在结构体内。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Name     <span class="hljs-type">string</span><br>UserName <span class="hljs-type">string</span><br>&#125;<br>err := db.Migrator().RenameColumn(&amp;User&#123;&#125;, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;user_name&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;修改字段名错误,err:%s\n&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_migrate/gorm11.png"></p><h3 id="4）HasColumn-查询字段是否存在"><a href="#4）HasColumn-查询字段是否存在" class="headerlink" title="4）HasColumn 查询字段是否存在"></a>4）HasColumn 查询字段是否存在</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">isExistField := db.Migrator().HasColumn(&amp;User&#123;&#125;, <span class="hljs-string">&quot;name&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;name字段是否存在:%t\n&quot;</span>, isExistField)<br>isExistField = db.Migrator().HasColumn(&amp;User&#123;&#125;, <span class="hljs-string">&quot;user_name&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;user_name:%t\n&quot;</span>, isExistField)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_migrate/gorm12.png"></p><h2 id="4、-数据库表的索引接口"><a href="#4、-数据库表的索引接口" class="headerlink" title="4、 数据库表的索引接口"></a>4、 数据库表的索引接口</h2><h3 id="1）CreateIndex-为字段创建索引"><a href="#1）CreateIndex-为字段创建索引" class="headerlink" title="1）CreateIndex 为字段创建索引"></a>1）CreateIndex 为字段创建索引</h3><p>注意：<br>-必须先声明模型。<br>-必须先在声明模型中使用标签<code>gorm:index</code>定义索引。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;size:255;index:idx_name,unique&quot;`</span><br>&#125;<br><span class="hljs-comment">// 为 Name 字段创建索引,两种方法都可以</span><br>db.Migrator().CreateIndex(&amp;User&#123;&#125;, <span class="hljs-string">&quot;Name&quot;</span>)<br>db.Migrator().CreateIndex(&amp;User&#123;&#125;, <span class="hljs-string">&quot;idx_name&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_migrate/gorm13.png"></p><h3 id="2）DropIndex-为字段删除索引"><a href="#2）DropIndex-为字段删除索引" class="headerlink" title="2）DropIndex 为字段删除索引"></a>2）DropIndex 为字段删除索引</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Migrator().DropIndex(&amp;User&#123;&#125;, <span class="hljs-string">&quot;Name&quot;</span>)<br>db.Migrator().DropIndex(&amp;User&#123;&#125;, <span class="hljs-string">&quot;idx_name&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_migrate/gorm14.png"></p><h3 id="3）HasIndex-检查索引是否存在"><a href="#3）HasIndex-检查索引是否存在" class="headerlink" title="3）HasIndex 检查索引是否存在"></a>3）HasIndex 检查索引是否存在</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">isExists := db.Migrator().HasIndex(&amp;User&#123;&#125;, <span class="hljs-string">&quot;idx_name&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;idex_name是否存在:%t\n&quot;</span>, isExists)<br><br>db.Migrator().CreateIndex(&amp;User&#123;&#125;, <span class="hljs-string">&quot;idx_name&quot;</span>)<br>isExists = db.Migrator().HasIndex(&amp;User&#123;&#125;, <span class="hljs-string">&quot;idx_name&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;idex_name是否存在:%t\n&quot;</span>, isExists)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_migrate/gorm15.png"></p><h3 id="4）RenameIndex-修改索引名"><a href="#4）RenameIndex-修改索引名" class="headerlink" title="4）RenameIndex 修改索引名"></a>4）RenameIndex 修改索引名</h3><p>注意：<br>-必须先声明模型。<br>-必须先在声明模型中使用标签<code>gorm:index</code>定义索引。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>Name  <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;size:255;index:idx_name,unique&quot;`</span><br>Name2 <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;size:255;index:idx_name_2,unique&quot;`</span><br>&#125;<br>db.Migrator().RenameIndex(&amp;User&#123;&#125;, <span class="hljs-string">&quot;idx_name&quot;</span>, <span class="hljs-string">&quot;idx_name_2&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/gorm_migrate/gorm16.png"></p><h1 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h1><p>Gorm的迁移接口功能很丰富，AutoMigrate 就适用于大多数的迁移，如果需要更加个性化的迁移工具 ，GORM 提供的一个通用数据库接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// returns `*sql.DB`</span><br>db.DB()<br></code></pre></td></tr></table></figure><p>迁移接口的方法，确实给开发工作带来了方便，但是个人建议除非特殊原因，否则尽量通过<code>在声明模型中修改数据库表的字段和索引</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Gorm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>mysql</tag>
      
      <tag>数据库</tag>
      
      <tag>Gorm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gorm学习（二）基础：CRUD接口(数据库增删改查操作)</title>
    <link href="/2022/10/11/gorm_CRUD/"/>
    <url>/2022/10/11/gorm_CRUD/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>感谢开源项目<a href="https://www.gin-vue-admin.com/">gin-vue-admin</a>，以及<a href="https://www.bilibili.com/video/BV12i4y1x7AG?spm_id_from=333.999.0.0">1010工作室的视频教程</a></p></blockquote><h1 id="一、创建"><a href="#一、创建" class="headerlink" title="一、创建"></a>一、创建</h1><p>GORM里的创建(Create方法)，也就是数据库插入语句(Insert语句)，可以创建单条或者多条，指定字段创建等</p><h2 id="1、Create方法"><a href="#1、Create方法" class="headerlink" title="1、Create方法"></a>1、Create方法</h2><h3 id="1）创建单条记录"><a href="#1）创建单条记录" class="headerlink" title="1）创建单条记录"></a>1）创建单条记录</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">user := User&#123;Name: <span class="hljs-string">&quot;linzy&quot;</span>, Age: <span class="hljs-number">23</span>, Birthday: time.Now()&#125;<br><br>result := db.Create(&amp;user) <span class="hljs-comment">// 通过数据的指针来创建</span><br><br>user.ID             <span class="hljs-comment">// 返回插入数据的主键</span><br>result.Error        <span class="hljs-comment">// 返回 error</span><br>result.RowsAffected <span class="hljs-comment">// 返回插入记录的条数</span><br></code></pre></td></tr></table></figure><h3 id="2）创建多条记录"><a href="#2）创建多条记录" class="headerlink" title="2）创建多条记录"></a>2）创建多条记录</h3><p>要有效地插入大量记录，需要将一个 <strong>slice</strong> 切片传递给 <strong>Create</strong> 方法。 将切片数据传递给 Create 方法，GORM 将生成一个单一的 SQL 语句来插入所有数据，并回填主键的值，钩子方法也会被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> users = []User&#123;&#123;Name: <span class="hljs-string">&quot;linzy1&quot;</span>&#125;, &#123;Name: <span class="hljs-string">&quot;linzy2&quot;</span>&#125;, &#123;Name: <span class="hljs-string">&quot;linzy3&quot;</span>&#125;&#125;<br>db.Create(&amp;users)<br><br><span class="hljs-keyword">for</span> _, user := <span class="hljs-keyword">range</span> users &#123;<br>user.ID <span class="hljs-comment">// 1,2,3</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3）指定字段创建记录"><a href="#3）指定字段创建记录" class="headerlink" title="3）指定字段创建记录"></a>3）指定字段创建记录</h3><ul><li>用 <strong>Select</strong> 方法指定需要创建的字段</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Select(<span class="hljs-string">&quot;Name&quot;</span>, <span class="hljs-string">&quot;Age&quot;</span>, <span class="hljs-string">&quot;CreatedAt&quot;</span>).Create(&amp;user)<br><span class="hljs-comment">// INSERT INTO `users` (`name`,`age`,`created_at`) VALUES (&quot;linzy&quot;, 23, &quot;2022-07-08 11:05:21.775&quot;)</span><br></code></pre></td></tr></table></figure><ul><li>用 Omit 方法会更新未给出的字段创建记录。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Omit(<span class="hljs-string">&quot;Name&quot;</span>, <span class="hljs-string">&quot;Age&quot;</span>, <span class="hljs-string">&quot;CreatedAt&quot;</span>).Create(&amp;user)<br><span class="hljs-comment">// INSERT INTO `users` (`birthday`,`updated_at`) VALUES (&quot;2022-07-04 00:00:00.000&quot;, &quot;2022-07-08 11:05:21.775&quot;)</span><br></code></pre></td></tr></table></figure><h2 id="2、CreateInBatches"><a href="#2、CreateInBatches" class="headerlink" title="2、CreateInBatches"></a>2、CreateInBatches</h2><p> 使用 <strong>CreateInBatches</strong> 创建时，你还可以指定创建的数量，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> 用户 = []User&#123;name: <span class="hljs-string">&quot;linzy_1&quot;</span>&#125;, ...., &#123;Name: <span class="hljs-string">&quot;linzy_10000&quot;</span>&#125;&#125;<br><br><span class="hljs-comment">// 数量为 100</span><br>db.CreateInBatches(用户, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><blockquote><p>Upsert 和 Create With Associations 也支持批量插入</p></blockquote><h2 id="3、创建钩子"><a href="#3、创建钩子" class="headerlink" title="3、创建钩子"></a>3、创建钩子</h2><p>GORM 允许用户定义的钩子有 <strong>BeforeSave</strong>, <strong>BeforeCreate</strong>, <strong>AfterSave</strong>, <strong>AfterCreate</strong> 创建记录时将调用这些钩子方法</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span></span> BeforeCreate(tx *gorm.DB) (err <span class="hljs-type">error</span>) &#123;<br>u.UUID = uuid.New()<br><br>    <span class="hljs-keyword">if</span> u.Role == <span class="hljs-string">&quot;admin&quot;</span> &#123;<br>       <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;invalid role&quot;</span>)<br>   &#125;<br>  <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果您想跳过 <strong>钩子</strong> 方法，您可以使用 <strong>SkipHooks</strong> 会话模式，例如：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//SkipHooks为true表示当前方法 不执行钩子方法</span><br>DB.Session(&amp;gorm.Session&#123;SkipHooks: <span class="hljs-literal">true</span>&#125;).Create(&amp;user)<br><br>DB.Session(&amp;gorm.Session&#123;SkipHooks: <span class="hljs-literal">true</span>&#125;).Create(&amp;users)<br><br>DB.Session(&amp;gorm.Session&#123;SkipHooks: <span class="hljs-literal">true</span>&#125;).CreateInBatches(users, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><h2 id="4、根据-Map-创建"><a href="#4、根据-Map-创建" class="headerlink" title="4、根据 Map 创建"></a>4、根据 Map 创建</h2><p>通常我们用GORM都是用<strong>结构体 struct</strong> 来创建记录，而<strong>GORM</strong> 也支持根据 <strong>map[string]interface{}</strong> 和 <strong>[]map[string]interface{}{}</strong> 创建记录，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//创建单条记录</span><br>db.Model(&amp;User&#123;&#125;).Create(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;linzy&quot;</span>, <span class="hljs-string">&quot;Age&quot;</span>: <span class="hljs-number">23</span>,<br>&#125;)<br><br><span class="hljs-comment">//创建多条记录</span><br>db.Model(&amp;User&#123;&#125;).Create([]<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>&#123;<span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;linzy_1&quot;</span>, <span class="hljs-string">&quot;Age&quot;</span>: <span class="hljs-number">23</span>&#125;,<br>&#123;<span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;linzy_2&quot;</span>, <span class="hljs-string">&quot;Age&quot;</span>: <span class="hljs-number">66</span>&#125;,<br>&#123;<span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;linzy_3&quot;</span>, <span class="hljs-string">&quot;Age&quot;</span>: <span class="hljs-number">88</span>&#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：根据 map 创建记录时，<strong>association</strong> (查找关联方法)不会被调用，且主键也不会自动填充</p></blockquote><h2 id="5、高级选项"><a href="#5、高级选项" class="headerlink" title="5、高级选项"></a>5、高级选项</h2><h3 id="1）关联创建"><a href="#1）关联创建" class="headerlink" title="1）关联创建"></a>1）关联创建</h3><p>创建关联数据时，如果关联值是非零值，这些关联会被 upsert，且它们的 <strong>Hook</strong> 钩子方法也会被调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> CreditCard <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>Number <span class="hljs-type">string</span><br>UserID <span class="hljs-type">uint</span><br>&#125;<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>Name       <span class="hljs-type">string</span><br>CreditCard CreditCard <span class="hljs-comment">// 一对一的关系</span><br>&#125;<br><br>db.Create(&amp;User&#123;<br>Name:       <span class="hljs-string">&quot;linzy&quot;</span>,<br>CreditCard: CreditCard&#123;Number: <span class="hljs-string">&quot;123456789&quot;</span>&#125;,<br>&#125;)<br><span class="hljs-comment">// INSERT INTO `users` ...</span><br><span class="hljs-comment">// INSERT INTO `credit_cards` ...</span><br></code></pre></td></tr></table></figure><blockquote><p>您也可以通过 <strong>Select</strong>、 <strong>Omit</strong> 跳过关联保存，例如：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Omit(<span class="hljs-string">&quot;CreditCard&quot;</span>).Create(&amp;user)<br><br><span class="hljs-comment">// 跳过所有关联</span><br>db.Omit(clause.Associations).Create(&amp;user)<br></code></pre></td></tr></table></figure><h3 id="2）默认值"><a href="#2）默认值" class="headerlink" title="2）默认值"></a>2）默认值</h3><p>您可以通过标签 <strong>default</strong> 为字段定义默认值，如：</p><blockquote><p>插入记录到数据库时，默认值 <em>会被用于</em> 填充值为 <strong>零值</strong> 的字段</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">int64</span><br>Name <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;default:linzy&quot;`</span><br>Age  <span class="hljs-type">int64</span>  <span class="hljs-string">`gorm:&quot;default:23&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>： 像 <strong>0</strong>、**’’<strong>、</strong>false** 等零值，不会将这些字段定义的默认值保存到数据库。您需要使用指针类型或 <strong>Scanner</strong>&#x2F;<strong>Valuer</strong> 来避免这个问题，例如：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>Name   <span class="hljs-type">string</span><br>Age    *<span class="hljs-type">int</span>         <span class="hljs-string">`gorm:&quot;default:23&quot;`</span><br>Active sql.NullBool <span class="hljs-string">`gorm:&quot;default:true&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>： 若要数据库有默认、虚拟 &#x2F; 生成的值，你必须为字段设置 default 标签。若要在迁移时跳过默认值定义，你可以使用 default:(-)，例如：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>ID        <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;default:uuid_generate_v3()&quot;`</span> <span class="hljs-comment">// 数据库函数</span><br>FirstName <span class="hljs-type">string</span><br>LastName  <span class="hljs-type">string</span><br>Age       <span class="hljs-type">uint8</span><br>FullName  <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;-&gt;;type:GENERATED ALWAYS AS (concat(firstname,&#x27; &#x27;,lastname));default:(-);`</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、查询"><a href="#二、查询" class="headerlink" title="二、查询"></a>二、查询</h1><p>GORM里的查询(Find方法)，也就是数据库查询语句(Select语句)，可以查询所有数据、查询指定条件数据，查询首条数据，查询最后一条数据</p><h2 id="1、查询单条数据"><a href="#1、查询单条数据" class="headerlink" title="1、查询单条数据"></a>1、查询单条数据</h2><p>GORM 提供了 <strong>First</strong>、<strong>Take</strong>、<strong>Last</strong> 方法，以便从数据库中检索单个对象。当查询数据库时它添加了 <strong>LIMIT 1</strong> 条件，且没有找到记录时，它会返回 <strong>ErrRecordNotFound</strong> 错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 获取第一条记录（主键升序）</span><br>db.First(&amp;user)<br><span class="hljs-comment">// SELECT * FROM users ORDER BY id LIMIT 1;</span><br><br><span class="hljs-comment">// 获取一条记录，没有指定排序字段</span><br>db.Take(&amp;user)<br><span class="hljs-comment">// SELECT * FROM users LIMIT 1;</span><br><br><span class="hljs-comment">// 获取最后一条记录（主键降序）</span><br>db.Last(&amp;user)<br><span class="hljs-comment">// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span><br><br>result := db.First(&amp;user)<br>result.RowsAffected <span class="hljs-comment">// 返回找到的记录数</span><br>result.Error        <span class="hljs-comment">// returns error</span><br><br><span class="hljs-comment">// 检查 ErrRecordNotFound 错误</span><br>errors.Is(result.Error, gorm.ErrRecordNotFound)<br></code></pre></td></tr></table></figure><ul><li><code>First、Last 方法会根据主键查找到第一个、最后一个记录， 它仅在通过结构体 struct 或提供 model 值进行查询时才起作用。</code> 如果 model 类型没有定义主键，则按第一个字段排序，例如：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> user User<br><span class="hljs-comment">// 可以</span><br>db.First(&amp;user)<br><span class="hljs-comment">// SELECT * FROM `users` ORDER BY `users`.`id` LIMIT 1</span><br><br><span class="hljs-comment">// 可以</span><br>result := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;&#125;<br>db.Model(&amp;User&#123;&#125;).First(&amp;result)<br><span class="hljs-comment">// SELECT * FROM `users` ORDER BY `users`.`id` LIMIT 1</span><br><br><span class="hljs-comment">// 不行</span><br>result := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;&#125;<br>db.Table(<span class="hljs-string">&quot;users&quot;</span>).First(&amp;result)<br><br><span class="hljs-comment">// 但可以配合 Take 使用</span><br>result := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;&#125;<br>db.Table(<span class="hljs-string">&quot;users&quot;</span>).Take(&amp;result)<br><br><span class="hljs-comment">// 根据第一个字段排序</span><br><span class="hljs-keyword">type</span> Language <span class="hljs-keyword">struct</span> &#123;<br>Code <span class="hljs-type">string</span><br>Name <span class="hljs-type">string</span><br>&#125;<br>db.First(&amp;Language&#123;&#125;)<br><span class="hljs-comment">// SELECT * FROM `languages` ORDER BY `languages`.`code` LIMIT 1</span><br></code></pre></td></tr></table></figure><h2 id="2、根据主键查询"><a href="#2、根据主键查询" class="headerlink" title="2、根据主键查询"></a>2、根据主键查询</h2><p>您可以使用 <strong>内联条件</strong> 来检索对象。 传入字符串参数时注意避免 SQL 注入问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">db.First(&amp;user, <span class="hljs-number">10</span>)<br><span class="hljs-comment">// SELECT * FROM users WHERE id = 10;</span><br><br>db.First(&amp;user, <span class="hljs-string">&quot;10&quot;</span>)<br><span class="hljs-comment">// SELECT * FROM users WHERE id = 10;</span><br><br>db.Find(&amp;users, []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;)<br><span class="hljs-comment">// SELECT * FROM users WHERE id IN (1,2,3);</span><br></code></pre></td></tr></table></figure><h2 id="3、查询全部数据"><a href="#3、查询全部数据" class="headerlink" title="3、查询全部数据"></a>3、查询全部数据</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 获取全部记录</span><br>result := db.Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users;</span><br><br>result.RowsAffected <span class="hljs-comment">// 返回找到的记录数，相当于 `len(users)`</span><br>result.Error        <span class="hljs-comment">// returns error</span><br></code></pre></td></tr></table></figure><h2 id="4、条件查询"><a href="#4、条件查询" class="headerlink" title="4、条件查询"></a>4、条件查询</h2><p>条件查询即查询满足条件的所有数据，GORM框架给用户提供了 String条件 、Struct &amp; Map 条件、内联条件 、Not 条件以及 Or 条件查询方式</p><h3 id="1）String条件"><a href="#1）String条件" class="headerlink" title="1）String条件"></a>1）String条件</h3><p>通过Where方法，对String里的？进行填充，来完成条件查询</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 获取第一条匹配的记录</span><br>db.Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>).First(&amp;user)<br><span class="hljs-comment">// SELECT * FROM users WHERE name = &#x27;linzy&#x27; ORDER BY id LIMIT 1;</span><br><br><span class="hljs-comment">// 获取全部匹配的记录</span><br>db.Where(<span class="hljs-string">&quot;name &lt;&gt; ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users WHERE name &lt;&gt; &#x27;linzy&#x27;;</span><br><br><span class="hljs-comment">// IN</span><br>db.Where(<span class="hljs-string">&quot;name IN ?&quot;</span>, []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;linzy&quot;</span>, <span class="hljs-string">&quot;linzy2&quot;</span>&#125;).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users WHERE name IN (&#x27;linzy&#x27;,&#x27;linzy2&#x27;);</span><br><br><span class="hljs-comment">// LIKE</span><br>db.Where(<span class="hljs-string">&quot;name LIKE ?&quot;</span>, <span class="hljs-string">&quot;%in%&quot;</span>).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users WHERE name LIKE &#x27;%in%&#x27;;</span><br><br><span class="hljs-comment">// AND</span><br>db.Where(<span class="hljs-string">&quot;name = ? AND age &gt;= ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users WHERE name = &#x27;linzy&#x27; AND age &gt;= 22;</span><br><br><span class="hljs-comment">// Time</span><br>db.Where(<span class="hljs-string">&quot;updated_at &gt; ?&quot;</span>, lastWeek).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users WHERE updated_at &gt; &#x27;2000-01-01 00:00:00&#x27;;</span><br><br><span class="hljs-comment">// BETWEEN</span><br>db.Where(<span class="hljs-string">&quot;created_at BETWEEN ? AND ?&quot;</span>, lastWeek, today).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users WHERE created_at BETWEEN &#x27;2000-01-01 00:00:00&#x27; AND &#x27;2000-01-08 00:00:00&#x27;;</span><br></code></pre></td></tr></table></figure><h3 id="2）Struct-amp-Map-条件"><a href="#2）Struct-amp-Map-条件" class="headerlink" title="2）Struct &amp; Map 条件"></a>2）Struct &amp; Map 条件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Struct</span><br>db.Where(&amp;User&#123;Name: <span class="hljs-string">&quot;linzy&quot;</span>, Age: <span class="hljs-number">20</span>&#125;).First(&amp;user)<br><span class="hljs-comment">// SELECT * FROM users WHERE name = &quot;linzy&quot; AND age = 20 ORDER BY id LIMIT 1;</span><br><br><span class="hljs-comment">// Map</span><br>db.Where(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;linzy&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">20</span>&#125;).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users WHERE name = &quot;linzy&quot; AND age = 20;</span><br><br><span class="hljs-comment">// 主键切片条件</span><br>db.Where([]<span class="hljs-type">int64</span>&#123;<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>&#125;).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users WHERE id IN (20, 21, 22);</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>： 当使用结构作为条件查询时，GORM 只会查询非零值字段。这意味着如果您的字段值为 <strong>0</strong>、**’’<strong>、</strong>false** 或其他 <strong>零值</strong>，该字段不会被用于构建查询条件，例如：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Where(&amp;User&#123;Name: <span class="hljs-string">&quot;linzy&quot;</span>, Age: <span class="hljs-number">0</span>&#125;).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users WHERE name = &quot;linzy&quot;;</span><br></code></pre></td></tr></table></figure><blockquote><p>您可以使用 map 来构建查询条件，例如：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Where(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;linzy&quot;</span>, <span class="hljs-string">&quot;Age&quot;</span>: <span class="hljs-number">0</span>&#125;).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users WHERE name = &quot;linzy&quot; AND age = 0;</span><br></code></pre></td></tr></table></figure><h3 id="3）内联条件"><a href="#3）内联条件" class="headerlink" title="3）内联条件"></a>3）内联条件</h3><p>用法跟 <strong>Where</strong> 方法一样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SELECT * FROM users WHERE id = 23;</span><br><span class="hljs-comment">// 根据主键获取记录，如果是非整型主键</span><br>db.First(&amp;user, <span class="hljs-string">&quot;id = ?&quot;</span>, <span class="hljs-string">&quot;string_primary_key&quot;</span>)<br><span class="hljs-comment">// SELECT * FROM users WHERE id = &#x27;string_primary_key&#x27;;</span><br><br><span class="hljs-comment">// Plain SQL</span><br>db.Find(&amp;user, <span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>)<br><span class="hljs-comment">// SELECT * FROM users WHERE name = &quot;linzy&quot;;</span><br><br>db.Find(&amp;users, <span class="hljs-string">&quot;name &lt;&gt; ? AND age &gt; ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>, <span class="hljs-number">20</span>)<br><span class="hljs-comment">// SELECT * FROM users WHERE name &lt;&gt; &quot;linzy&quot; AND age &gt; 20;</span><br><br><span class="hljs-comment">// Struct</span><br>db.Find(&amp;users, User&#123;Age: <span class="hljs-number">20</span>&#125;)<br><span class="hljs-comment">// SELECT * FROM users WHERE age = 20;</span><br><br><span class="hljs-comment">// Map</span><br>db.Find(&amp;users, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">20</span>&#125;)<br><span class="hljs-comment">// SELECT * FROM users WHERE age = 20;</span><br></code></pre></td></tr></table></figure><h3 id="4）Not-条件"><a href="#4）Not-条件" class="headerlink" title="4）Not 条件"></a>4）Not 条件</h3><p>Not在sql语句中是一个逻辑运算符，取反的用处，<strong>真为假</strong>，<strong>假为真</strong>，语句用法跟 <strong>Where</strong> 方法一样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Not(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>).First(&amp;user)<br><span class="hljs-comment">// SELECT * FROM users WHERE NOT name = &quot;linzy&quot; ORDER BY id LIMIT 1;</span><br><br><span class="hljs-comment">// Not In</span><br>db.Not(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;name&quot;</span>: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;linzy&quot;</span>, <span class="hljs-string">&quot;linzy 2&quot;</span>&#125;&#125;).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users WHERE name NOT IN (&quot;linzy&quot;, &quot;linzy 2&quot;);</span><br><br><span class="hljs-comment">// Struct</span><br>db.Not(User&#123;Name: <span class="hljs-string">&quot;linzy&quot;</span>, Age: <span class="hljs-number">18</span>&#125;).First(&amp;user)<br><span class="hljs-comment">// SELECT * FROM users WHERE name &lt;&gt; &quot;linzy&quot; AND age &lt;&gt; 18 ORDER BY id LIMIT 1;</span><br><br><span class="hljs-comment">// 不在主键切片中的记录</span><br>db.Not([]<span class="hljs-type">int64</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;).First(&amp;user)<br><span class="hljs-comment">// SELECT * FROM users WHERE id NOT IN (1,2,3) ORDER BY id LIMIT 1;</span><br></code></pre></td></tr></table></figure><h3 id="5）Or条件"><a href="#5）Or条件" class="headerlink" title="5）Or条件"></a>5）Or条件</h3><p>在 <strong>Where 方法</strong>和 <strong>内联条件</strong> 存在多个条件的时候都是用AND联系，表示条件都必须满足的数据，那我们如果只需要满足其中一种条件呢，那就需要 <strong>Or条件</strong> 了，语句用法跟 <strong>Where</strong> 方法一样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Where(<span class="hljs-string">&quot;role = ?&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>).Or(<span class="hljs-string">&quot;role = ?&quot;</span>, <span class="hljs-string">&quot;super_admin&quot;</span>).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users WHERE role = &#x27;admin&#x27; OR role = &#x27;super_admin&#x27;;</span><br><br><span class="hljs-comment">// Struct</span><br>db.Where(<span class="hljs-string">&quot;name = &#x27;linzy&#x27;&quot;</span>).Or(User&#123;Name: <span class="hljs-string">&quot;linzy 2&quot;</span>, Age: <span class="hljs-number">18</span>&#125;).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users WHERE name = &#x27;linzy&#x27; OR (name = &#x27;linzy 2&#x27; AND age = 18);</span><br><br><span class="hljs-comment">// Map</span><br>db.Where(<span class="hljs-string">&quot;name = &#x27;linzy&#x27;&quot;</span>).Or(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;linzy 2&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>&#125;).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users WHERE name = &#x27;linzy&#x27; OR (name = &#x27;linzy 2&#x27; AND age = 18);</span><br></code></pre></td></tr></table></figure><h2 id="5、选择特定字段"><a href="#5、选择特定字段" class="headerlink" title="5、选择特定字段"></a>5、选择特定字段</h2><h3 id="1）Select"><a href="#1）Select" class="headerlink" title="1）Select"></a>1）Select</h3><p>选择您想从数据库中检索的字段，默认情况下会选择全部字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Select(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>).Find(&amp;users)<br><span class="hljs-comment">// SELECT name, age FROM users;</span><br><br>db.Select([]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>&#125;).Find(&amp;users)<br><span class="hljs-comment">// SELECT name, age FROM users;</span><br><br>db.Table(<span class="hljs-string">&quot;users&quot;</span>).Select(<span class="hljs-string">&quot;COALESCE(age,?)&quot;</span>, <span class="hljs-number">42</span>).Rows()<br><span class="hljs-comment">// SELECT COALESCE(age,&#x27;42&#x27;) FROM users;</span><br></code></pre></td></tr></table></figure><h3 id="2）结构体智能选择字段"><a href="#2）结构体智能选择字段" class="headerlink" title="2）结构体智能选择字段"></a>2）结构体智能选择字段</h3><p>GORM 允许通过 <code>Select </code>方法选择特定的字段，如果在应用程序中经常使用Select获取特定的字段，你也可以定义一个较小的结构体，以实现调用 API 时自动选择特定的字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  ID     <span class="hljs-type">uint</span><br>  Name   <span class="hljs-type">string</span><br>  Age    <span class="hljs-type">int</span><br>  Gender <span class="hljs-type">string</span><br>  <span class="hljs-comment">// 假设后面还有几百个字段...</span><br>&#125;<br><br><span class="hljs-keyword">type</span> APIUser <span class="hljs-keyword">struct</span> &#123;<br>  ID   <span class="hljs-type">uint</span><br>  Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 查询时会自动选择 `id`, `name` 字段</span><br>db.Model(&amp;User&#123;&#125;).Limit(<span class="hljs-number">10</span>).Find(&amp;APIUser&#123;&#125;)<br><span class="hljs-comment">// SELECT `id`, `name` FROM `users` LIMIT 10</span><br></code></pre></td></tr></table></figure><h2 id="6、Order排序"><a href="#6、Order排序" class="headerlink" title="6、Order排序"></a>6、Order排序</h2><p>指定从数据库检索记录时的排序方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Order(<span class="hljs-string">&quot;age desc, name&quot;</span>).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users ORDER BY age desc, name;</span><br><br><span class="hljs-comment">// 多个 order</span><br>db.Order(<span class="hljs-string">&quot;age desc&quot;</span>).Order(<span class="hljs-string">&quot;name&quot;</span>).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users ORDER BY age desc, name;</span><br><br>db.Clauses(clause.OrderBy&#123;<br>Expression: clause.Expr&#123;SQL: <span class="hljs-string">&quot;FIELD(id,?)&quot;</span>, Vars: []<span class="hljs-keyword">interface</span>&#123;&#125;&#123;[]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;&#125;, WithoutParentheses: <span class="hljs-literal">true</span>&#125;,<br>&#125;).Find(&amp;User&#123;&#125;)<br><span class="hljs-comment">// SELECT * FROM users ORDER BY FIELD(id,1,2,3)</span><br></code></pre></td></tr></table></figure><h2 id="7、Limit-amp-Offset"><a href="#7、Limit-amp-Offset" class="headerlink" title="7、Limit &amp; Offset"></a>7、Limit &amp; Offset</h2><ul><li><strong>Limit</strong> 指定获取记录的最大数量 </li><li><strong>Offset</strong> 指定在开始返回记录之前要跳过的记录数量</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Limit(<span class="hljs-number">3</span>).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users LIMIT 3;</span><br><br><span class="hljs-comment">// 通过 -1 消除 Limit 条件</span><br>db.Limit(<span class="hljs-number">10</span>).Find(&amp;users1).Limit(<span class="hljs-number">-1</span>).Find(&amp;users2)<br><span class="hljs-comment">// SELECT * FROM users LIMIT 10; (users1)</span><br><span class="hljs-comment">// SELECT * FROM users; (users2)</span><br><br>db.Offset(<span class="hljs-number">3</span>).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users OFFSET 3;</span><br><br>db.Limit(<span class="hljs-number">10</span>).Offset(<span class="hljs-number">5</span>).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users OFFSET 5 LIMIT 10;</span><br><br><span class="hljs-comment">// 通过 -1 消除 Offset 条件</span><br>db.Offset(<span class="hljs-number">10</span>).Find(&amp;users1).Offset(<span class="hljs-number">-1</span>).Find(&amp;users2)<br><span class="hljs-comment">// SELECT * FROM users OFFSET 10; (users1)</span><br><span class="hljs-comment">// SELECT * FROM users; (users2)</span><br></code></pre></td></tr></table></figure><h2 id="8、Group-amp-Having"><a href="#8、Group-amp-Having" class="headerlink" title="8、Group &amp; Having"></a>8、Group &amp; Having</h2><ul><li><strong>Group</strong> 指定字段进行分组</li><li><strong>Having</strong> 指定字段分组后的条件查询</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> result <span class="hljs-keyword">struct</span> &#123;<br>Date  time.Time<br>Total <span class="hljs-type">int</span><br>&#125;<br>  <br>db.Model(&amp;User&#123;&#125;).Select(<span class="hljs-string">&quot;name, sum(age) as total&quot;</span>).Where(<span class="hljs-string">&quot;name LIKE ?&quot;</span>, <span class="hljs-string">&quot;group%&quot;</span>).Group(<span class="hljs-string">&quot;name&quot;</span>).First(&amp;result)<br><span class="hljs-comment">// SELECT name, sum(age) as total FROM `users` WHERE name LIKE &quot;group%&quot; GROUP BY `name`</span><br>  <br>db.Model(&amp;User&#123;&#125;).Select(<span class="hljs-string">&quot;name, sum(age) as total&quot;</span>).Group(<span class="hljs-string">&quot;name&quot;</span>).Having(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;group&quot;</span>).Find(&amp;result)<br><span class="hljs-comment">// SELECT name, sum(age) as total FROM `users` GROUP BY `name` HAVING name = &quot;group&quot;</span><br>  <br>rows, err := db.Table(<span class="hljs-string">&quot;orders&quot;</span>).Select(<span class="hljs-string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="hljs-string">&quot;date(created_at)&quot;</span>).Rows()<br><span class="hljs-keyword">for</span> rows.Next() &#123;<br>...<br> &#125;<br>  <br>rows, err := db.Table(<span class="hljs-string">&quot;orders&quot;</span>).Select(<span class="hljs-string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="hljs-string">&quot;date(created_at)&quot;</span>).Having(<span class="hljs-string">&quot;sum(amount) &gt; ?&quot;</span>, <span class="hljs-number">100</span>).Rows()<br><span class="hljs-keyword">for</span> rows.Next() &#123;<br>...<br>&#125;<br>  <br><span class="hljs-keyword">type</span> Result <span class="hljs-keyword">struct</span> &#123;<br>Date  time.Time<br>Total <span class="hljs-type">int64</span><br>&#125;<br>db.Table(<span class="hljs-string">&quot;orders&quot;</span>).Select(<span class="hljs-string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="hljs-string">&quot;date(created_at)&quot;</span>).Having(<span class="hljs-string">&quot;sum(amount) &gt; ?&quot;</span>, <span class="hljs-number">100</span>).Scan(&amp;results)<br></code></pre></td></tr></table></figure><h2 id="9、Distinct去重"><a href="#9、Distinct去重" class="headerlink" title="9、Distinct去重"></a>9、Distinct去重</h2><p>从模型中选择不相同的值，简而言之，把选定的字段里重复数据去掉，只留下一条</p><blockquote><p>Distinct 也可以配合 <strong>Pluck</strong>, <strong>Count</strong> 使用</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Distinct(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>).Order(<span class="hljs-string">&quot;name, age desc&quot;</span>).Find(&amp;results)<br></code></pre></td></tr></table></figure><h2 id="10、Joins连接"><a href="#10、Joins连接" class="headerlink" title="10、Joins连接"></a>10、Joins连接</h2><p>数据空的连接操作，有左连接(left join)，右连接(right join)，全连接(outer join)、内连接(inner join)，指定 Joins 条件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> result <span class="hljs-keyword">struct</span> &#123;<br>Name  <span class="hljs-type">string</span><br>Email <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//左连接</span><br>db.Model(&amp;User&#123;&#125;).Select(<span class="hljs-string">&quot;users.name, emails.email&quot;</span>).Joins(<span class="hljs-string">&quot;left join emails on emails.user_id = users.id&quot;</span>).Scan(&amp;result&#123;&#125;)<br><span class="hljs-comment">// SELECT users.name, emails.email FROM `users` left join emails on emails.user_id = users.id</span><br><br>rows, err := db.Table(<span class="hljs-string">&quot;users&quot;</span>).Select(<span class="hljs-string">&quot;users.name, emails.email&quot;</span>).Joins(<span class="hljs-string">&quot;left join emails on emails.user_id = users.id&quot;</span>).Rows()<br><span class="hljs-keyword">for</span> rows.Next() &#123;<br>  ...<br>&#125;<br><br>db.Table(<span class="hljs-string">&quot;users&quot;</span>).Select(<span class="hljs-string">&quot;users.name, emails.email&quot;</span>).Joins(<span class="hljs-string">&quot;left join emails on emails.user_id = users.id&quot;</span>).Scan(&amp;results)<br><br><span class="hljs-comment">// 带参数的多表连接</span><br>db.Joins(<span class="hljs-string">&quot;JOIN emails ON emails.user_id = users.id AND emails.email = ?&quot;</span>, <span class="hljs-string">&quot;linzy@example.org&quot;</span>).Joins(<span class="hljs-string">&quot;JOIN credit_cards ON credit_cards.user_id = users.id&quot;</span>).Where(<span class="hljs-string">&quot;credit_cards.number = ?&quot;</span>, <span class="hljs-string">&quot;411111111111&quot;</span>).Find(&amp;user)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11、Joins-预加载"><a href="#11、Joins-预加载" class="headerlink" title="11、Joins 预加载"></a>11、Joins 预加载</h2><p>您可以使用 <strong>Joins</strong> 实现单条 SQL 预加载关联记录，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Joins(<span class="hljs-string">&quot;Company&quot;</span>).Find(&amp;users)<br><span class="hljs-comment">// SELECT `users`.`id`,`users`.`name`,`users`.`age`,`Company`.`id` AS `Company__id`,`Company`.`name` AS `Company__name` FROM `users` LEFT JOIN `companies` AS `Company` ON `users`.`company_id` = `Company`.`id`;</span><br></code></pre></td></tr></table></figure><h2 id="12、Scan"><a href="#12、Scan" class="headerlink" title="12、Scan"></a>12、Scan</h2><p>Scan 结果存储于结构体 <strong>struct</strong>，用法与 Find 类似</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Result <span class="hljs-keyword">struct</span> &#123;<br>  Name <span class="hljs-type">string</span><br>  Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> result Result<br>db.Table(<span class="hljs-string">&quot;users&quot;</span>).Select(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;Antonio&quot;</span>).Scan(&amp;result)<br><br><span class="hljs-comment">// 原生 SQL</span><br>db.Raw(<span class="hljs-string">&quot;SELECT name, age FROM users WHERE name = ?&quot;</span>, <span class="hljs-string">&quot;Antonio&quot;</span>).Scan(&amp;result)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、更新"><a href="#三、更新" class="headerlink" title="三、更新"></a>三、更新</h1><p>GORM里的更新(Update方法)，也就是数据库更新语句(Update语句)，可以更新单列、更新多列、更新选定列</p><h2 id="1、更新单列"><a href="#1、更新单列" class="headerlink" title="1、更新单列"></a>1、更新单列</h2><p>当使用 <strong>Update</strong> 更新单个列时，你需要指定条件，否则会返回 <strong>ErrMissingWhereClause</strong> 错误。当使用了 <strong>Model</strong> 方法，且该对象主键有值，该值会被用于构建条件，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 条件更新</span><br>db.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;active = ?&quot;</span>, <span class="hljs-literal">true</span>).Update(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>)<br><span class="hljs-comment">// UPDATE users SET name=&#x27;linzy&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE active=true;</span><br><br><span class="hljs-comment">// User 的 ID 是 `111`</span><br>db.Model(&amp;user).Update(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>)<br><span class="hljs-comment">// UPDATE users SET name=&#x27;linzy&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span><br><br><span class="hljs-comment">// 根据条件和 model 的值进行更新</span><br>db.Model(&amp;user).Where(<span class="hljs-string">&quot;active = ?&quot;</span>, <span class="hljs-literal">true</span>).Update(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>)<br><span class="hljs-comment">// UPDATE users SET name=&#x27;linzy&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111 AND active=true;</span><br></code></pre></td></tr></table></figure><h2 id="2、更新多列"><a href="#2、更新多列" class="headerlink" title="2、更新多列"></a>2、更新多列</h2><p><strong>Updates</strong> 方法支持 <strong>struct</strong> 和 <strong>map[string]interface{}</strong> 参数。当使用 <strong>struct</strong> 更新时，默认情况下，GORM 只会更新非零值的字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 根据 `struct` 更新属性，只会更新非零值的字段</span><br>db.Model(&amp;user).Updates(User&#123;Name: <span class="hljs-string">&quot;linzy&quot;</span>, Age: <span class="hljs-number">18</span>, Active: <span class="hljs-literal">false</span>&#125;)<br><span class="hljs-comment">// UPDATE users SET name=&#x27;linzy&#x27;, age=18, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id = 111;</span><br><br><span class="hljs-comment">// 根据 `map` 更新属性</span><br>db.Model(&amp;user).Updates(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;linzy&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&quot;actived&quot;</span>: <span class="hljs-literal">false</span>&#125;)<br><span class="hljs-comment">// UPDATE users SET name=&#x27;linzy&#x27;, age=18, actived=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：当通过 <strong>struct</strong> 更新时，GORM 只会更新<strong>非零字段</strong>。 如果您想确保指定字段被更新，你应该使用 <strong>Select</strong> 更新选定字段，或使用 <strong>map</strong> 来完成更新操作</p></blockquote><h2 id="3、更新选定字段"><a href="#3、更新选定字段" class="headerlink" title="3、更新选定字段"></a>3、更新选定字段</h2><p>如果您想要在更新时选定、忽略某些字段，您可以使用 <strong>Select</strong>、<strong>Omit</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Select 和 Map</span><br><span class="hljs-comment">// User&#x27;s ID is `111`:</span><br>db.Model(&amp;user).Select(<span class="hljs-string">&quot;name&quot;</span>).Updates(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;linzy&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&quot;actived&quot;</span>: <span class="hljs-literal">false</span>&#125;)<br><span class="hljs-comment">// UPDATE users SET name=&#x27;linzy&#x27; WHERE id=111;</span><br><br>db.Model(&amp;user).Omit(<span class="hljs-string">&quot;name&quot;</span>).Updates(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;linzy&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&quot;actived&quot;</span>: <span class="hljs-literal">false</span>&#125;)<br><span class="hljs-comment">// UPDATE users SET age=18, actived=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span><br><br><span class="hljs-comment">// Select 和 Struct （可以选中更新零值字段）</span><br>db.Model(&amp;result).Select(<span class="hljs-string">&quot;Name&quot;</span>, <span class="hljs-string">&quot;Age&quot;</span>).Updates(User&#123;Name: <span class="hljs-string">&quot;new_name&quot;</span>, Age: <span class="hljs-number">0</span>&#125;)<br><span class="hljs-comment">// UPDATE users SET name=&#x27;new_name&#x27;, age=0 WHERE id=111;</span><br></code></pre></td></tr></table></figure><h2 id="4、保存所有字段"><a href="#4、保存所有字段" class="headerlink" title="4、保存所有字段"></a>4、保存所有字段</h2><p><strong>Save</strong> 会保存所有的字段，即使字段是零值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">db.First(&amp;user)<br><br>user.Name = <span class="hljs-string">&quot;linzy 2&quot;</span><br>user.Age = <span class="hljs-number">100</span><br>db.Save(&amp;user)<br><span class="hljs-comment">// UPDATE users SET name=&#x27;linzy 2&#x27;, age=100, birthday=&#x27;2016-01-01&#x27;, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span><br></code></pre></td></tr></table></figure><h2 id="5、更新-Hook"><a href="#5、更新-Hook" class="headerlink" title="5、更新 Hook"></a>5、更新 Hook</h2><p>对于更新操作，GORM 支持 <strong>BeforeSave</strong>、<strong>BeforeUpdate</strong>、<strong>AfterSave</strong>、<strong>AfterUpdate</strong> 钩子，这些方法将在更新记录时被调用<br>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span></span> BeforeUpdate(tx *gorm.DB) (err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> u.Role == <span class="hljs-string">&quot;admin&quot;</span> &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;admin user not allowed to update&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6、批量更新"><a href="#6、批量更新" class="headerlink" title="6、批量更新"></a>6、批量更新</h2><p>如果您尚未通过 <strong>Model</strong> 指定记录的主键，则 GORM 会执行批量更新</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 根据 struct 更新</span><br>db.Model(User&#123;&#125;).Where(<span class="hljs-string">&quot;role = ?&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>).Updates(User&#123;Name: <span class="hljs-string">&quot;linzy&quot;</span>, Age: <span class="hljs-number">18</span>&#125;)<br><span class="hljs-comment">// UPDATE users SET name=&#x27;linzy&#x27;, age=18 WHERE role = &#x27;admin;</span><br><br><span class="hljs-comment">// 根据 map 更新</span><br>db.Table(<span class="hljs-string">&quot;users&quot;</span>).Where(<span class="hljs-string">&quot;id IN ?&quot;</span>, []<span class="hljs-type">int</span>&#123;<span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;).Updates(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;linzy&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>&#125;)<br><span class="hljs-comment">// UPDATE users SET name=&#x27;linzy&#x27;, age=18 WHERE id IN (10, 11);</span><br></code></pre></td></tr></table></figure><h3 id="1）阻止全局更新"><a href="#1）阻止全局更新" class="headerlink" title="1）阻止全局更新"></a>1）阻止全局更新</h3><p>如果在没有任何条件的情况下执行批量更新，默认情况下，GORM 不会执行该操作，并返回 <strong>ErrMissingWhereClause</strong> 错误</p><p>对此，你必须加一些条件，或者使用原生 SQL，或者启用 <strong>AllowGlobalUpdate</strong> 模式，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Model(&amp;User&#123;&#125;).Update(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>).Error <span class="hljs-comment">// gorm.ErrMissingWhereClause</span><br><br>db.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;1 = 1&quot;</span>).Update(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>)<br><span class="hljs-comment">// UPDATE users SET `name` = &quot;linzy&quot; WHERE 1=1</span><br><br>db.Exec(<span class="hljs-string">&quot;UPDATE users SET name = ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>)<br><span class="hljs-comment">// UPDATE users SET name = &quot;linzy&quot;</span><br><br>db.Session(&amp;gorm.Session&#123;AllowGlobalUpdate: <span class="hljs-literal">true</span>&#125;).Model(&amp;User&#123;&#125;).Update(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>)<br><span class="hljs-comment">// UPDATE users SET `name` = &quot;linzy&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2）更新的记录数"><a href="#2）更新的记录数" class="headerlink" title="2）更新的记录数"></a>2）更新的记录数</h3><p>获取受更新影响的行数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 通过 `RowsAffected` 得到更新的记录数</span><br>result := db.Model(User&#123;&#125;).Where(<span class="hljs-string">&quot;role = ?&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>).Updates(User&#123;Name: <span class="hljs-string">&quot;hello&quot;</span>, Age: <span class="hljs-number">18</span>&#125;)<br><span class="hljs-comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE role = &#x27;admin;</span><br><br>result.RowsAffected <span class="hljs-comment">// 更新的记录数</span><br>result.Error        <span class="hljs-comment">// 更新的错误</span><br></code></pre></td></tr></table></figure><h2 id="7、高级选项"><a href="#7、高级选项" class="headerlink" title="7、高级选项"></a>7、高级选项</h2><h3 id="1）使用-SQL-表达式更新"><a href="#1）使用-SQL-表达式更新" class="headerlink" title="1）使用 SQL 表达式更新"></a>1）使用 SQL 表达式更新</h3><p>GORM 允许使用 SQL 表达式更新列，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// product 的 ID 是 `3`</span><br>db.Model(&amp;product).Update(<span class="hljs-string">&quot;price&quot;</span>, gorm.Expr(<span class="hljs-string">&quot;price * ? + ?&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100</span>))<br><span class="hljs-comment">// UPDATE &quot;products&quot; SET &quot;price&quot; = price * 2 + 100, &quot;updated_at&quot; = &#x27;2013-11-17 21:34:10&#x27; WHERE &quot;id&quot; = 3;</span><br><br>db.Model(&amp;product).Updates(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;price&quot;</span>: gorm.Expr(<span class="hljs-string">&quot;price * ? + ?&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100</span>)&#125;)<br><span class="hljs-comment">// UPDATE &quot;products&quot; SET &quot;price&quot; = price * 2 + 100, &quot;updated_at&quot; = &#x27;2013-11-17 21:34:10&#x27; WHERE &quot;id&quot; = 3;</span><br><br>db.Model(&amp;product).UpdateColumn(<span class="hljs-string">&quot;quantity&quot;</span>, gorm.Expr(<span class="hljs-string">&quot;quantity - ?&quot;</span>, <span class="hljs-number">1</span>))<br><span class="hljs-comment">// UPDATE &quot;products&quot; SET &quot;quantity&quot; = quantity - 1 WHERE &quot;id&quot; = 3;</span><br><br>db.Model(&amp;product).Where(<span class="hljs-string">&quot;quantity &gt; 1&quot;</span>).UpdateColumn(<span class="hljs-string">&quot;quantity&quot;</span>, gorm.Expr(<span class="hljs-string">&quot;quantity - ?&quot;</span>, <span class="hljs-number">1</span>))<br><span class="hljs-comment">// UPDATE &quot;products&quot; SET &quot;quantity&quot; = quantity - 1 WHERE &quot;id&quot; = 3 AND quantity &gt; 1;</span><br></code></pre></td></tr></table></figure><h3 id="2）根据子查询进行更新"><a href="#2）根据子查询进行更新" class="headerlink" title="2）根据子查询进行更新"></a>2）根据子查询进行更新</h3><p>使用子查询更新表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Model(&amp;user).Update(<span class="hljs-string">&quot;company_name&quot;</span>, db.Model(&amp;Company&#123;&#125;).Select(<span class="hljs-string">&quot;name&quot;</span>).Where(<span class="hljs-string">&quot;companies.id = users.company_id&quot;</span>))<br><span class="hljs-comment">// UPDATE &quot;users&quot; SET &quot;company_name&quot; = (SELECT name FROM companies WHERE companies.id = users.company_id);</span><br><br>db.Table(<span class="hljs-string">&quot;users as u&quot;</span>).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>).Update(<span class="hljs-string">&quot;company_name&quot;</span>, db.Table(<span class="hljs-string">&quot;companies as c&quot;</span>).Select(<span class="hljs-string">&quot;name&quot;</span>).Where(<span class="hljs-string">&quot;c.id = u.company_id&quot;</span>))<br><br>db.Table(<span class="hljs-string">&quot;users as u&quot;</span>).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>).Updates(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;&#125;&#123;<span class="hljs-string">&quot;company_name&quot;</span>: db.Table(<span class="hljs-string">&quot;companies as c&quot;</span>).Select(<span class="hljs-string">&quot;name&quot;</span>).Where(<span class="hljs-string">&quot;c.id = u.company_id&quot;</span>)&#125;)<br></code></pre></td></tr></table></figure><h3 id="3）不使用-Hook-和时间追踪"><a href="#3）不使用-Hook-和时间追踪" class="headerlink" title="3）不使用 Hook 和时间追踪"></a>3）不使用 Hook 和时间追踪</h3><p>如果您想在更新时<strong>跳过 Hook 方法</strong>且<strong>不追踪更新时间</strong>，可以使用 <strong>UpdateColumn</strong>、<strong>UpdateColumns</strong>，其用法类似于 <strong>Update</strong>、<strong>Updates</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 更新单个列</span><br>db.Model(&amp;user).UpdateColumn(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-comment">// UPDATE users SET name=&#x27;hello&#x27; WHERE id = 111;</span><br><br><span class="hljs-comment">// 更新多个列</span><br>db.Model(&amp;user).UpdateColumns(User&#123;Name: <span class="hljs-string">&quot;hello&quot;</span>, Age: <span class="hljs-number">18</span>&#125;)<br><span class="hljs-comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE id = 111;</span><br><br><span class="hljs-comment">// 更新选中的列</span><br>db.Model(&amp;user).Select(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>).UpdateColumns(User&#123;Name: <span class="hljs-string">&quot;hello&quot;</span>, Age: <span class="hljs-number">0</span>&#125;)<br><span class="hljs-comment">// UPDATE users SET name=&#x27;hello&#x27;, age=0 WHERE id = 111;</span><br></code></pre></td></tr></table></figure><h1 id="四、删除"><a href="#四、删除" class="headerlink" title="四、删除"></a>四、删除</h1><p>GORM里的更新(Delete方法)，也就是数据库删除语句(Delete语句)，可以删除单条记录，删除多条记录，根据主键删除，删除Hook钩子</p><h2 id="1、删除单条记录"><a href="#1、删除单条记录" class="headerlink" title="1、删除单条记录"></a>1、删除单条记录</h2><p>删除一条记录时，删除对象需要<strong>指定主键</strong>，否则会触发 <strong>批量 Delete</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Email 的 ID 是 `10`</span><br>db.Delete(&amp;email)<br><span class="hljs-comment">// DELETE from emails where id = 10;</span><br><br><span class="hljs-comment">// 带额外条件的删除</span><br>db.Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>).Delete(&amp;email)<br><span class="hljs-comment">// DELETE from emails where id = 10 AND name = &quot;linzy&quot;;</span><br></code></pre></td></tr></table></figure><h2 id="2、删除多条记录"><a href="#2、删除多条记录" class="headerlink" title="2、删除多条记录"></a>2、删除多条记录</h2><p>如果指定的值不包括主属性，那么 GORM 会执行批量删除，它将删除所有匹配的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Where(<span class="hljs-string">&quot;email LIKE ?&quot;</span>, <span class="hljs-string">&quot;%linzy%&quot;</span>).Delete(Email&#123;&#125;)<br><span class="hljs-comment">// DELETE from emails where email LIKE &quot;%linzy%&quot;;</span><br><br>db.Delete(Email&#123;&#125;, <span class="hljs-string">&quot;email LIKE ?&quot;</span>, <span class="hljs-string">&quot;%linzy%&quot;</span>)<br><span class="hljs-comment">//内联 DELETE from emails where email LIKE &quot;%linzy%&quot;;</span><br></code></pre></td></tr></table></figure><h3 id="1）阻止全局删除"><a href="#1）阻止全局删除" class="headerlink" title="1）阻止全局删除"></a>1）阻止全局删除</h3><p>如果在没有任何条件的情况下执行批量删除，GORM 不会执行该操作，并返回 <strong>ErrMissingWhereClause</strong> 错误</p><p>对此，你必须加一些条件，或者使用原生 SQL，或者启用 <strong>AllowGlobalUpdate</strong> 模式，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Delete(&amp;User&#123;&#125;).Error <span class="hljs-comment">// gorm.ErrMissingWhereClause</span><br><br>db.Where(<span class="hljs-string">&quot;1 = 1&quot;</span>).Delete(&amp;User&#123;&#125;)<br><span class="hljs-comment">// DELETE FROM `users` WHERE 1=1</span><br><br>db.Exec(<span class="hljs-string">&quot;DELETE FROM users&quot;</span>)<br><span class="hljs-comment">// DELETE FROM users</span><br><br>db.Session(&amp;gorm.Session&#123;AllowGlobalUpdate: <span class="hljs-literal">true</span>&#125;).Delete(&amp;User&#123;&#125;)<br><span class="hljs-comment">// DELETE FROM users</span><br></code></pre></td></tr></table></figure><h2 id="3、根据主键删除"><a href="#3、根据主键删除" class="headerlink" title="3、根据主键删除"></a>3、根据主键删除</h2><p>GORM 允许通过内联条件指定主键来检索对象，但只支持整型数值，因为 string 可能导致 SQL 注入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Delete(&amp;User&#123;&#125;, <span class="hljs-number">10</span>)<br><span class="hljs-comment">// DELETE FROM users WHERE id = 10;</span><br><br>db.Delete(&amp;User&#123;&#125;, <span class="hljs-string">&quot;10&quot;</span>)<br><span class="hljs-comment">// DELETE FROM users WHERE id = 10;</span><br><br>db.Delete(&amp;users, []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;)<br><span class="hljs-comment">// DELETE FROM users WHERE id IN (1,2,3);</span><br></code></pre></td></tr></table></figure><h2 id="4、删除Hook钩子"><a href="#4、删除Hook钩子" class="headerlink" title="4、删除Hook钩子"></a>4、删除Hook钩子</h2><p>对于删除操作，GORM 支持 <strong>BeforeDelete</strong>、<strong>AfterDelete</strong> Hook，在删除记录时会调用这些方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span></span> BeforeDelete(tx *gorm.DB) (err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> u.Role == <span class="hljs-string">&quot;admin&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;admin user not allowed to delete&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、-软删除"><a href="#5、-软删除" class="headerlink" title="5、*软删除"></a>5、*软删除</h2><p>如果您的模型包含了一个 <strong>gorm.deletedat</strong> 字段（<strong>gorm.Model</strong> 已经包含了该字段)，它将自动获得软删除的能力！</p><p>拥有软删除能力的模型调用 <strong>Delete</strong> 时，记录不会被从数据库中真正删除。但 GORM 会将 <strong>DeletedAt</strong> 置为当前时间， 并且你不能再通过正常的查询方法找到该记录。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// user 的 ID 是 `111`</span><br>db.Delete(&amp;user)<br><span class="hljs-comment">// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE id = 111;</span><br><br><span class="hljs-comment">// 批量删除</span><br>db.Where(<span class="hljs-string">&quot;age = ?&quot;</span>, <span class="hljs-number">20</span>).Delete(&amp;User&#123;&#125;)<br><span class="hljs-comment">// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE age = 20;</span><br><br><span class="hljs-comment">// 在查询时会忽略被软删除的记录</span><br>db.Where(<span class="hljs-string">&quot;age = 20&quot;</span>).Find(&amp;user)<br><span class="hljs-comment">// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;</span><br></code></pre></td></tr></table></figure><blockquote><p>如果您不想引入 gorm.Model，您也可以这样启用软删除特性：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>  ID      <span class="hljs-type">int</span><br>  Deleted gorm.DeletedAt<br>  Name    <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1）查找被软删除的记录"><a href="#1）查找被软删除的记录" class="headerlink" title="1）查找被软删除的记录"></a>1）查找被软删除的记录</h3><p>您可以使用 Unscoped 找到被软删除的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Unscoped().Where(<span class="hljs-string">&quot;age = 20&quot;</span>).Find(&amp;users)<br><span class="hljs-comment">// SELECT * FROM users WHERE age = 20;</span><br></code></pre></td></tr></table></figure><h3 id="2）永久删除"><a href="#2）永久删除" class="headerlink" title="2）永久删除"></a>2）永久删除</h3><p>您也可以使用 <strong>Unscoped</strong> 永久删除匹配的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Unscoped().Delete(&amp;order)<br><span class="hljs-comment">// DELETE FROM orders WHERE id=10;</span><br></code></pre></td></tr></table></figure><h1 id="五、SQL-构建器"><a href="#五、SQL-构建器" class="headerlink" title="五、SQL 构建器"></a>五、SQL 构建器</h1><h2 id="1、原生-SQL"><a href="#1、原生-SQL" class="headerlink" title="1、原生 SQL"></a>1、原生 SQL</h2><ul><li>原生查询 SQL 和 <strong>Scan</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Result <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">int</span><br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> result Result<br>db.Raw(<span class="hljs-string">&quot;SELECT id, name, age FROM users WHERE id = ?&quot;</span>, <span class="hljs-number">3</span>).Scan(&amp;result)<br><br><span class="hljs-keyword">var</span> age <span class="hljs-type">int</span><br>db.Raw(<span class="hljs-string">&quot;select sum(age) from users where role = ?&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>).Scan(&amp;age)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Exec 原生 SQL</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Exec(<span class="hljs-string">&quot;DROP TABLE users&quot;</span>)<br>db.Exec(<span class="hljs-string">&quot;UPDATE orders SET shipped_at=? WHERE id IN ?&quot;</span>, time.Now(), []<span class="hljs-type">int64</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;)<br><br><span class="hljs-comment">// Exec SQL 表达式</span><br>db.Exec(<span class="hljs-string">&quot;update users set money=? where name = ?&quot;</span>, gorm.Expr(<span class="hljs-string">&quot;money * ? + ?&quot;</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">1</span>), <span class="hljs-string">&quot;linzy&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> GORM 允许缓存预编译 SQL 语句来提高性能</p></blockquote><h2 id="2、命名参数"><a href="#2、命名参数" class="headerlink" title="2、命名参数"></a>2、命名参数</h2><p>GORM 支持 <strong>sql.NamedArg</strong>、<strong>map[string]interface{}{}</strong> 或 <strong>struct</strong> 形式的命名参数，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Where(<span class="hljs-string">&quot;name1 = @name OR name2 = @name&quot;</span>, sql.Named(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>)).Find(&amp;user)<br><span class="hljs-comment">// SELECT * FROM `users` WHERE name1 = &quot;linzy&quot; OR name2 = &quot;linzy&quot;</span><br><br>db.Where(<span class="hljs-string">&quot;name1 = @name OR name2 = @name&quot;</span>, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;linzy2&quot;</span>&#125;).First(&amp;result3)<br><span class="hljs-comment">// SELECT * FROM `users` WHERE name1 = &quot;linzy2&quot; OR name2 = &quot;linzy2&quot; ORDER BY `users`.`id` LIMIT 1</span><br><br><span class="hljs-comment">// 原生 SQL 及命名参数</span><br>db.Raw(<span class="hljs-string">&quot;SELECT * FROM users WHERE name1 = @name OR name2 = @name2 OR name3 = @name&quot;</span>,<br>sql.Named(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;linzy1&quot;</span>), sql.Named(<span class="hljs-string">&quot;name2&quot;</span>, <span class="hljs-string">&quot;linzy2&quot;</span>)).Find(&amp;user)<br><span class="hljs-comment">// SELECT * FROM users WHERE name1 = &quot;linzy1&quot; OR name2 = &quot;linzy2&quot; OR name3 = &quot;linzy1&quot;</span><br><br>db.Exec(<span class="hljs-string">&quot;UPDATE users SET name1 = @name, name2 = @name2, name3 = @name&quot;</span>,<br>sql.Named(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;linzynew&quot;</span>), sql.Named(<span class="hljs-string">&quot;name2&quot;</span>, <span class="hljs-string">&quot;linzynew2&quot;</span>))<br><span class="hljs-comment">// UPDATE users SET name1 = &quot;linzynew&quot;, name2 = &quot;linzynew2&quot;, name3 = &quot;linzynew&quot;</span><br><br>db.Raw(<span class="hljs-string">&quot;SELECT * FROM users WHERE (name1 = @name AND name3 = @name) AND name2 = @name2&quot;</span>,<br><span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;linzy&quot;</span>, <span class="hljs-string">&quot;name2&quot;</span>: <span class="hljs-string">&quot;linzy2&quot;</span>&#125;).Find(&amp;user)<br><span class="hljs-comment">// SELECT * FROM users WHERE (name1 = &quot;linzy&quot; AND name3 = &quot;linzy&quot;) AND name2 = &quot;linzy2&quot;</span><br><br><span class="hljs-keyword">type</span> NamedArgument <span class="hljs-keyword">struct</span> &#123;<br>Name  <span class="hljs-type">string</span><br>Name2 <span class="hljs-type">string</span><br>&#125;<br><br>db.Raw(<span class="hljs-string">&quot;SELECT * FROM users WHERE (name1 = @Name AND name3 = @Name) AND name2 = @Name2&quot;</span>,<br>NamedArgument&#123;Name: <span class="hljs-string">&quot;linzy&quot;</span>, Name2: <span class="hljs-string">&quot;linzy2&quot;</span>&#125;).Find(&amp;user)<br><span class="hljs-comment">// SELECT * FROM users WHERE (name1 = &quot;linzy&quot; AND name3 = &quot;linzy&quot;) AND name2 = &quot;linzy2&quot;</span><br></code></pre></td></tr></table></figure><h2 id="3、DryRun-模式"><a href="#3、DryRun-模式" class="headerlink" title="3、DryRun 模式"></a>3、DryRun 模式</h2><p>在不执行的情况下生成 SQL ，可以用于准备或测试生成的 SQL</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">stmt := db.Session(&amp;Session&#123;DryRun: <span class="hljs-literal">true</span>&#125;).First(&amp;user, <span class="hljs-number">1</span>).Statement<br>stmt.SQL.String() <span class="hljs-comment">//=&gt; SELECT * FROM `users` WHERE `id` = $1 ORDER BY `id`</span><br>stmt.Vars         <span class="hljs-comment">//=&gt; []interface&#123;&#125;&#123;1&#125;</span><br></code></pre></td></tr></table></figure><ul><li>Row &amp; Rows<br>获取 *sql.Row 结果</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用 GORM API 构建 SQL</span><br>row := db.Table(<span class="hljs-string">&quot;users&quot;</span>).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>).Select(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>).Row()<br>row.Scan(&amp;name, &amp;age)<br><br><span class="hljs-comment">// 使用原生 SQL</span><br>row := db.Raw(<span class="hljs-string">&quot;select name, age, email from users where name = ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>).Row()<br>row.Scan(&amp;name, &amp;age, &amp;email)<br></code></pre></td></tr></table></figure><ul><li>获取 *sql.Rows 结果</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用 GORM API 构建 SQL</span><br>rows, err := db.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>).Select(<span class="hljs-string">&quot;name, age, email&quot;</span>).Rows()<br><span class="hljs-keyword">defer</span> rows.Close()<br><span class="hljs-keyword">for</span> rows.Next() &#123;<br>rows.Scan(&amp;name, &amp;age, &amp;email)<br><br><span class="hljs-comment">// 业务逻辑...</span><br>&#125;<br><br><span class="hljs-comment">// 原生 SQL</span><br>rows, err := db.Raw(<span class="hljs-string">&quot;select name, age, email from users where name = ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>).Rows()<br><span class="hljs-keyword">defer</span> rows.Close()<br><span class="hljs-keyword">for</span> rows.Next() &#123;<br>rows.Scan(&amp;name, &amp;age, &amp;email)<br><br><span class="hljs-comment">// 业务逻辑...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>转到 <strong>FindInBatches</strong> 获取如何在批量中查询和处理记录的信息， 转到 Group 条件 获取如何构建复杂 SQL 查询的信息</p><h2 id="4、将-sql-Rows-扫描至-model"><a href="#4、将-sql-Rows-扫描至-model" class="headerlink" title="4、将 sql.Rows 扫描至 model"></a>4、将 sql.Rows 扫描至 model</h2><p>使用 <strong>ScanRows</strong> 将一行记录扫描至 struct，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">rows, err := db.Model(&amp;User&#123;&#125;).Where(<span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>).Select(<span class="hljs-string">&quot;name, age, email&quot;</span>).Rows() <span class="hljs-comment">// (*sql.Rows, error)</span><br><span class="hljs-keyword">defer</span> rows.Close()<br><br><span class="hljs-keyword">var</span> user User<br><span class="hljs-keyword">for</span> rows.Next() &#123;<br><span class="hljs-comment">// ScanRows 将一行扫描至 user</span><br>db.ScanRows(rows, &amp;user)<br><br><span class="hljs-comment">// 业务逻辑...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>参考GORM中文文档:<a href="https://learnku.com/docs/gorm/v2/connecting_to_the_database/9731#64cea3">https://learnku.com/docs/gorm/v2/connecting_to_the_database&#x2F;9731#64cea3</a></p>]]></content>
    
    
    <categories>
      
      <category>Gorm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>mysql</tag>
      
      <tag>数据库</tag>
      
      <tag>Gorm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gorm学习（一）入门：Gorm入门指南</title>
    <link href="/2022/10/11/gorm_begin/"/>
    <url>/2022/10/11/gorm_begin/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>感谢开源项目<a href="https://www.gin-vue-admin.com/">gin-vue-admin</a>，以及<a href="https://www.bilibili.com/video/BV12i4y1x7AG?spm_id_from=333.999.0.0">1010工作室的视频教程</a></p></blockquote><h1 id="一、GORM介绍"><a href="#一、GORM介绍" class="headerlink" title="一、GORM介绍"></a>一、GORM介绍</h1><h2 id="1、GORM概述"><a href="#1、GORM概述" class="headerlink" title="1、GORM概述"></a>1、GORM概述</h2><p>GORM一个目前比较热门的，使用简单，对开发人员友好的 <code>Golang ORM 库</code>。<br>GORM框架是go的一个<strong>数据库连接及交互框架</strong>，主要是把struct类型和数据库记录进行映射，数据库语句复杂的情况下可以直接手写语句，一般用于连接<strong>关系型数据库</strong>，这里我主要使用MySQL数据库。</p><blockquote><p><strong>对象关系映射（英语：Object Relational Mapping，简称ORM）：</strong> 通过使用描述对象和数据库之间映射的<code>元数据</code>，将程序中的对象与关系数据库<code>相互映射</code>，可以使用面向对象的范例从数据库中查询和操作数据。<br>简而言之：代码结构即是数据库结构，代码行为就是数据库行为。</p></blockquote><h2 id="2、为什么选择GORM？"><a href="#2、为什么选择GORM？" class="headerlink" title="2、为什么选择GORM？"></a>2、为什么选择GORM？</h2><p>特性：</p><ul><li>数据库连接(以MySQL为例)和自动建表方便。</li><li>文档内容详细全面，适合快速入门上手。</li><li>支持关联 (一对一，一对多，多对多的关系)。</li><li>带有Create，Save，Update，Delete，Find 中钩子方法。</li><li>支持 <code>Preload、Joins</code> 的预加载，对于关联查询很重要，主要用于显示关联子结构的内容。</li><li>支持事务，嵌套事务。</li><li>可以使用Context、预编译模式、DryRun 模式。</li><li>批量插入，FindInBatches，Find&#x2F;Create with Map，使用 SQL 表达式、Context Valuer 进行 CRUD。</li><li>SQL 构建器，Upsert，<code>数据库锁</code>，Optimizer&#x2F;Index&#x2F;Comment Hint，命名参数，子查询。</li><li>复合主键，索引，约束。</li><li>自定义 Logger。</li><li>灵活的可扩展插件 API：Database Resolver（多数据库，读写分离）、Prometheus…</li><li>开发者友好。</li></ul><h1 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h1><p>GORM库github地址: <a href="https://github.com/go-gorm/gorm">https://github.com/go-gorm/gorm</a><br>GORM库文档地址：<a href="https://gorm.io/zh_CN/docs/">https://gorm.io/zh_CN&#x2F;docs&#x2F;</a></p><p>第一步：<br>很重要，go mod 包管理工具项目的开始都需要先做这一步</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> mod init name<br></code></pre></td></tr></table></figure><p>第二步：</p><blockquote><p>操作MySQL数据库需要两个包</p><ul><li>GORM包</li><li>MySQL驱动包</li></ul></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">go get <span class="hljs-literal">-u</span> gorm.io/gorm <br>go get <span class="hljs-literal">-u</span> gorm.io/driver/mysql<br></code></pre></td></tr></table></figure><p><strong>或者：</strong></p><p>你可以直接在文件里面直接导入这两个库的引用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br><span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>再用 <code>go mod tidy</code>的方法自动导入库。</p><h1 id="三、快速入门"><a href="#三、快速入门" class="headerlink" title="三、快速入门"></a>三、快速入门</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br><span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">uint</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//我这里用到数据库是mysql，需要配置DSN属性[username[:password]@][protocol[(address)]]/dbname[?param1=value1&amp;...&amp;paramN=valueN]</span><br>dsn := <span class="hljs-string">&quot;root:123456@tcp(127.0.0.1:3306)/go_test?charset=utf8&amp;parseTime=True&quot;</span><br>db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;failed to connect database&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 迁移 schema</span><br>db.AutoMigrate(&amp;User&#123;&#125;)<br><br><span class="hljs-comment">// Insert 插入语句</span><br>db.Create(&amp;User&#123;Name: <span class="hljs-string">&quot;linzy&quot;</span>, Age: <span class="hljs-number">23</span>&#125;)<br><br><span class="hljs-comment">// Select 查询语句</span><br><span class="hljs-keyword">var</span> user User<br>db.First(&amp;user, <span class="hljs-number">1</span>) <span class="hljs-comment">// 根据整形主键查找</span><br>fmt.Println(user)<br>db.First(&amp;user, <span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>) <span class="hljs-comment">// 查找 name 字段值为 linzy 的记录</span><br>fmt.Println(user)<br><br><span class="hljs-comment">// Update 更新语句 - 将 User 的 age 更新为 18</span><br>db.Model(&amp;user).Update(<span class="hljs-string">&quot;Age&quot;</span>, <span class="hljs-number">18</span>)<br><span class="hljs-comment">// Update - 更新多个字段</span><br>db.Model(&amp;user).Updates(User&#123;Name: <span class="hljs-string">&quot;linzy&quot;</span>, Age: <span class="hljs-number">88</span>&#125;) <span class="hljs-comment">// 仅更新非零值字段</span><br>db.Model(&amp;user).Updates(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;linzy&quot;</span>, <span class="hljs-string">&quot;Age&quot;</span>: <span class="hljs-number">23</span>&#125;)<br><br><span class="hljs-comment">// Delete 删除语句 - 删除 ID为1</span><br>db.Delete(&amp;user, <span class="hljs-number">1</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/img/gorm_begin/gorm.png"></p><h1 id="四、模型定义"><a href="#四、模型定义" class="headerlink" title="四、模型定义"></a>四、模型定义</h1><p>GORM负责将对模型的读写操作翻译成sql语句，然后GORM再把数据库执行的sql语句后返回的结果转化为我们定义的模型对象。</p><h2 id="1、模型定义介绍"><a href="#1、模型定义介绍" class="headerlink" title="1、模型定义介绍"></a>1、模型定义介绍</h2><p>模型是标准的 struct，由 Go 的基本数据类型、实现了 Scanner 和 Valuer 接口的自定义类型及其指针或别名组成。<br>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>ID           <span class="hljs-type">uint</span><br>Name         <span class="hljs-type">string</span><br>Email        *<span class="hljs-type">string</span><br>Age          <span class="hljs-type">uint8</span><br>Birthday     *time.Time<br>MemberNumber sql.NullString<br>ActivedAt    sql.NullTime<br>CreatedAt    time.Time<br>UpdatedAt    time.Time<br>&#125;<br></code></pre></td></tr></table></figure><p>默认gorm对struct字段名使用Snake Case命名风格转换成mysql表字段名(需要转换成小写字母)。</p><blockquote><p>Snake Case命名风格，就是各个单词之间用下划线（_）分隔，首字母大写区分一个单词，例如： CreateTime的Snake Case风格命名为create_time</p></blockquote><h2 id="2、约定"><a href="#2、约定" class="headerlink" title="2、约定"></a>2、约定</h2><p>GORM 倾向于<strong>约定</strong>，而不是配置。默认情况下，GORM 使用 ID 作为主键，使用结构体名的 <strong>蛇形复数</strong> 作为表名，字段名的 <strong>蛇形</strong> 作为列名，并使用 <strong>CreatedAt</strong>、<strong>UpdatedAt</strong> 字段追踪创建、更新时间</p><p>遵循 GORM 已有的约定，可以减少您的配置和代码量。如果约定不符合您的需求，GORM 允许您自定义配置它们</p><h2 id="3、gorm-Model"><a href="#3、gorm-Model" class="headerlink" title="3、gorm.Model"></a>3、gorm.Model</h2><p>GORM 定义一个 <strong>gorm.Model</strong> 结构体，其包括字段 <strong>ID</strong>、<strong>CreatedAt</strong>、<strong>UpdatedAt</strong>、<strong>DeletedAt</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// gorm.Model 的定义</span><br><span class="hljs-keyword">type</span> Model <span class="hljs-keyword">struct</span> &#123;<br>ID        <span class="hljs-type">uint</span> <span class="hljs-string">`gorm:&quot;primaryKey&quot;`</span> <span class="hljs-comment">//设置主键</span><br>CreatedAt time.Time<br>UpdatedAt time.Time<br>DeletedAt gorm.DeletedAt <span class="hljs-string">`gorm:&quot;index&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以将它嵌入到你的结构体中，以包含这几个字段</p><h2 id="4、高级选项"><a href="#4、高级选项" class="headerlink" title="4、高级选项"></a>4、高级选项</h2><h3 id="1）字段级权限控制"><a href="#1）字段级权限控制" class="headerlink" title="1）字段级权限控制"></a>1）字段级权限控制</h3><p>可导出的字段在使用 GORM 进行 CRUD 时拥有全部的权限，此外，GORM 允许您用标签控制字段级别的权限。这样您就可以让一个字段的权限是只读、只写、只创建、只更新或者被忽略</p><blockquote><p><strong>注意</strong>： 使用 GORM Migrator 创建表时，不会创建被忽略的字段</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;&lt;-:create&quot;`</span>          <span class="hljs-comment">// 允许读和创建</span><br>Name <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;&lt;-:update&quot;`</span>          <span class="hljs-comment">// 允许读和更新</span><br>Name <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;&lt;-&quot;`</span>                 <span class="hljs-comment">// 允许读和写（创建和更新）</span><br>Name <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;&lt;-:false&quot;`</span>           <span class="hljs-comment">// 允许读，禁止写</span><br>Name <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;-&gt;&quot;`</span>                 <span class="hljs-comment">// 只读（除非有自定义配置，否则禁止写）</span><br>Name <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;-&gt;;&lt;-:create&quot;`</span>       <span class="hljs-comment">// 允许读和写</span><br>Name <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;-&gt;:false;&lt;-:create&quot;`</span> <span class="hljs-comment">// 仅创建（禁止从 db 读）</span><br>Name <span class="hljs-type">string</span> <span class="hljs-string">`gorm:&quot;-&quot;`</span>                  <span class="hljs-comment">// 读写操作均会忽略该字段</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）创建-x2F-更新时间追踪（纳秒、毫秒、秒、Time）"><a href="#2）创建-x2F-更新时间追踪（纳秒、毫秒、秒、Time）" class="headerlink" title="2）创建 &#x2F; 更新时间追踪（纳秒、毫秒、秒、Time）"></a>2）创建 &#x2F; 更新时间追踪（纳秒、毫秒、秒、Time）</h3><p>GORM 约定使用 <strong>CreatedAt</strong>、<strong>UpdatedAt</strong> 追踪创建 &#x2F; 更新时间。如果您定义了这种字段，GORM 在创建、更新时会自动填充 当前时间</p><p>要使用不同名称的字段，您可以配置 <strong>autoCreateTim</strong>、<strong>autoUpdateTim</strong> 标签</p><p>如果您想要保存 UNIX（毫 &#x2F; 纳）秒时间戳，而不是 time，您只需简单地将 time.Time 修改为 int 即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>CreatedAt time.Time <span class="hljs-comment">// 在创建时，如果该字段值为零值，则使用当前时间填充</span><br>UpdatedAt <span class="hljs-type">int</span>       <span class="hljs-comment">// 在创建时该字段值为零值或者在更新时，使用当前时间戳秒数填充</span><br>Updated   <span class="hljs-type">int64</span>     <span class="hljs-string">`gorm:&quot;autoUpdateTime:nano&quot;`</span>  <span class="hljs-comment">// 使用时间戳填纳秒数充更新时间</span><br>Updated   <span class="hljs-type">int64</span>     <span class="hljs-string">`gorm:&quot;autoUpdateTime:milli&quot;`</span> <span class="hljs-comment">// 使用时间戳毫秒数填充更新时间</span><br>Created   <span class="hljs-type">int64</span>     <span class="hljs-string">`gorm:&quot;autoCreateTime&quot;`</span>       <span class="hljs-comment">// 使用时间戳秒数填充创建时间</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3）嵌入结构体"><a href="#3）嵌入结构体" class="headerlink" title="3）嵌入结构体"></a>3）嵌入结构体</h3><p>对于匿名字段，GORM 会将其字段包含在父结构体中，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 等效于</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>ID        <span class="hljs-type">uint</span> <span class="hljs-string">`gorm:&quot;primaryKey&quot;`</span><br>CreatedAt time.Time<br>UpdatedAt time.Time<br>DeletedAt gorm.DeletedAt <span class="hljs-string">`gorm:&quot;index&quot;`</span><br>Name      <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于正常的结构体字段，你也可以通过标签 <strong>embedded</strong> 将其嵌入，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Author <span class="hljs-keyword">struct</span> &#123;<br>Name  <span class="hljs-type">string</span><br>Email <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Blog <span class="hljs-keyword">struct</span> &#123;<br>ID      <span class="hljs-type">int</span><br>Author  Author <span class="hljs-string">`gorm:&quot;embedded&quot;`</span><br>Upvotes <span class="hljs-type">int32</span><br>&#125;<br><br><span class="hljs-comment">// 等效于</span><br><span class="hljs-keyword">type</span> Blog <span class="hljs-keyword">struct</span> &#123;<br>ID      <span class="hljs-type">int64</span><br>Name    <span class="hljs-type">string</span><br>Email   <span class="hljs-type">string</span><br>Upvotes <span class="hljs-type">int32</span><br>&#125;<br></code></pre></td></tr></table></figure><p>并且，您可以使用标签 <strong>embeddedPrefix</strong> 来为 db 中的字段名添加前缀，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Blog <span class="hljs-keyword">struct</span> &#123;<br>ID      <span class="hljs-type">int</span><br>Author  Author <span class="hljs-string">`gorm:&quot;embedded;embeddedPrefix:author_&quot;`</span><br>Upvotes <span class="hljs-type">int32</span><br>&#125;<br><br><span class="hljs-comment">// 等效于</span><br><span class="hljs-keyword">type</span> Blog <span class="hljs-keyword">struct</span> &#123;<br>ID          <span class="hljs-type">int64</span><br>AuthorName  <span class="hljs-type">string</span><br>AuthorEmail <span class="hljs-type">string</span><br>Upvotes     <span class="hljs-type">int32</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4）字段标签"><a href="#4）字段标签" class="headerlink" title="4）字段标签"></a>4）字段标签</h3><p>声明 model 时，tag 是可选的，GORM 支持以下 tag： tag 名大小写不敏感，但建议使用 <strong>camelCase</strong> 风格</p><table><thead><tr><th align="left"><strong>标签名</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">column</td><td align="left">指定 db 列名</td></tr><tr><td align="left">type</td><td align="left">列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：<strong>not null</strong>、<strong>size</strong>, <strong>autoIncrement</strong>… 像 <strong>varbinary(8</strong>) 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：<strong>MEDIUMINT UNSIGNED not NULL   AUTO_INSTREMENT</strong></td></tr><tr><td align="left">size</td><td align="left">指定列大小，例如：size:256</td></tr><tr><td align="left">primaryKey</td><td align="left">指定列为主键</td></tr><tr><td align="left">unique</td><td align="left">指定列为唯一</td></tr><tr><td align="left">default</td><td align="left">指定列的默认值</td></tr><tr><td align="left">precision</td><td align="left">指定列的精度</td></tr><tr><td align="left">scale</td><td align="left">指定列大小</td></tr><tr><td align="left">not null</td><td align="left">指定列为 NOT NULL</td></tr><tr><td align="left">autoIncrement</td><td align="left">指定列为自动增长</td></tr><tr><td align="left">embedded</td><td align="left">嵌套字段</td></tr><tr><td align="left">embeddedPrefix</td><td align="left">嵌入字段的列名前缀</td></tr><tr><td align="left">autoCreateTime</td><td align="left">创建时追踪当前时间，对于 int 字段，它会追踪时间戳秒数，您可以使用 <strong>nano</strong>&#x2F;<strong>milli</strong> 来追踪纳秒、毫秒时间戳，例如：<strong>autoCreateTime:nano</strong></td></tr><tr><td align="left">autoUpdateTime</td><td align="left">创建 &#x2F; 更新时追踪当前时间，对于 int 字段，它会追踪时间戳秒数，您可以使用 <strong>nano</strong>&#x2F;<strong>milli</strong> 来追踪纳秒、毫秒时间戳，例如：<strong>autoUpdateTime:milli</strong></td></tr><tr><td align="left">index</td><td align="left">根据参数创建索引，多个字段使用相同的名称则创建复合索引</td></tr><tr><td align="left">uniqueIndex</td><td align="left">与 <strong>index</strong> 相同，但创建的是唯一索引</td></tr><tr><td align="left">check</td><td align="left">创建检查约束，例如 <strong>check:age &gt; 13</strong></td></tr><tr><td align="left">&lt;-</td><td align="left">设置字段写入的权限， <strong>&lt;-:create</strong> 只创建、**&lt;-:update** 只更新、**&lt;-:false** 无写入权限、**&lt;-** 创建和更新权限</td></tr><tr><td align="left">-&gt;</td><td align="left">设置字段读的权限，**-&gt;:false** 无读权限</td></tr><tr><td align="left">-</td><td align="left">忽略该字段，**-** 无读写权限</td></tr></tbody></table><h3 id="5）关联标签"><a href="#5）关联标签" class="headerlink" title="5）关联标签"></a>5）关联标签</h3><p>GORM 允许通过标签为关联配置外键、约束、many2many 表</p><h1 id="五、连接数据库"><a href="#五、连接数据库" class="headerlink" title="五、连接数据库"></a>五、连接数据库</h1><p>GORM 官方支持的数据库类型有： MySQL, PostgreSQL, SQlite, SQL Server</p><h2 id="1、MySQL"><a href="#1、MySQL" class="headerlink" title="1、MySQL"></a>1、MySQL</h2><p>连接MySQL主要有两个步骤:</p><p>1）配置DSN (Data Source Name)</p><ul><li>DSN介绍：<strong>gorm库使用dsn作为连接数据库的参数</strong>，dsn翻译过来就叫数据源名称，用来描述数据库连接信息。一般都包含数据库连接地址，账号，密码之类的信息。</li><li>DSN字段格式：</li></ul><blockquote><p>[username[:password]@][protocol[(address)]]&#x2F;dbname[?param1&#x3D;value1&amp;…&amp;paramN&#x3D;valueN]</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//mysql dsn格式</span><br><span class="hljs-comment">//涉及参数:</span><br><span class="hljs-comment">//username   数据库账号</span><br><span class="hljs-comment">//password   数据库密码</span><br><span class="hljs-comment">//host       数据库连接地址，可以是Ip或者域名</span><br><span class="hljs-comment">//port       数据库端口</span><br><span class="hljs-comment">//Dbname     数据库名</span><br>username:password@tcp(host:port)/Dbname?charset=utf8&amp;parseTime=True&amp;loc=Local<br></code></pre></td></tr></table></figure><p>2）使用gorm.Open连接数据库</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br><span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情</span><br>dsn := <span class="hljs-string">&quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span><br>db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：想要正确的处理 time.Time ，您需要带上 parseTime 参数，要支持完整的 UTF-8 编码，您需要将 charset&#x3D;utf8 更改为 charset&#x3D;utf8mb4</p></blockquote><p>MySQl 驱动程序提供了 一些高级配置 可以在初始化过程中使用，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">db, err := gorm.Open(mysql.New(mysql.Config&#123;<br><span class="hljs-comment">// DSN data source name</span><br>DSN:                       <span class="hljs-string">&quot;gorm:gorm@tcp(127.0.0.1:3306)/gorm?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>, <br><span class="hljs-comment">// string 类型字段的默认长度</span><br>DefaultStringSize:         <span class="hljs-number">256</span>,<br><span class="hljs-comment">// 禁用 datetime 精度，MySQL 5.6 之前的数据库不支持                                                                        </span><br>DisableDatetimePrecision:  <span class="hljs-literal">true</span>,<br><span class="hljs-comment">// 重命名索引时采用删除并新建的方式，MySQL 5.7 之前的数据库和 MariaDB 不支持重命名索引                                                                       </span><br>DontSupportRenameIndex:    <span class="hljs-literal">true</span>,<br><span class="hljs-comment">// 用 `change` 重命名列，MySQL 8 之前的数据库和 MariaDB 不支持重命名列                                                                       </span><br>DontSupportRenameColumn:   <span class="hljs-literal">true</span>,<br><span class="hljs-comment">// 根据当前 MySQL 版本自动配置                                                                       </span><br>SkipInitializeWithVersion: <span class="hljs-literal">false</span>,                                                                      <br>&#125;), &amp;gorm.Config&#123;&#125;)<br></code></pre></td></tr></table></figure><h3 id="1）自定义驱动"><a href="#1）自定义驱动" class="headerlink" title="1）自定义驱动"></a>1）自定义驱动</h3><p>GORM 允许通过 <strong>DriverName</strong> 选项自定义 MySQL 驱动，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br><span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db, err := gorm.Open(mysql.New(mysql.Config&#123;<br>DriverName: <span class="hljs-string">&quot;my_mysql_driver&quot;</span>,<br>DSN:        <span class="hljs-string">&quot;gorm:gorm@tcp(localhost:9910)/gorm?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>, <br><span class="hljs-comment">// Data Source Name，参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name</span><br>&#125;), &amp;gorm.Config&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）现有的数据库连接"><a href="#2）现有的数据库连接" class="headerlink" title="2）现有的数据库连接"></a>2）现有的数据库连接</h3><p>GORM 允许通过一个现有的数据库连接来初始化 *<strong>gorm.DB</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;database/sql&quot;</span><br><br><span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br><span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sqlDB, err := sql.Open(<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;mydb_dsn&quot;</span>)<br>gormDB, err := gorm.Open(mysql.New(mysql.Config&#123;<br>Conn: sqlDB,<br>&#125;), &amp;gorm.Config&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3）GORM配置"><a href="#3）GORM配置" class="headerlink" title="3）GORM配置"></a>3）GORM配置</h3><p> <strong>gorm.Config{}：</strong> GORM 提供可以在初始化时使用的配置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>  <span class="hljs-comment">//跳过默认事务:为了确保数据一致性，GORM 会在事务里执行写入操作（创建、更新、删除）。</span><br>  SkipDefaultTransaction   <span class="hljs-type">bool</span><br>  <span class="hljs-comment">//命名策略:用户通过覆盖默认的NamingStrategy来更改命名约定</span><br>  NamingStrategy           schema.Namer<br>  <span class="hljs-comment">//Logger:通过覆盖此选项更改 GORM 的默认 logger</span><br>  Logger                   logger.Interface<br>  <span class="hljs-comment">//NowFunc:更改创建时间使用的函数</span><br>  NowFunc                  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> time.Time<br>  <span class="hljs-comment">//DryRun:生成 SQL 但不执行，可以用于准备或测试生成的 SQL</span><br>  DryRun                   <span class="hljs-type">bool</span><br>  <span class="hljs-comment">//PrepareStmt:PreparedStmt 在执行任何 SQL 时都会创建一个 prepared statement 并将其缓存，以提高后续的效率</span><br>  PrepareStmt              <span class="hljs-type">bool</span><br>  <span class="hljs-comment">//禁用嵌套事务</span><br>  DisableNestedTransaction <span class="hljs-type">bool</span><br>  <span class="hljs-comment">//AllowGlobalUpdate:启用全局 update/delete</span><br>  AllowGlobalUpdate        <span class="hljs-type">bool</span><br>  <span class="hljs-comment">//DisableAutomaticPing:在完成初始化后，GORM 会自动 ping 数据库以检查数据库的可用性</span><br>  DisableAutomaticPing     <span class="hljs-type">bool</span><br>  <span class="hljs-comment">//DisableForeignKeyConstraintWhenMigrating:在 AutoMigrate 或 CreateTable 时，GORM 会自动创建外键约束</span><br>  DisableForeignKeyConstraintWhenMigrating <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>GORM配置详细内容直接看文档，我后续会再写一篇：<a href="https://gorm.io/zh_CN/docs/gorm_config.html">点击跳转</a></p></blockquote><h2 id="2、连接池"><a href="#2、连接池" class="headerlink" title="2、连接池"></a>2、连接池</h2><p>在高并发实践中，为了提高数据库连接的使用率，避免重复建立数据库连接带来的性能消耗，会经常使用数据库连接池技术来维护数据库连接。<br>GORM 使用 <strong>database</strong>&#x2F;<strong>sql</strong> 维护连接池</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">sqlDB, err := db.DB()<br><br><span class="hljs-comment">// SetMaxIdleConns 设置空闲连接池中连接的最大数量</span><br>sqlDB.SetMaxIdleConns(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment">// SetMaxOpenConns 设置打开数据库连接的最大数量。</span><br>sqlDB.SetMaxOpenConns(<span class="hljs-number">100</span>)<br><br><span class="hljs-comment">// SetConnMaxLifetime 设置了连接可复用的最大时间。</span><br>sqlDB.SetConnMaxLifetime(time.Hour)<br></code></pre></td></tr></table></figure><p>参考GORM中文文档:<a href="https://learnku.com/docs/gorm/v2/connecting_to_the_database/9731#64cea3">https://learnku.com/docs/gorm/v2/connecting_to_the_database&#x2F;9731#64cea3</a></p>]]></content>
    
    
    <categories>
      
      <category>Gorm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>mysql</tag>
      
      <tag>数据库</tag>
      
      <tag>Gorm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis（四）实战：redigo的安装和连接使用</title>
    <link href="/2022/10/11/redis-redigo/"/>
    <url>/2022/10/11/redis-redigo/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>学习本文需要一些redis知识，请学习前面文章</p></blockquote><h1 id="一、Redigo"><a href="#一、Redigo" class="headerlink" title="一、Redigo"></a>一、Redigo</h1><h2 id="1、Redigo概述"><a href="#1、Redigo概述" class="headerlink" title="1、Redigo概述"></a>1、Redigo概述</h2><p>Redigo是Redis数据库的Go客户端。用于实现Redis数据库的基本操作，支持Redis的所有命令。<br>Redigo 官方地址：<a href="https://github.com/gomodule/redigo">点击跳转</a></p><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><p>直接在在terminal里输入指令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">go get github.com/gomodule/redigo/redis<br></code></pre></td></tr></table></figure><h1 id="二、Redigo使用"><a href="#二、Redigo使用" class="headerlink" title="二、Redigo使用"></a>二、Redigo使用</h1><h2 id="1、普通连接"><a href="#1、普通连接" class="headerlink" title="1、普通连接"></a>1、普通连接</h2><p>Conn接口是使用Redis数据库的主要接口。通过调用redis.Dial()来创建连接。创建连接完成操作后，必须调用连接关闭方法Conn.Close()。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//创建Redis连接</span><br>c, err := redis.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:6379&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-comment">//使用延迟函数，在函数结束前调用连接关闭</span><br><span class="hljs-keyword">defer</span> c.Close()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>若是Redis设置了密码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//创建Redis连接</span><br>c, err := redis.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:6379&quot;</span>,<br>redis.DialUsername(<span class="hljs-string">&quot;username&quot;</span>),<br>redis.DialPassword(<span class="hljs-string">&quot;password&quot;</span>),<br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-comment">//使用延迟函数，在函数结束前调用连接关闭</span><br><span class="hljs-keyword">defer</span> c.Close()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、创建Redis连接池-推荐"><a href="#2、创建Redis连接池-推荐" class="headerlink" title="2、创建Redis连接池(推荐)"></a>2、创建Redis连接池(推荐)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Setup</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>RedisConn = &amp;redis.Pool&#123;<br><span class="hljs-comment">//最大空闲连接数</span><br>MaxIdle: <span class="hljs-number">30</span>,<br><span class="hljs-comment">//在给定时间内，允许分配的最大连接数（当为零时，没有限制）</span><br>MaxActive: <span class="hljs-number">30</span>,<br><span class="hljs-comment">//在给定时间内，保持空闲状态的时间，若到达时间限制则关闭连接（当为零时，没有限制）</span><br>IdleTimeout: <span class="hljs-number">200</span>,<br><span class="hljs-comment">//提供创建和配置应用程序连接的一个函数</span><br>Dial: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (redis.Conn, <span class="hljs-type">error</span>) &#123;<br>c, err := redis.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:6379&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-comment">//如果redis设置了用户密码，使用auth指令</span><br><span class="hljs-keyword">if</span> _, err := c.Do(<span class="hljs-string">&quot;AUTH&quot;</span>, password); err != <span class="hljs-literal">nil</span> &#123;<br>c.Close()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> c, err<br>&#125;,<br>TestOnBorrow: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c redis.Conn, t time.Time)</span></span> <span class="hljs-type">error</span> &#123;<br>_, err := c.Do(<span class="hljs-string">&quot;PING&quot;</span>)<br><span class="hljs-keyword">return</span> err<br>&#125;,<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>设置 RedisConn 为 redis.Pool（连接池）并配置了它的一些参数：</p><ul><li>Dial：提供创建和配置应用程序连接的一个函数。</li><li>TestOnBorrow：可选的应用程序检查连接是否健康功能。</li><li>MaxIdle：最大空闲连接数。</li><li>MaxActive：在给定时间内，允许分配的最大连接数（当为零时，没有限制）。</li><li>IdleTimeout：在给定时间内，保持空闲状态的时间，若到达时间限制则关闭连接（当为零时，没有限制）。</li></ul></blockquote><h2 id="3、简单Redis指令操作"><a href="#3、简单Redis指令操作" class="headerlink" title="3、简单Redis指令操作"></a>3、简单Redis指令操作</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Do 方法将命令参数转换为批量字符串以传输到Redis服务器,交给Redis处理</span><br><span class="hljs-comment">//redis.String将Do操作后的返回值转换为String格式输出</span><br>s1, err := redis.String(c.Do(<span class="hljs-string">&quot;SET&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>, <span class="hljs-string">&quot;18&quot;</span>))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>fmt.Println(s1)<br><br>s2, err := redis.String(c.Do(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>fmt.Println(s2)<br><br>s3, err := redis.String(c.Do(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;linzydashuaige&quot;</span>))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>fmt.Println(s3)<br></code></pre></td></tr></table></figure><p><img src="/img/redis_redigo/redis.png"></p><blockquote><p>可以参考我上一篇文章<a href="https://linzyblog.netlify.app/2022/09/19/redis-five-basicdata-types/">《Redis五大基础数据类型》</a>，自己动手测试吧。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>数据库</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis（三）基础：Redis五大基础数据类型</title>
    <link href="/2022/09/19/redis-five-BasicData-types/"/>
    <url>/2022/09/19/redis-five-BasicData-types/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>Redis官网：<a href="https://redis.io/docs/">https://redis.io/docs/</a><br>Redis中文文档：<a href="http://www.redis.cn/topics/data-types-intro.html#strings">http://www.redis.cn/topics/data-types-intro.html#strings</a><br>结合官网的学习一定是正确合理的，如果有命令或者理论我讲的不对，可以评论指出谢谢！</p></blockquote><h1 id="一、Redis数据类型介绍"><a href="#一、Redis数据类型介绍" class="headerlink" title="一、Redis数据类型介绍"></a>一、Redis数据类型介绍</h1><p>Redis不仅只有key-value存储，实际上是一个<code>数据结构服务器</code>，支持不同的数据类型，可以解决从缓存到队列再到事件处理的各种问题。</p><ul><li>Strings：二进制安全的字符串</li><li>Lists：按插入顺序排序的字符串元素的集合。Redis 列表是字符串值的链表。（用于实现栈和队列）</li><li>Sets：<code>不重复且无序</code>的字符串元素的集合</li><li>Sorted sets：类似Sets，不同的地方在于每个字符串元素都关联一个叫<code>score</code>的浮动数值（floating number value）。里面的元素是按score进行排序。它可以检索一系列的元素。（可以直接看前10个元素或后10个元素）</li><li>Hashes：由field和关联的value组成的map。field和value都是字符串。实现类似于<code>哈希表</code>的概念。</li><li>Bit arrays (或者说 simply bitmaps)：通过特殊的命令，你可以将 String 值当作一系列 bits 处理：可以设置和清除单独的 bits，数出所有设为 1 的 bits 的数量，找到最前的被设为 1 或 0 的 bit，等等。</li><li>HyperLogLog：是一种概率数据结构，这是被用于估计一个 set 中元素数量的概率性的数据结构。</li></ul><p><img src="/img/Redis_five_BasicData_types/redis1.png"></p><h1 id="二、Redis-key"><a href="#二、Redis-key" class="headerlink" title="二、Redis key"></a>二、Redis key</h1><p><code>Redis key值是二进制安全的。</code>可以用任意二进制序列作为key值，如“linzy”简单字符串到JPEG文件的内容都可以作为key值。空值也是有效的key值。</p><blockquote><p>关于key的几条规则：</p><ol><li><code>键值不要太长</code>，例如：1024字节的键值不仅消耗大量内存，而且查询这个键值的成本也很高。</li><li><code>键值不要太短</code>，就好是简洁表达含义的键值，例如：”u:1000:pwd”和”user:1000:password”，前者虽然简短，但是后者更容易阅读，一眼就知道键值的含义，并且后者增加的空间消耗相对较小。不过这个算个人习惯，没有人必须要求你该怎么写。</li><li><code>坚持使用一种模式</code>，例如：”object-type : id : field”就是一个很不错的模式，像“user:1000:password”。对于多单词组合我习惯中间加<code>_</code>隔离，比如：”comment:123456:linzy_dashuaige“。</li><li>key允许最大为 512 MB。</li></ol></blockquote><h1 id="三、Redis-Strings"><a href="#三、Redis-Strings" class="headerlink" title="三、Redis Strings"></a>三、Redis Strings</h1><h2 id="1、字符串简介"><a href="#1、字符串简介" class="headerlink" title="1、字符串简介"></a>1、字符串简介</h2><p>Redis 字符串存储<code>字节序列</code>，包括文本、序列化对象和二进制数组。因此，字符串是Redis最基本的数据类型。字符串用于缓存，通过提供的额外的功能也可以实现计算器以及按位运算。</p><h2 id="2、字符串基本操作"><a href="#2、字符串基本操作" class="headerlink" title="2、字符串基本操作"></a>2、字符串基本操作</h2><h3 id="1）通用命令"><a href="#1）通用命令" class="headerlink" title="1）通用命令"></a>1）通用命令</h3><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">set key value <br><strong>[NX | XX] [GET] [EX seconds | PX milliseconds |   <br>EXAT unix-time-seconds | PXAT unix-time-milliseconds | KEEPTTL]</strong></td><td align="left">添加 &#x2F; 修改一个键值对。<br> EX(expire)：设置过期秒数<br>PX：设置过期毫秒数<br>EXAT：设置过期的Unix秒数<br>PXAT：设置过期的Unix毫秒数<br>KEEPTTL：set时不重置<code>ttl</code><br>NX：只有当key不存在时添加一个新的键值对<br>XX：仅当key存在时覆盖当前value<br>GET：修改一个键值并返回原值，如果原址不存在则返回nil</td></tr><tr><td align="left">get key</td><td align="left">获取key对应的value值。<br>注：key不存在会直接返回nil</td></tr><tr><td align="left">mset key1 value1 [key2 value2…]</td><td align="left">添加 &#x2F; 修改一个或多个键值对。</td></tr><tr><td align="left">mget key1 [key2…]</td><td align="left">获取key1 key2..获取对应的value1 value2 …</td></tr></tbody></table><blockquote><p>注意：由于SET命令选项可以替换SETNX, SETEX, PSETEX, GETSET，因此在未来的 Redis 版本中，这些命令可能会被弃用并最终被删除。</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#添加一个key为&quot;name&quot; 值为&quot;linzy&quot;的键值对</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-built_in">set</span> name linzy <br>OK<br><span class="hljs-comment">#查看key为name对应的值</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; get name <br><span class="hljs-string">&quot;linzy&quot;</span><br><span class="hljs-comment">#设置key为name的键值对10秒后过期</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-built_in">set</span> name linzydashuaige EX <span class="hljs-number">10</span> <br>OK<br><span class="hljs-comment">#查看key剩余多少生存时间,key不存在则返回-2，永久键值对则返回-1</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; ttl name <br>(integer) <span class="hljs-number">6</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; ttl name<br>(integer) <span class="hljs-number">4</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; ttl name<br>(integer) <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; ttl name<br>(integer) <span class="hljs-number">2</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; ttl name<br>(integer) <span class="hljs-literal">-2</span><br><span class="hljs-comment">#清空当前库的所有键值对</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; flushdb <br>OK<br><span class="hljs-comment">#添加多条键值对</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; mset k1 v1 k2 v2 <br>OK<br><span class="hljs-comment">#查看当前库的所有键值对</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; keys * <br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;k2&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;k1&quot;</span><br><span class="hljs-comment">#如果查不到则返回nil</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; mget k1 k3 <br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;v1&quot;</span><br><span class="hljs-number">2</span>) (nil)<br><span class="hljs-comment">#添加一个key为k1 值为v2的键值对，只有k1不存在才执行</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-built_in">set</span> k1 v2 NX <br>(nil)<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; get k1<br><span class="hljs-string">&quot;v1&quot;</span><br><span class="hljs-comment">#将key为k1的值修改为v2，只有k1存在才执行 </span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-built_in">set</span> k1 v2 XX <br>OK<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; get k1<br><span class="hljs-string">&quot;v2&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-built_in">set</span> k1 v50 GET<br><span class="hljs-string">&quot;v2&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/Redis_five_BasicData_types/redis2.png"></p><h3 id="2）value是字符串时操作"><a href="#2）value是字符串时操作" class="headerlink" title="2）value是字符串时操作"></a>2）value是字符串时操作</h3><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">append key value</td><td align="left">在key对应原有的value后追加内容。<br>注：如果键值对不存在，则会创建新的键值对，类似于set的功能</td></tr><tr><td align="left">strlen key</td><td align="left">对应value的字符串值的长度。<br>注：如果value非字符串类型则返回错误</td></tr><tr><td align="left">getrange key start end</td><td align="left">获取[start，end]范围内的子字符串。<br>注：可以使用<code>负偏移量</code>来提供从字符串末尾开始的偏移量。所以 -1 表示最后一个字符，-2 表示倒数第二个字符，依此类推。</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-built_in">set</span> name linzy<br>OK<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; get name<br><span class="hljs-string">&quot;linzy&quot;</span><br><span class="hljs-comment">#在key为name的内容后添加“dashuaibi”</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; append name dashuaibi <br>(integer) <span class="hljs-number">14</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; get name<br><span class="hljs-string">&quot;linzydashuaibi&quot;</span><br><span class="hljs-comment">#获取key为name的字符串长度</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; strlen name <br>(integer) <span class="hljs-number">14</span><br><span class="hljs-comment">#获取key为name的字符串在[5, 14]范围内的子串</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; getrange name <span class="hljs-number">5</span> <span class="hljs-number">14</span> <br><span class="hljs-string">&quot;dashuaibi&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; getrange name <span class="hljs-number">0</span> <span class="hljs-number">4</span><br><span class="hljs-string">&quot;linzy&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; getrange name <span class="hljs-literal">-8</span> <span class="hljs-literal">-1</span><br><span class="hljs-string">&quot;ashuaibi&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/Redis_five_BasicData_types/redis3.png"></p><h3 id="3）value是数值的操作"><a href="#3）value是数值的操作" class="headerlink" title="3）value是数值的操作"></a>3）value是数值的操作</h3><p>有关于增量&#x2F;减量操作，如果键值对不存在，则会默认创建一个值为0的键值对。增量&#x2F;减量操作是<code>原子操作</code>。</p><blockquote><p>原子操作就是在多线程程序中“最小的且不可并行化的”操作，意味着多个线程访问同一个资源时，有且仅有一个线程能对资源进行操作。</p></blockquote><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">incr key</td><td align="left">将key对应的value加一。</td></tr><tr><td align="left">incrby key 整数</td><td align="left">将key对应的value增加给定的数值。</td></tr><tr><td align="left">incrbyfloat key 小数值</td><td align="left">将key对应的value增加给定的数值。</td></tr><tr><td align="left">decr key</td><td align="left">将key对应的value减一。</td></tr><tr><td align="left">decrby key 整数</td><td align="left">将key对应的value增加给定的数值。</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; keys *<br>(empty list or <span class="hljs-built_in">set</span>)<br><span class="hljs-comment">#将key为k1的值加一。k1不存在自动创建一个value为0的键值对</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; incr k1 <br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; get k1<br><span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-comment">#将key为k1的值加114514</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; incrby k1 <span class="hljs-number">114514</span> <br>(integer) <span class="hljs-number">114515</span><br><span class="hljs-comment">#将key为k1的值加-1000.05</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; incrbyfloat k1 <span class="hljs-literal">-1000</span>.<span class="hljs-number">05</span><br><span class="hljs-string">&quot;113514.95&quot;</span><br><span class="hljs-comment">#虽然value是数值，但是他的数据类型还是string,他依旧可以使用上面的指令</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-built_in">type</span> k1 <br>string<br><span class="hljs-comment">#将key为k1的值减一。k1不存在自动创建一个value为0的键值对</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; decr k2<br>(integer) <span class="hljs-literal">-1</span><br><span class="hljs-comment">#将key为k1的值减1000.02</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; decrby k2 <span class="hljs-number">1000.02</span><br>(error) ERR value is not an integer or out of range<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; decrby k2 <span class="hljs-number">1000</span><br>(integer) <span class="hljs-literal">-1001</span><br></code></pre></td></tr></table></figure><p><img src="/img/Redis_five_BasicData_types/redis4.png"></p><blockquote><p>String 数据结构是简单的key-value 类型，<code>value 其实不仅是String，也可以是数字。</code></p></blockquote><h3 id="4）临时键值对的操作"><a href="#4）临时键值对的操作" class="headerlink" title="4）临时键值对的操作"></a>4）临时键值对的操作</h3><p>生存时间（time to live），简称为<code>ttl</code>，指键值对距离被删除的剩余时间(秒数或者毫秒数)</p><blockquote><p>注：如果重新set设置生存时间，则会将之前的生存时间重置掉。</p></blockquote><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">expire key 秒数</td><td align="left">给键值对设置一个生存时间。<br>注：超时后只有对key执行DEL命令或者SET命令或者GETSET时才会清除。从概念上讲所有改变key的值的操作都会使他清除。</td></tr><tr><td align="left">ttl key</td><td align="left">查看当前键值对剩余生存时间。<br>注：key不存在则返回-2，永久键值对返回-1</td></tr><tr><td align="left">pexpire key 毫秒数</td><td align="left">毫秒版expire</td></tr><tr><td align="left">pttl key</td><td align="left">毫秒版ttl</td></tr><tr><td align="left">persist key</td><td align="left">持久化（取消生存时间）</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-built_in">set</span> name linzy<br>OK<br><span class="hljs-comment">#将key为name的键值对设置五秒后过期</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; expire name <span class="hljs-number">5</span> <br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; ttl name<br>(integer) <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; ttl name<br>(integer) <span class="hljs-literal">-2</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; keys *<br>(empty list or <span class="hljs-built_in">set</span>)<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-built_in">set</span> name linzy<br>OK<br><span class="hljs-comment">#将key为name的键值对设置5000毫秒后过期</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; pexpire name <span class="hljs-number">5000</span> <br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; pttl name <br>(integer) <span class="hljs-number">2681</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; pttl name<br>(integer) <span class="hljs-literal">-2</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-built_in">set</span> name linzy<br>OK<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; expire name <span class="hljs-number">100</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; ttl name<br>(integer) <span class="hljs-number">98</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; persist name<br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; ttl name<br>(integer) <span class="hljs-literal">-1</span><br></code></pre></td></tr></table></figure><p><img src="/img/Redis_five_BasicData_types/redis5.png"></p><h2 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h2><p>Redis String 类型是可以与 Redis 键关联的最简单的值类型。Redis就像一个可以持久化的memcached服务器（注：memcache的数据仅保存在内存中，服务器重启后，数据将丢失）。</p><p>由于 Redis 的键是字符串，所以当我们也使用字符串类型作为值时，我们是在将一个字符串映射到另一个字符串。字符串数据类型可用于许多用例，例如缓存 HTML 片段或页面。</p><h1 id="四、Redis-Lists"><a href="#四、Redis-Lists" class="headerlink" title="四、Redis Lists"></a>四、Redis Lists</h1><h2 id="1、列表简介"><a href="#1、列表简介" class="headerlink" title="1、列表简介"></a>1、列表简介</h2><p>列表就是有序元素的序列，一般意义由两种数组（List）和链表（Linked List），例如 50，3，114514，20就是一个列表。</p><p><code>Redis lists基于链表实现。</code>这意味着即使在一个list中有数百万个元素，在头部或尾部添加一个元素的操作，其时间复杂度也是常数O(1)级别的。用LPUSH 命令在十个元素的list头部添加新元素，和在千万元素list头部添加新元素的速度相同。</p><p>那么，坏消息是什么？在数组实现的list中利用索引访问元素的速度极快，而同样的操作在链表实现的list上没有那么快。</p><p>Redis Lists用链表实现的原因是：对于数据库系统来说，至关重要的特性是：能非常快的在很大的列表上添加元素。另一个重要因素是，正如你将要看到的：Redis lists能在常数时间取得常数长度。</p><blockquote><p>如果需要快速访问集合元素，建议使用可排序集合(sorted sets)。</p></blockquote><h2 id="2、列表基本操作"><a href="#2、列表基本操作" class="headerlink" title="2、列表基本操作"></a>2、列表基本操作</h2><h3 id="1）通用命令-1"><a href="#1）通用命令-1" class="headerlink" title="1）通用命令"></a>1）通用命令</h3><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">rpush key value0 [value1…]</td><td align="left">在列表尾部添加一个或多个value值。</td></tr><tr><td align="left">lpush key value0 [value1…]</td><td align="left">在列表头部添加一个或多个value值。</td></tr><tr><td align="left">rpushx key value0 [value1…]</td><td align="left">仅当列表存在时，在列表尾部添加一个或多个value值。</td></tr><tr><td align="left">lpushx key value0 [value1…]</td><td align="left">仅当列表存在时，在列表头部添加一个或多个value值。</td></tr><tr><td align="left">rpop key [整数]</td><td align="left">移除并返回存于 key 的 list 的尾部指定数值个元素。<br> 注：与lpush组合可以实现队列，与rpush组合可以实现栈。</td></tr><tr><td align="left">lpop key [整数]</td><td align="left">移除并返回存于 key 的 list 的头部指定数值个元素。<br> 注：与rpush组合可以实现队列，与lpush组合可以实现栈。</td></tr><tr><td align="left">lrange key start end</td><td align="left">查看[start，end]范围内的子序列。<br>注：lrange key 0 -1 查看列表所有值</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#在key为nums的列表尾部添加[50, 3, 20, 114514]。如果键值对不存在，会自动创建一个键值对。</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; rpush nums <span class="hljs-number">50</span> <span class="hljs-number">3</span> <span class="hljs-number">20</span> <span class="hljs-number">114514</span> <br>(integer) <span class="hljs-number">4</span><br><span class="hljs-comment">#获取nums整个列表</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lrange nums <span class="hljs-number">0</span> <span class="hljs-literal">-1</span> <br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;50&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;20&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;114514&quot;</span><br><span class="hljs-comment"># 在key为nums的列表头部添加[11451415, 666, 233]</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lpush nums <span class="hljs-number">11451415</span> <span class="hljs-number">666</span> <span class="hljs-number">233</span> <br>(integer) <span class="hljs-number">7</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lrange nums <span class="hljs-number">0</span> <span class="hljs-literal">-1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;233&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;666&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;11451415&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;50&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;20&quot;</span><br><span class="hljs-number">7</span>) <span class="hljs-string">&quot;114514&quot;</span><br><span class="hljs-comment"># 移除并返回key为nums的列表尾部一个元素</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; rpop nums <br><span class="hljs-string">&quot;114514&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; rpop nums <span class="hljs-number">2</span> <br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;20&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-comment"># 移除并返回key为nums的列表头部一个元素</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lpop nums <br><span class="hljs-string">&quot;233&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lpop nums <span class="hljs-number">2</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;666&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;11451415&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lrange <span class="hljs-number">0</span> <span class="hljs-literal">-1</span><br>(error) ERR wrong number of arguments <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;lrange&#x27;</span> command<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lrange nums <span class="hljs-number">0</span> <span class="hljs-literal">-1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;50&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; rpushx nums <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>(integer) <span class="hljs-number">5</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lrange nums <span class="hljs-number">0</span> <span class="hljs-literal">-1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;50&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;2&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;4&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lpushx nums <span class="hljs-number">1145</span>,<span class="hljs-number">14</span>,<span class="hljs-number">45</span>,<span class="hljs-number">14</span><br>(integer) <span class="hljs-number">6</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lrange nums <span class="hljs-number">0</span> <span class="hljs-literal">-1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;1145,14,45,14&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;50&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;2&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;4&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/Redis_five_BasicData_types/redis6.png"></p><h3 id="2）数组操作"><a href="#2）数组操作" class="headerlink" title="2）数组操作"></a>2）数组操作</h3><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">lset key index value</td><td align="left">将指定index位置上的元素修改为value。</td></tr><tr><td align="left">linsert key &lt;before &#x2F; after&gt; pivot value</td><td align="left">在基准值pivot的前 &#x2F; 后插入一个值。</td></tr><tr><td align="left">lindex key index</td><td align="left">按索引查看值。</td></tr><tr><td align="left">llen key</td><td align="left">查看列表长度。</td></tr><tr><td align="left">lrem key 整数 value</td><td align="left">删除整数个指定数值。<br>注：整数为正从左开始删，为负从尾部开始删</td></tr><tr><td align="left">ltrim key start end</td><td align="left">只保留[start, end]范围的列表。</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; rpush mylist linzy haoshuai<br>(integer) <span class="hljs-number">2</span><br><span class="hljs-comment"># 将key为mylist的列表索引为1的值改为dashuaige</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lset mylist <span class="hljs-number">1</span> dashuaige <br>OK<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lrange mylist <span class="hljs-number">0</span> <span class="hljs-literal">-1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;linzy&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;dashuaige&quot;</span><br><span class="hljs-comment"># 在key为mylist的列表的基准值&quot;dashuaige&quot;之前插入元素&quot;shi&quot;。（基准值就是从左往右找到的第一个元素就是基准值）</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; linsert mylist before dashuaige shi <br>(integer) <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lrange mylist <span class="hljs-number">0</span> <span class="hljs-literal">-1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;linzy&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;shi&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;dashuaige&quot;</span><br><span class="hljs-comment"># 获取key为mylist的列表索引为1的值</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lindex mylist <span class="hljs-number">1</span> <br><span class="hljs-string">&quot;shi&quot;</span><br><span class="hljs-comment"># 获取key为mylist的列表长度</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; llen mylist <br>(integer) <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; rpush mylist <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br>(integer) <span class="hljs-number">8</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lrange mylist <span class="hljs-number">0</span> <span class="hljs-literal">-1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;linzy&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;shi&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;dashuaige&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">7</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">8</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-comment"># 在key为mylist的列表从左往右删除3个&quot;1&quot;元素</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lrem mylist <span class="hljs-number">3</span> <span class="hljs-number">1</span> <br>(integer) <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lrange mylist <span class="hljs-number">0</span> <span class="hljs-literal">-1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;linzy&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;shi&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;dashuaige&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lpush mylist <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br>(integer) <span class="hljs-number">8</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lrange mylist <span class="hljs-number">0</span> <span class="hljs-literal">-1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;linzy&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;shi&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;dashuaige&quot;</span><br><span class="hljs-number">7</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">8</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-comment"># 在key为mylist的列表从右往左删除3个&quot;1&quot;元素</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lrem mylist <span class="hljs-literal">-3</span> <span class="hljs-number">1</span> <br>(integer) <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lrange mylist <span class="hljs-number">0</span> <span class="hljs-literal">-1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;linzy&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;shi&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;dashuaige&quot;</span><br><span class="hljs-comment"># key为mylist的列表只保留[2, 5]的范围的子序列</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; ltrim mylist <span class="hljs-number">2</span> <span class="hljs-number">5</span> <br>OK<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; lrange mylist <span class="hljs-number">0</span> <span class="hljs-literal">-1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;linzy&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;shi&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;dashuaige&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/Redis_five_BasicData_types/redis7.png"><br><img src="/img/Redis_five_BasicData_types/redis8.png"></p><blockquote><p>列表索引从0开始，-n表示倒数第n个值。</p></blockquote><h2 id="3、小结-1"><a href="#3、小结-1" class="headerlink" title="3、小结"></a>3、小结</h2><p>列表访问其头部或尾部的列表操作是 O(1)，非常高效。但是，操作列表中元素的命令通常是 O(n)。这些示例包括LINDEX、LINSERT和LSET。运行这些命令时要小心，主要是在处理大型列表时。</p><p><code>列表可被用来实现聊天系统。还可以作为不同进程间传递消息的队列。</code>关键是，你可以每次都以原先添加的顺序访问数据。这不需要任何SQL ORDER BY 操作，将会非常快，也会很容易扩展到百万级别元素的规模。</p><p>例如在评级系统中，比如社会化新闻网站 reddit.com，你可以把每个新提交的链接添加到一个list，用LRANGE可简单的对结果分页。</p><p>在博客引擎实现中，你可为每篇日志设置一个list，在该list中推入博客评论，等等。</p><h1 id="五、Redis-Hashes"><a href="#五、Redis-Hashes" class="headerlink" title="五、Redis Hashes"></a>五、Redis Hashes</h1><h2 id="1、哈希简介"><a href="#1、哈希简介" class="headerlink" title="1、哈希简介"></a>1、哈希简介</h2><p>Redis 哈希是字符串字段和字符串值之间的映射。可以使用哈希来表示基本对象并存储计数器分组等。</p><h2 id="2、哈希基本操作"><a href="#2、哈希基本操作" class="headerlink" title="2、哈希基本操作"></a>2、哈希基本操作</h2><h3 id="1）通用命令-2"><a href="#1）通用命令-2" class="headerlink" title="1）通用命令"></a>1）通用命令</h3><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">hset key field1 value1 [field2 value2…]</td><td align="left">添加一个键与一或多个指定字段的值。<br>注：如果哈希表不存在，会自动创建一个哈希表</td></tr><tr><td align="left">hget key field</td><td align="left">获取哈希表对应的field字段所关联的值。</td></tr><tr><td align="left">hmget key field1 [field2…]</td><td align="left">获取哈希表对应的field1, field2…字段所关联的值。</td></tr><tr><td align="left">hdel key field1 [field2…]</td><td align="left">删除哈希表对应的field1, field2..字段。</td></tr><tr><td align="left">hsetnx key field value</td><td align="left">仅当field不存在时才添加field-value</td></tr><tr><td align="left">hkeys key</td><td align="left">查看哈希表所有的field</td></tr><tr><td align="left">hvals key</td><td align="left">查看哈希表所有的value</td></tr><tr><td align="left">hlen key</td><td align="left">获取哈希表有多少对field-value</td></tr><tr><td align="left">hexists key field</td><td align="left">查看field是否存在</td></tr><tr><td align="left">hstrlen key field</td><td align="left">获取哈希表里field的值的长度</td></tr></tbody></table><blockquote><p>*哈希表： key对应的哈希表</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 创建一个key为myhash的哈希表，并在哈希表里面添加f1-v1 f2-v2 f3-v3的字段</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hset myhash f1 v1 f2 v2 f3 v3 <br>(integer) <span class="hljs-number">3</span><br><span class="hljs-comment"># 获取key为myhash的哈希表里f1对应的值</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hget myhash f1 <br><span class="hljs-string">&quot;v1&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hget myhash f4<br>(nil)<br><span class="hljs-comment"># 获取key为myhash的哈希表里f3,f1,f5字段对应的值</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hmget myhash f3 f1 f5 <br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;v3&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;v1&quot;</span><br><span class="hljs-number">3</span>) (nil)<br><span class="hljs-comment"># 删除key为myhash的哈希表里f2 f4的字段</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hdel myhash f2 f4 <br>(integer) <span class="hljs-number">1</span><br><span class="hljs-comment"># 在哈希表里面添加KFC-v50的字段</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hsetnx myhash KFC v50 <br>(integer) <span class="hljs-number">1</span><br><span class="hljs-comment"># 获取哈希表里所有的field字段</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hkeys myhash <br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;f1&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;f3&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;KFC&quot;</span><br><span class="hljs-comment"># 获取哈希表里所有的value值</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hvals myhash <br>u<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;v1&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;v3&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;v50&quot;</span><br><span class="hljs-comment"># 获取哈希表里有多少field字段</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hlen myhash <br>(integer) <span class="hljs-number">3</span><br><span class="hljs-comment"># 判断哈希表里是否存在KFC字段</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hexists myhash KFC <br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hexists myhash fff<br>(integer) <span class="hljs-number">0</span><br><span class="hljs-comment"># 获取哈希表里KFC字段对应的值的长度</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hstrlen myhash KFC <br>(integer) <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><img src="/img/Redis_five_BasicData_types/redis9.png"></p><h3 id="2）value是数值的操作"><a href="#2）value是数值的操作" class="headerlink" title="2）value是数值的操作"></a>2）value是数值的操作</h3><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">hincrby key field 整数</td><td align="left">将key对应的哈希表的field字段的值添加指定数值。</td></tr><tr><td align="left">hincrbyfloat key field 小数值</td><td align="left">将key对应的哈希表的field字段的值添加指定小数值。</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hset myhash f1 <span class="hljs-number">1</span> f2 <span class="hljs-number">2</span> KFC <span class="hljs-number">50</span><br>(integer) <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hincrby myhash f1 <span class="hljs-number">1</span><br>(integer) <span class="hljs-number">2</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hincrby myhash f2 <span class="hljs-number">10</span><br>(integer) <span class="hljs-number">12</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; hincrbyfloat myhash KFC <span class="hljs-number">11.4514</span><br><span class="hljs-string">&quot;61.4514&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/Redis_five_BasicData_types/redis10.png"></p><h2 id="3、小结-2"><a href="#3、小结-2" class="headerlink" title="3、小结"></a>3、小结</h2><p>一个拥有少量（100个左右）字段的hash需要 很少的空间来存储，所有你可以在一个小型的 Redis实例中存储上百万的对象。</p><p>尽管Hashes主要用来表示对象，但它们也能够存储许多元素，所以你也可以用Hashes来完成许多其他的任务。</p><p>一个hash最多可以包含2^32^-1 个key-value键值对（超过40亿）。</p><h1 id="六、Redis-Sets"><a href="#六、Redis-Sets" class="headerlink" title="六、Redis Sets"></a>六、Redis Sets</h1><h2 id="1、集合简介"><a href="#1、集合简介" class="headerlink" title="1、集合简介"></a>1、集合简介</h2><p>Redis集合是一个<code>无序</code>的字符串合集。你可以以O(1) 的时间复杂度（无论集合中有多少元素时间复杂度都为常量）完成 <code>添加，删除以及测试元素是否存在</code>的操作。</p><p>集合的特性：集合内的元素都是唯一的，向集合多次添加同一个元素时，集合只会保留一个元素，添加元素的前就可以不用判断元素是否存在。</p><h2 id="2、集合基本操作"><a href="#2、集合基本操作" class="headerlink" title="2、集合基本操作"></a>2、集合基本操作</h2><h3 id="1）通用命令-3"><a href="#1）通用命令-3" class="headerlink" title="1）通用命令"></a>1）通用命令</h3><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">sadd key element  [element …]</td><td align="left">添加一个或多个元素到集合内。<br>注：集合不存在时，会自动创建一个集合，并把元素添加进去</td></tr><tr><td align="left">scard key</td><td align="left">获取集合内元素的数量。</td></tr><tr><td align="left">smembers key</td><td align="left">获取集合内所有的元素。</td></tr><tr><td align="left">srem key element [element…]</td><td align="left">在集合中删除一个或多个元素。</td></tr><tr><td align="left">sismember key element</td><td align="left">查看集合中是否存在member元素。</td></tr><tr><td align="left">smismember key element [element…]</td><td align="left">查看集合中是否存在一个或多个元素。</td></tr><tr><td align="left">srandmember key [数量]</td><td align="left">随机查看指定数量的成员。</td></tr><tr><td align="left">spop key [数量]</td><td align="left">随机删除指定数量的成员。</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 添加[a, 1, b, c, 5, 6, 7, 8]元素到myset集合内</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; sadd myset a <span class="hljs-number">1</span> b c <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <br>(integer) <span class="hljs-number">8</span><br><span class="hljs-comment"># 获取myset集合元素数量</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; scard myset <br>(integer) <span class="hljs-number">8</span><br><span class="hljs-comment"># 获取myset集合内所有元素，元素是无序的</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; smembers myset <br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;8&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;6&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;5&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;b&quot;</span><br><span class="hljs-number">7</span>) <span class="hljs-string">&quot;7&quot;</span><br><span class="hljs-number">8</span>) <span class="hljs-string">&quot;c&quot;</span><br><span class="hljs-comment"># 删除myset集合内的元素，只会删除集合内存在的元素</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; srem myset b d <span class="hljs-number">1</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <br>(integer) <span class="hljs-number">4</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; smembers myset<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;6&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;5&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;c&quot;</span><br><span class="hljs-comment"># 查看元素5是否存在</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; sismember myset <span class="hljs-number">5</span> <br>(integer) <span class="hljs-number">1</span><br> <span class="hljs-comment"># 查看[1, b, a, 5, 8]元素是否存在，存在为1，不存在为0</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; smismember myset <span class="hljs-number">1</span> b a <span class="hljs-number">5</span> <span class="hljs-number">8</span><br><span class="hljs-number">1</span>) (integer) <span class="hljs-number">0</span><br><span class="hljs-number">2</span>) (integer) <span class="hljs-number">0</span><br><span class="hljs-number">3</span>) (integer) <span class="hljs-number">1</span><br><span class="hljs-number">4</span>) (integer) <span class="hljs-number">1</span><br><span class="hljs-number">5</span>) (integer) <span class="hljs-number">0</span><br><span class="hljs-comment"># 随机取出一个元素</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; srandmember myset <br><span class="hljs-string">&quot;5&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; srandmember myset <span class="hljs-number">3</span> <br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;6&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;c&quot;</span><br><span class="hljs-comment"># 随机删除两个元素</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; spop myset <span class="hljs-number">2</span> <br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;c&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; smembers myset<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;6&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;5&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/Redis_five_BasicData_types/redis11.png"></p><h3 id="2）交集、并集以及差集"><a href="#2）交集、并集以及差集" class="headerlink" title="2）交集、并集以及差集"></a>2）交集、并集以及差集</h3><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">smove key1 key2 element</td><td align="left">将集合1的指定元素移动到集合2。</td></tr><tr><td align="left">sinter key1 [key2…]</td><td align="left">查看给定集合的交集。<br>注：多个集合交集，是两个集合先取交集，交集再跟后面的集合去交集。</td></tr><tr><td align="left">sinterstore newkey key1 [key2…]</td><td align="left">将给定集合的交集创建为新的集合newkey。</td></tr><tr><td align="left">sunion key1 [key2…]</td><td align="left">查看给定集合的并集。</td></tr><tr><td align="left">sunionstore newkey key1 [key2…]</td><td align="left">将给定集合的并集创建为新的集合newkey。</td></tr><tr><td align="left">sdiff  key1 [key2…]</td><td align="left">查看给定集合的差集。<br>差集：集合1存在的，在集合2内不存在的元素。</td></tr><tr><td align="left">sdiffstore newkey key1 [key2…]</td><td align="left">将给定集合的差集创建为新的集合newkey。</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 将set1集合内的元素3移到set2集合</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; sadd set1 a b c d <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br>(integer) <span class="hljs-number">7</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; sadd set2 c d e <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span><br>(integer) <span class="hljs-number">6</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; smove set1 set2 <span class="hljs-number">3</span> <br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; smembers set2<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;e&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;c&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;0&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;5&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;d&quot;</span><br><span class="hljs-number">7</span>) <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-comment"># 查看set1集合与set2集合的交集</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; sinter set1 set2 <br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;d&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;c&quot;</span><br><span class="hljs-comment"># 将set1集合与set2集合的交集存储到setinter集合内</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; sinterstore setinter set1 set2 <br>(integer) <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; smembers setinter<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;d&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;c&quot;</span><br><span class="hljs-comment"># 查看set1集合与set2集合的并集</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; sunion set1 set2 <br> <span class="hljs-number">1</span>) <span class="hljs-string">&quot;c&quot;</span><br> <span class="hljs-number">2</span>) <span class="hljs-string">&quot;2&quot;</span><br> <span class="hljs-number">3</span>) <span class="hljs-string">&quot;0&quot;</span><br> <span class="hljs-number">4</span>) <span class="hljs-string">&quot;a&quot;</span><br> <span class="hljs-number">5</span>) <span class="hljs-string">&quot;5&quot;</span><br> <span class="hljs-number">6</span>) <span class="hljs-string">&quot;1&quot;</span><br> <span class="hljs-number">7</span>) <span class="hljs-string">&quot;d&quot;</span><br> <span class="hljs-number">8</span>) <span class="hljs-string">&quot;b&quot;</span><br> <span class="hljs-number">9</span>) <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-number">10</span>) <span class="hljs-string">&quot;e&quot;</span><br><span class="hljs-comment"># 将set1集合与set2集合的并集存储到setunion集合内</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; sunionstore setunion set1 set2 <br>(integer) <span class="hljs-number">10</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; smembers setunion<br> <span class="hljs-number">1</span>) <span class="hljs-string">&quot;c&quot;</span><br> <span class="hljs-number">2</span>) <span class="hljs-string">&quot;2&quot;</span><br> <span class="hljs-number">3</span>) <span class="hljs-string">&quot;0&quot;</span><br> <span class="hljs-number">4</span>) <span class="hljs-string">&quot;a&quot;</span><br> <span class="hljs-number">5</span>) <span class="hljs-string">&quot;5&quot;</span><br> <span class="hljs-number">6</span>) <span class="hljs-string">&quot;1&quot;</span><br> <span class="hljs-number">7</span>) <span class="hljs-string">&quot;d&quot;</span><br> <span class="hljs-number">8</span>) <span class="hljs-string">&quot;b&quot;</span><br> <span class="hljs-number">9</span>) <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-number">10</span>) <span class="hljs-string">&quot;e&quot;</span><br><span class="hljs-comment"># 查看set1集合与set2集合的差集</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; sdiff set1 set2 <br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;2&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;b&quot;</span><br><span class="hljs-comment"># 将set1集合与set2集合的差集存储到setdiff集合内</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; sdiffstore setdiff set1 set2 <br>(integer) <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; smembers setdiff<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;2&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;b&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/Redis_five_BasicData_types/redis12.png"><br><img src="/img/Redis_five_BasicData_types/redis13.png"></p><h2 id="3、小结-3"><a href="#3、小结-3" class="headerlink" title="3、小结"></a>3、小结</h2><p>Redis集合是一个无序的字符串合集。<br>集合可以高效的处理：</p><ul><li>用集合跟踪一个独特的事。想要知道所有访问某个博客文章的独立IP？只要每次都用<code>sadd</code>来处理一个页面访问。那么你可以肯定重复的IP是不会插入的。</li><li>Redis集合能很好的表示关系。你可以创建一个tagging系统，然后用集合来代表单个tag。接下来你可以用<code>sadd</code>添加命令把所有拥有tag的对象的所有ID添加进集合，这样来表示这个特定的tag。如果你想要同时有3个不同tag的所有对象的所有ID，那么你需要使用<code>sinter</code>交集命令。</li><li>使用<code>spop</code>或者<code>srandmember</code>命令随机地获取元素。</li><li>支持一些服务端的命令从现有的集合出发去进行集合运算。 所以你可以在很短的时间内完成合并（union）,求交(intersection), 找出不同元素的操作。</li></ul><h1 id="七、Redis-Sorted-Sets"><a href="#七、Redis-Sorted-Sets" class="headerlink" title="七、Redis Sorted Sets"></a>七、Redis Sorted Sets</h1><h2 id="1、有序集合简介"><a href="#1、有序集合简介" class="headerlink" title="1、有序集合简介"></a>1、有序集合简介</h2><p>有序集合与集合类似，不同的地方在于每个字符串元素都关联一个叫<code>score</code>的浮动数值（floating number value）。里面的元素是按score进行排序，当多个字符串具有相同的<code>score</code>时，这些字符串按<code>字典序</code>排列。</p><p>使用有序集合，你可以非常快地（O(log(N))）完成<code>添加，删除和更新元素</code>的操作。 因为元素是在插入时就排好序的，所以很快地通过分数(score)或者 位次(position)获得一个范围的元素。 </p><p>访问有序集合的中间元素同样也是非常快的，因此你可以使用有序集合作为一个没有重复成员的<code>优先队列</code>(c++里面的优先队列的概念)。 在这个列表中， 你可以轻易地访问任何你需要的东西: 有序的元素，快速的存在性测试，快速访问集合中间元素！</p><h2 id="2、有序集合基本操作"><a href="#2、有序集合基本操作" class="headerlink" title="2、有序集合基本操作"></a>2、有序集合基本操作</h2><h3 id="1）-通用命令"><a href="#1）-通用命令" class="headerlink" title="1） 通用命令"></a>1） 通用命令</h3><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">zadd key <br>[NX | XX] [GT | LT] [CH] [INCR]<br> score1 element [score2 element…]</td><td align="left">添加一个或多个元素，每个元素都有一个分数(score)用于排序。<br>NX：只有元素不存在的时候才添加<br>XX：只有元素存在时修改元素<br>LT(less than)：只有在分数score低于原来元素的分数时才更新分数<br>GT(greater than)：只有在分数score高于原来元素的分数时才更新分数<br><strong>注：NX不可与GT\LT同时使用</strong><br>CH(changed)：返回变更的元素数量，默认返回新增的元素数量<br>INCR：累加分数<br><strong>注：INCR只能操作一个分数-元素对</strong></td></tr><tr><td align="left">zrem key element [element…]</td><td align="left">删除有序集合内一个或多个元素。</td></tr><tr><td align="left">zcount key left right</td><td align="left">获取在[left, right]区间内的元素数量。<br><strong>注：默认闭区间，开区间在分数前加 <code>(</code><br>支持无穷大表示：<code>inf</code>表示正无穷大，<code>-inf</code>表示负无穷大</strong></td></tr><tr><td align="left">zscore key element</td><td align="left">查看有序集合内指定元素的分数。<br><strong>注：元素不存在返回nil</strong></td></tr><tr><td align="left">zmscore key element1 [element2…]</td><td align="left">查看有序集合内指定元素element1，element2…的分数。</td></tr><tr><td align="left">zcard key</td><td align="left">查看有序集合内元素数量。</td></tr><tr><td align="left">zincrby key 数值 element</td><td align="left">给有序集合内指定元素的分数增加指定数值。</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 添加元素100-linzy, 10-ww, 50-KFC, 66-hh到有序集合内mysset, NX只有元素不存在才添加</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zadd mysset NX <span class="hljs-number">100</span> linzy <span class="hljs-number">10</span> ww <span class="hljs-number">50</span> KFC <span class="hljs-number">66</span> hh <br>(integer) <span class="hljs-number">4</span><br><span class="hljs-comment"># 查看有序集合mysset内指定区间内的元素 byscore按照分数排序，withscores显示分数</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zrange mysset <span class="hljs-literal">-inf</span> inf byscore withscores <br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;ww&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;10&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;KFC&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;50&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;hh&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;66&quot;</span><br><span class="hljs-number">7</span>) <span class="hljs-string">&quot;linzy&quot;</span><br><span class="hljs-number">8</span>) <span class="hljs-string">&quot;100&quot;</span><br><span class="hljs-comment"># 删除有序集合内ww元素</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zrem mysset ww <br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zrange mysset <span class="hljs-literal">-inf</span> inf byscore withscores<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;KFC&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;50&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;hh&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;66&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;linzy&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;100&quot;</span><br><span class="hljs-comment"># 查看有序集合内KFC的分数</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zscore mysset KFC<br><span class="hljs-string">&quot;50&quot;</span><br><span class="hljs-comment"># 批量查看分数</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zmscore mysset KFC linzy gggg <br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;50&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;100&quot;</span><br><span class="hljs-number">3</span>) (nil)<br><span class="hljs-comment"># 查看mysset有序集合内有多少元素</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zcard mysset <br>(integer) <span class="hljs-number">3</span><br><span class="hljs-comment"># 给mysset有序集合内指定元素hh的分数增加10</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zincrby mysset <span class="hljs-number">10</span> hh <br><span class="hljs-string">&quot;76&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zrange mysset <span class="hljs-literal">-inf</span> inf byscore withscores<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;KFC&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;50&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;hh&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;76&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;linzy&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;100&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/Redis_five_BasicData_types/redis14.png"></p><h3 id="2）区间操作"><a href="#2）区间操作" class="headerlink" title="2）区间操作"></a>2）区间操作</h3><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">zrange key left right <br>[BYSCORE | BYLEX] [REV] <br> [LIMIT 偏移量 查看数量] [WITHSCORES]</td><td align="left">查看分数在[left, right]区间内元素。<br>BYSCORE：按分数升序排列。<br><strong>注：BYSCORE支持开区间，需要在分数前加<code>(</code><br>支持无穷大表示：<code>inf</code>表示正无穷大，<code>-inf</code>表示负无穷大</strong><br>BYLEX：分数相同时，按照元素<code>字典序</code>排序<br><strong>注：BYLEX指定字符串区间要指定开闭区间：”[string”表示闭区间，”(string”表示开区间<br>BYLEX支持选取从开始到结束：”-“表示开始，”+”表示结束</strong><br>REV(reverse)：有序集合排序后反转。<br>LIMIT：用于指定查看的范围<br><strong>注：仅在BYSCORE&#x2F;BYLEX时可用</strong><br>WITHSCORES：输出时元素与分数一起输出</td></tr><tr><td align="left">zrangestore newkey key left right</td><td align="left">将有序集合[left, right]区间内的元素存储到newkey有序集合内。<br><strong>注：类似zrange key left right BYSCORE | BYLEX] [REV]  [LIMIT 偏移量 查看数量]</strong></td></tr><tr><td align="left">zlexcount key startString endString</td><td align="left">查看有序集合内指定字符串区间的元素数量。<br><strong>注：类似zrange key startString endString BYLEX</strong></td></tr><tr><td align="left">zremrangebyscore key minScore maxScore</td><td align="left">删除有序集合内指定分数区间的所有元素。<br><strong>注：类似zrange key minScore maxScore BYSCORE</strong></td></tr><tr><td align="left">zrank key element</td><td align="left">查看有序集合内指定元素的升序排名。<br><strong>注：排名从第0位开始</strong></td></tr><tr><td align="left">zrevrank key element</td><td align="left"></td></tr><tr><td align="left">zremrangebyrank key startRank endRank</td><td align="left">删除有序集合内指定排名区间的所有元素。<br><strong>注：排名从第0位开始，-n表示倒数第几名</strong></td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zadd myzset <span class="hljs-number">50</span> KFC <span class="hljs-number">100</span> linzy <span class="hljs-number">0</span> aa <span class="hljs-number">0</span> bb <span class="hljs-number">0</span> nn <span class="hljs-number">0</span> zz<br>(integer) <span class="hljs-number">6</span><br><span class="hljs-comment"># 查看myzset有序集合内所有元素，升序且带分数显示</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zrange myzset <span class="hljs-literal">-inf</span> inf byscore withscores <br> <span class="hljs-number">1</span>) <span class="hljs-string">&quot;aa&quot;</span><br> <span class="hljs-number">2</span>) <span class="hljs-string">&quot;0&quot;</span><br> <span class="hljs-number">3</span>) <span class="hljs-string">&quot;bb&quot;</span><br> <span class="hljs-number">4</span>) <span class="hljs-string">&quot;0&quot;</span><br> <span class="hljs-number">5</span>) <span class="hljs-string">&quot;nn&quot;</span><br> <span class="hljs-number">6</span>) <span class="hljs-string">&quot;0&quot;</span><br> <span class="hljs-number">7</span>) <span class="hljs-string">&quot;zz&quot;</span><br> <span class="hljs-number">8</span>) <span class="hljs-string">&quot;0&quot;</span><br> <span class="hljs-number">9</span>) <span class="hljs-string">&quot;KFC&quot;</span><br><span class="hljs-number">10</span>) <span class="hljs-string">&quot;50&quot;</span><br><span class="hljs-number">11</span>) <span class="hljs-string">&quot;linzy&quot;</span><br><span class="hljs-number">12</span>) <span class="hljs-string">&quot;100&quot;</span><br><span class="hljs-comment"># 查看myzset有序集合(50, 100]分数区间内所有元素，rev反转，需要将maxScore写在左边，minScore写在右边</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zrange myzset <span class="hljs-number">100</span> (<span class="hljs-number">50</span> byscore withscores rev <br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;linzy&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;100&quot;</span><br><span class="hljs-comment"># 查看myzset有序集合内所有元素，升序且带分数显示，limit限制从索引为2的元素开始只显示三个元素</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zrange myzset <span class="hljs-literal">-inf</span> inf byscore withscores limit <span class="hljs-number">2</span> <span class="hljs-number">3</span> <br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;nn&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;0&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;zz&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;0&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;KFC&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;50&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zrange myzset [<span class="hljs-type">aa</span> [<span class="hljs-type">ff</span> <span class="hljs-type">bylex</span> <span class="hljs-type">withscores</span> <br>(<span class="hljs-type">error</span>) <span class="hljs-type">ERR</span> <span class="hljs-type">syntax</span> <span class="hljs-type">error</span>, <span class="hljs-type">WITHSCORES</span> <span class="hljs-type">not</span> <span class="hljs-type">supported</span> <span class="hljs-type">in</span> <span class="hljs-type">combination</span> <span class="hljs-type">with</span> <span class="hljs-type">BYLEX</span><br><span class="hljs-comment"># 查看有序集合分数相同时，按照字典序显示排名，不能用withscores，会报错</span><br><span class="hljs-number">127.0</span><span class="hljs-type">.0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-type">zrange</span> <span class="hljs-type">myzset</span> [<span class="hljs-type">aa</span> [<span class="hljs-type">ff</span> <span class="hljs-type">bylex</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;aa&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;bb&quot;</span><br><span class="hljs-comment"># 将myzset有序集合内[50，100]区间内所有元素存储到newzset有序集合内</span><br><span class="hljs-number">127.0</span><span class="hljs-type">.0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-type">zrangestore</span> <span class="hljs-type">newzset</span> <span class="hljs-type">myzset</span> <span class="hljs-number">50</span> <span class="hljs-number">100</span> <span class="hljs-type">byscore</span><br>(<span class="hljs-built_in">int</span><span class="hljs-type">eger</span>) <span class="hljs-number">2</span><br><span class="hljs-number">127.0</span><span class="hljs-type">.0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-type">zlexcount</span> <span class="hljs-type">myzset</span> <span class="hljs-type">ff</span> <span class="hljs-type">nn</span><br>(<span class="hljs-type">error</span>) <span class="hljs-type">ERR</span> <span class="hljs-type">min</span> <span class="hljs-type">or</span> <span class="hljs-type">max</span> <span class="hljs-type">not</span> <span class="hljs-type">valid</span> <span class="hljs-built_in">string</span> <span class="hljs-type">range</span> <span class="hljs-type">item</span><br><span class="hljs-comment"># 查看myzset有序集合内(ff，nn]区间内的所有元素</span><br><span class="hljs-number">127.0</span><span class="hljs-type">.0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-type">zlexcount</span> <span class="hljs-type">myzset</span> (<span class="hljs-type">ff</span> [<span class="hljs-type">nn</span><br>(<span class="hljs-built_in">int</span><span class="hljs-type">eger</span>) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-type">.0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-type">zlexcount</span> <span class="hljs-type">myzset</span> (<span class="hljs-type">aa</span> [<span class="hljs-type">nn</span><br>(<span class="hljs-built_in">int</span><span class="hljs-type">eger</span>) <span class="hljs-number">2</span><br><span class="hljs-comment"># 删除myzset有序集合内(ff，nn]区间内的所有元素</span><br><span class="hljs-number">127.0</span><span class="hljs-type">.0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-type">zremrangebylex</span> <span class="hljs-type">myzset</span> (<span class="hljs-type">aa</span> [<span class="hljs-type">nn</span><br>(<span class="hljs-built_in">int</span><span class="hljs-type">eger</span>) <span class="hljs-number">2</span><br><span class="hljs-number">127.0</span><span class="hljs-type">.0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-type">zrange</span> <span class="hljs-type">myzset</span> -<span class="hljs-type">inf</span> <span class="hljs-type">inf</span> <span class="hljs-type">byscore</span> <span class="hljs-type">withscores</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;aa&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;0&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;zz&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;0&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;KFC&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;50&quot;</span><br><span class="hljs-number">7</span>) <span class="hljs-string">&quot;linzy&quot;</span><br><span class="hljs-number">8</span>) <span class="hljs-string">&quot;100&quot;</span><br><span class="hljs-comment"># 删除myzset有序集合内[0，49]分数区间内的所有元素</span><br><span class="hljs-number">127.0</span><span class="hljs-type">.0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-type">zremrangebyscore</span> <span class="hljs-type">myzset</span> <span class="hljs-number">0</span> <span class="hljs-number">49</span><br>(<span class="hljs-built_in">int</span><span class="hljs-type">eger</span>) <span class="hljs-number">2</span><br><span class="hljs-number">127.0</span><span class="hljs-type">.0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-type">zrange</span> <span class="hljs-type">myzset</span> -<span class="hljs-type">inf</span> <span class="hljs-type">inf</span> <span class="hljs-type">byscore</span> <span class="hljs-type">withscores</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;KFC&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;50&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;linzy&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;100&quot;</span><br><span class="hljs-comment"># 查看myzset有序集合内KFC升序的排名</span><br><span class="hljs-number">127.0</span><span class="hljs-type">.0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-type">zrank</span> <span class="hljs-type">myzset</span> <span class="hljs-type">KFC</span><br>(<span class="hljs-built_in">int</span><span class="hljs-type">eger</span>) <span class="hljs-number">0</span><br><span class="hljs-comment"># 查看myzset有序集合内KFC降序的排名</span><br><span class="hljs-number">127.0</span><span class="hljs-type">.0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-type">zrevrank</span> <span class="hljs-type">myzset</span> <span class="hljs-type">KFC</span><br>(<span class="hljs-built_in">int</span><span class="hljs-type">eger</span>) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-type">.0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-type">zadd</span> <span class="hljs-type">myzset</span> <span class="hljs-number">10</span> <span class="hljs-type">aa</span> <span class="hljs-number">20</span> <span class="hljs-type">bb</span> <span class="hljs-number">30</span> <span class="hljs-type">nn</span> <span class="hljs-number">0</span> <span class="hljs-type">zz</span><br>(<span class="hljs-built_in">int</span><span class="hljs-type">eger</span>) <span class="hljs-number">4</span><br><span class="hljs-number">127.0</span><span class="hljs-type">.0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-type">zrevrank</span> <span class="hljs-type">myzset</span> <span class="hljs-type">aa</span><br>(<span class="hljs-built_in">int</span><span class="hljs-type">eger</span>) <span class="hljs-number">4</span><br><span class="hljs-number">127.0</span><span class="hljs-type">.0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-type">zrank</span> <span class="hljs-type">myzset</span> <span class="hljs-type">KFC</span><br>(<span class="hljs-built_in">int</span><span class="hljs-type">eger</span>) <span class="hljs-number">4</span><br><span class="hljs-number">127.0</span><span class="hljs-type">.0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-type">zrevrank</span> <span class="hljs-type">myzset</span> <span class="hljs-type">KFC</span><br>(<span class="hljs-built_in">int</span><span class="hljs-type">eger</span>) <span class="hljs-number">1</span><br><span class="hljs-comment"># 删除myzset有序集合升序排名内[3,5]名的元素</span><br><span class="hljs-number">127.0</span><span class="hljs-type">.0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-type">zremrangebyrank</span> <span class="hljs-type">myzset</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br>(<span class="hljs-built_in">int</span><span class="hljs-type">eger</span>) <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span><span class="hljs-type">.0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-type">zrange</span> <span class="hljs-type">myzset</span> -<span class="hljs-type">inf</span> <span class="hljs-type">inf</span> <span class="hljs-type">byscore</span> <span class="hljs-type">withscores</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;zz&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;0&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;aa&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;10&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;bb&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;20&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/Redis_five_BasicData_types/redis15.png"><br><img src="/img/Redis_five_BasicData_types/redis16.png"></p><h3 id="3）交集、并集以及差集"><a href="#3）交集、并集以及差集" class="headerlink" title="3）交集、并集以及差集"></a>3）交集、并集以及差集</h3><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">zinter key的数量 key1 [key2…]<br>[weights 权重1 [权重2…] [aggregate sum | min | max] [withscores]</td><td align="left">查看给定的有序集合的交集。<br>werights：依次给每个集合的分数设置权重，默认权重为1<br>aggregate：新分数的计算方法，默认是sum<br><strong>注：新分数&#x3D;aggregate(集合1中该元素的分数 * 权重1+集合2中该元素的分数 * 权重2…) (符号是aggregate决定的可以是sum加，min取两者最小，max取两者最大)</strong><br>withscores：带分数显示</td></tr><tr><td align="left">zinterstore newkey key的数量 key1 [key2…]<br>[weights 权重1 [权重2…] [aggregate sum | min | max]</td><td align="left">将给定的有序集合的交集存储到新的有序集合newkey。</td></tr><tr><td align="left">zunion key的数量 key1 [key2…]<br>[weights 权重1 [权重2…] [aggregate sum | min | max] [withscores]</td><td align="left">查看给定的有序集合的并集。</td></tr><tr><td align="left">zunionstore newkey key的数量 key1 [key2…]<br>[weights 权重1 [权重2…] [aggregate sum | min | max]</td><td align="left">将给定的有序集合的并集存储到新的有序集合newkey。</td></tr><tr><td align="left">zdiff key的数量 key1 [key2…] [withscores]</td><td align="left">查看给定的有序集合的差集。</td></tr><tr><td align="left">zdiff newkey key的数量 key1 [key2…]</td><td align="left">将给定的有序集合的差集存储到新的有序集合newkey。</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zadd zset1 <span class="hljs-number">1</span> a <span class="hljs-number">2</span> b <span class="hljs-number">3</span> c <span class="hljs-number">4</span> g<br>(integer) <span class="hljs-number">4</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zadd zset2 <span class="hljs-number">0</span> a <span class="hljs-number">1</span> b <span class="hljs-number">2</span> c <span class="hljs-number">5</span> f<br>(integer) <span class="hljs-number">4</span><br><span class="hljs-comment"># 获取zset1与zset2的交集，显示的新分数 = zset1的元素分数 * 2 + zset2的元素分数 * 3 </span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zinter <span class="hljs-number">2</span> zset1 zset2 weights <span class="hljs-number">2</span> <span class="hljs-number">3</span> withscores<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;2&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;b&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;7&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;c&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;12&quot;</span><br><span class="hljs-comment"># 获取zset1与zset2计算的新分数后的交集，显示的新分数 = min(zset1的元素分数 * 2, zset2的元素分数 * 3) </span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zinter <span class="hljs-number">2</span> zset1 zset2 weights <span class="hljs-number">2</span> <span class="hljs-number">3</span> aggregate min withscores<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;0&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;b&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;c&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;6&quot;</span><br><span class="hljs-comment"># 将zset1与zset2计算的新分数后的交集，存储到有序集合newzset1内</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zinterstore newzset1 <span class="hljs-number">2</span> zset1 zset2 weights <span class="hljs-number">1</span> <span class="hljs-number">4</span><br>(integer) <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zrange newzset1 <span class="hljs-literal">-inf</span> inf byscore withscores<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;b&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;6&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;c&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;11&quot;</span><br><span class="hljs-comment"># 获取zset1与zset2计算的新分数后的并集</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zunion <span class="hljs-number">2</span> zset1 zset2 weights <span class="hljs-number">2</span> <span class="hljs-number">3</span> withscores<br> <span class="hljs-number">1</span>) <span class="hljs-string">&quot;a&quot;</span><br> <span class="hljs-number">2</span>) <span class="hljs-string">&quot;2&quot;</span><br> <span class="hljs-number">3</span>) <span class="hljs-string">&quot;b&quot;</span><br> <span class="hljs-number">4</span>) <span class="hljs-string">&quot;7&quot;</span><br> <span class="hljs-number">5</span>) <span class="hljs-string">&quot;g&quot;</span><br> <span class="hljs-number">6</span>) <span class="hljs-string">&quot;8&quot;</span><br> <span class="hljs-number">7</span>) <span class="hljs-string">&quot;c&quot;</span><br> <span class="hljs-number">8</span>) <span class="hljs-string">&quot;12&quot;</span><br> <span class="hljs-number">9</span>) <span class="hljs-string">&quot;f&quot;</span><br><span class="hljs-number">10</span>) <span class="hljs-string">&quot;15&quot;</span><br><span class="hljs-comment"># 将zset1与zset2计算的新分数后的并集，存储到有序集合newzset2内</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zunionstore newzset2 <span class="hljs-number">2</span> zset1 zset2 weights <span class="hljs-number">3</span> <span class="hljs-number">2</span> aggregate max<br>(integer) <span class="hljs-number">5</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zrange newzset2 <span class="hljs-literal">-inf</span> inf byscore withscores<br> <span class="hljs-number">1</span>) <span class="hljs-string">&quot;a&quot;</span><br> <span class="hljs-number">2</span>) <span class="hljs-string">&quot;3&quot;</span><br> <span class="hljs-number">3</span>) <span class="hljs-string">&quot;b&quot;</span><br> <span class="hljs-number">4</span>) <span class="hljs-string">&quot;6&quot;</span><br> <span class="hljs-number">5</span>) <span class="hljs-string">&quot;c&quot;</span><br> <span class="hljs-number">6</span>) <span class="hljs-string">&quot;9&quot;</span><br> <span class="hljs-number">7</span>) <span class="hljs-string">&quot;f&quot;</span><br> <span class="hljs-number">8</span>) <span class="hljs-string">&quot;10&quot;</span><br> <span class="hljs-number">9</span>) <span class="hljs-string">&quot;g&quot;</span><br><span class="hljs-number">10</span>) <span class="hljs-string">&quot;12&quot;</span><br><span class="hljs-comment"># 获取zset1与zset2的差集</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zdiff <span class="hljs-number">2</span> zset1 zset2 withscores<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;g&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;4&quot;</span><br><span class="hljs-comment"># 获取zset1与zset2的差集，存储到有序集合newzset3内</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zdiffstore newzset3 <span class="hljs-number">2</span> zset1 zset2<br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; zrange newzset3 <span class="hljs-literal">-inf</span> inf byscore withscores<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;g&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;4&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/Redis_five_BasicData_types/redis17.png"><br><img src="/img/Redis_five_BasicData_types/redis18.png"></p><h2 id="3、小结-4"><a href="#3、小结-4" class="headerlink" title="3、小结"></a>3、小结</h2><p>使用有序集合你可以很好地完成很多在其他数据库中难以实现的任务。<br>有序集合可以：</p><ul><li>在一个大型在线游戏中建立一个排行榜，每当有新的记录产生时，使用<code>ZADD</code>来更新它。你可以用<code>ZRANGE</code>轻松地获取排名靠前的用户， 你也可以提供一个用户名，然后用<code>ZRANK</code>获取他在排行榜中的名次。 同时使用<code>ZRANK</code>和<code>ZRANGE</code>你可以获得与指定用户有相同分数的用户名单。 所有这些操作都非常迅速。</li><li>有序集合通常用来索引存储在Redis中的数据。 例如：如果你有很多的hash来表示用户，那么你可以使用一个有序集合，这个集合的年龄字段用来当作评分，用户ID当作值。用·ZRANGEBYSCORE·可以简单快速地检索到给定年龄段的所有用户。</li></ul><blockquote><p>注意：<br>大多数有序集合操作是 O(log(n))，其中n是成员数。<br><code>ZRANGE</code>在运行具有较大返回值（例如，数万条或更多）的命令时要小心。该命令的时间复杂度为 O(log(n) + m)，其中m是返回的结果数。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>数据库</tag>
      
      <tag>Redis</tag>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis（二）入门：概述与安装</title>
    <link href="/2022/09/19/redis-begin/"/>
    <url>/2022/09/19/redis-begin/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Redis概述"><a href="#一、Redis概述" class="headerlink" title="一、Redis概述"></a>一、Redis概述</h1><h2 id="1、什么是Redis？"><a href="#1、什么是Redis？" class="headerlink" title="1、什么是Redis？"></a>1、什么是Redis？</h2><p>Redis(Remote Dictionary Server)，即远程字典服务。是一个开源的使用ANSI C语言编写、支持网络、可<code>基于内存</code>亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p><img src="/img/Redis_begin/redis1.png"></p><p><code>Redis通常将全部数据存储在内存中</code>，会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，但只是用于重启后将数据加载回内存，相当于一个数据备份作用。</p><blockquote><p><strong>为什么Redis会将数据存储在内存中？</strong></p><p>因为内存的读写速度比硬盘快一个数量级！这样数据库的性能就会大大提高。也是这个优点，Redis是当下最热门的 <code>NoSQL</code> 技术之一！也被人们称之为结构化数据库！</p></blockquote><h2 id="2、NoSQL"><a href="#2、NoSQL" class="headerlink" title="2、NoSQL"></a>2、NoSQL</h2><h3 id="1）什么是NoSQL？"><a href="#1）什么是NoSQL？" class="headerlink" title="1）什么是NoSQL？"></a>1）什么是NoSQL？</h3><p>NoSQL 数据库（意即”不仅仅是SQL”）并非表格格式，其存储数据的方式与关系表不同。NoSQL 数据库的类型因数据模型而异。主要类型包括文档、键值、列式和图形。它们提供了灵活的模式，可以随大量数据和高用户负载而轻松扩展。</p><p>参考文章：<a href="https://linzyblog.netlify.app/2022/09/19/redis-nosql-sql/">《NoSQL OR SQL，看完这篇你就懂了》</a></p><h2 id="3、Redis的定义"><a href="#3、Redis的定义" class="headerlink" title="3、Redis的定义"></a>3、Redis的定义</h2><ol><li>Redis是一个<code>key-value存储系统</code>：支持存储的value类型多，包括<code>string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）</code>。这些数据类型都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且这些操作都是<code>原子性</code>的。</li><li>Redis 是一个高性能的key-value数据库：在部分场合可以对关系数据库起到很好的补充作用。它提供了Java，C&#x2F;C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。</li></ol><p><img src="/img/Redis_begin/redis2.png"><br>3. Redis支持<code>主从同步</code>：数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了<code>发布/订阅机制</code>，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。<code>同步对读取操作的可扩展性和数据冗余很有帮助</code>。</p><p><img src="/img/Redis_begin/redis3.png"></p><h2 id="4、Redis发展简史"><a href="#4、Redis发展简史" class="headerlink" title="4、Redis发展简史"></a>4、Redis发展简史</h2><p><img src="/img/Redis_begin/redis4.png"><br>Redis的作者Salvatore Sanfilippo，意大利程序员，他最早使用传统数据库做了一个实时的Web日志分析器，因为对其性能不够满意，开发了Redis。</p><p>2020年6月，Salvatore Sanfilippo辞去了Redis维护者的职位。</p><h1 id="二、Redis安装"><a href="#二、Redis安装" class="headerlink" title="二、Redis安装"></a>二、Redis安装</h1><p>官方安装文档：<a href="https://redis.io/docs/getting-started/installation/">点击跳转</a></p><h2 id="1、windows下安装Redis"><a href="#1、windows下安装Redis" class="headerlink" title="1、windows下安装Redis"></a>1、windows下安装Redis</h2><p>这边选择windows下载只是方便学习测试，后续可能会转到Linux上。<br>下载地址: <a href="https://github.com/microsoftarchive/redis/releases">点击跳转.</a><br><img src="/img/Redis_begin/redis5.png"></p><blockquote><p>我的建议是直接下载.msi的安装包，电脑会自动给我们配置好环境变量，这样就不用自己启动redis的服务端<code>redis-server</code>了，直接用redis-cli启动redis客户端了。<br>如果下的是zip压缩包也没事，自己手动配置环境变量就行或者先启动<code>redis-server</code>再启动<code>redis-cli</code>即可。</p></blockquote><p>注意：Redis官方文档不建议我们在Widows环境下搭建Redis服务。因为只有 Redis 3，且上次更新是2016。<strong>不推荐</strong>！</p><h2 id="2、测试操作"><a href="#2、测试操作" class="headerlink" title="2、测试操作"></a>2、测试操作</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">PS</span> C:\Users\sly&gt; redis<span class="hljs-literal">-cli</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; ping <span class="hljs-comment">#查看当前连接是否正常，正常连接返回PONG</span><br>PONG<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-built_in">set</span> name linzy<br>OK<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; keys *<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;name&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/Redis_begin/redis6.png"></p><h1 id="三、基本操作"><a href="#三、基本操作" class="headerlink" title="三、基本操作"></a>三、基本操作</h1><h2 id="1、数据库操作"><a href="#1、数据库操作" class="headerlink" title="1、数据库操作"></a>1、数据库操作</h2><h3 id="1）数据库基本操作"><a href="#1）数据库基本操作" class="headerlink" title="1）数据库基本操作"></a>1）数据库基本操作</h3><p>Redis默认有16个数据库，编号为0~15，默认访问为0号数据库。</p><table><thead><tr><th>命令</th><th align="left">描述</th></tr></thead><tbody><tr><td>select 数据库编号</td><td align="left">选择访问指定数据库</td></tr><tr><td>dbsize</td><td align="left">返回当前数据库的键值对数量</td></tr><tr><td>flushdb</td><td align="left">清空当前数据库</td></tr><tr><td>flushall</td><td align="left">清空所有数据库</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-built_in">select</span> <span class="hljs-number">6</span><br>OK<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; dbsize<br>(integer) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; <span class="hljs-built_in">set</span> name linzy<br>OK<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; dbsize<br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; flushdb<br>OK<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; dbsize<br>(integer) <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><img src="/img/Redis_begin/redis7.png"></p><h3 id="2）数据库保存操作"><a href="#2）数据库保存操作" class="headerlink" title="2）数据库保存操作"></a>2）数据库保存操作</h3><table><thead><tr><th>命令</th><th align="left">描述</th></tr></thead><tbody><tr><td>save</td><td align="left">将数据保存到磁盘</td></tr><tr><td>bgsave</td><td align="left">将后台数据异步保存到磁盘(默认每两秒保存一次)</td></tr><tr><td>lastsave</td><td align="left">查看最近一次成功保存的 Unix 秒(1970年1月1日00:00:00到现在经过的总秒数)</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; save<br>OK<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; lastsave<br>(integer) <span class="hljs-number">1663070951</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; bgsave<br>Background saving started<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; lastsave<br>(integer) <span class="hljs-number">1663070960</span><br></code></pre></td></tr></table></figure><p><img src="/img/Redis_begin/redis8.png"></p><h2 id="2、-通用数据操作"><a href="#2、-通用数据操作" class="headerlink" title="2、 通用数据操作"></a>2、 通用数据操作</h2><h3 id="1）对当前数据库进行基本操作"><a href="#1）对当前数据库进行基本操作" class="headerlink" title="1）对当前数据库进行基本操作"></a>1）对当前数据库进行基本操作</h3><table><thead><tr><th>命令</th><th align="left">描述</th></tr></thead><tbody><tr><td>set key value</td><td align="left">在当前数据库保存一个键值对，如果key存在则直接将原来的value值覆盖</td></tr><tr><td>mset key1 value1 [key2 value2…]</td><td align="left">在当前数据库保存多个键值对，与set一样，key存在也会覆盖原来的value</td></tr><tr><td>keys 格式</td><td align="left">查看符合指定格式的 key ，*为通配符</td></tr><tr><td>exists key1 [key2…]</td><td align="left">查看一个或多个指定的 key</td></tr><tr><td>type key</td><td align="left">按指定的 key 查看 value 的数据类型</td></tr><tr><td>del key1 [key2…]</td><td align="left">删除一个或多个指定的键值对</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; <span class="hljs-built_in">set</span> name linzy<br>OK<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; mset k1 v1 k2 v2 k3 v3<br>OK<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; keys *<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;k3&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;name&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;k2&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;k1&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; keys k*<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;k3&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;k2&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;k1&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; keys k<br>(empty list or <span class="hljs-built_in">set</span>)<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; exists k1 k5<br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; <span class="hljs-built_in">type</span> k1<br>string<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; <span class="hljs-built_in">type</span> name<br>string<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; <span class="hljs-built_in">del</span> name k3<br>(integer) <span class="hljs-number">2</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; keys *<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;k2&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;k1&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/Redis_begin/redis9.png"></p><h3 id="2）对当前数据库重命名操作"><a href="#2）对当前数据库重命名操作" class="headerlink" title="2）对当前数据库重命名操作"></a>2）对当前数据库重命名操作</h3><table><thead><tr><th>命令</th><th align="left">描述</th></tr></thead><tbody><tr><td>rename key1 key2</td><td align="left">key1 重命名为 key2 ，如果 key2 已经存在，其对应的值会被覆盖为 key1 的值</td></tr><tr><td>renamenx key1 key2</td><td align="left">key1 只有在 key2 不存在时才会重命名为 key2</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; rename k1 k2<br>OK<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; keys *<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;k2&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; get k2 <span class="hljs-comment">#获取key对应的值，如果key不存则返回nil，get只处理字符串类型数据</span><br><span class="hljs-string">&quot;v1&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; <span class="hljs-built_in">set</span> k1 v1<br>OK<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; renamenx k1 k2<br>(integer) <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><img src="/img/Redis_begin/redis10.png"></p><h3 id="3）对当前数据库移动操作"><a href="#3）对当前数据库移动操作" class="headerlink" title="3）对当前数据库移动操作"></a>3）对当前数据库移动操作</h3><table><thead><tr><th>命令</th><th align="left">描述</th></tr></thead><tbody><tr><td>move key 数据库编号</td><td align="left">将指定的键值对移动到指定的数据库</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; <span class="hljs-built_in">move</span> k1 <span class="hljs-number">0</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; keys *<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;k2&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>[<span class="hljs-number">6</span>]&gt; <span class="hljs-built_in">select</span> <span class="hljs-number">0</span><br>OK<br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; keys *<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;k1&quot;</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-built_in">set</span> k2 v2<br>OK<br></code></pre></td></tr></table></figure><p><img src="/img/Redis_begin/redis11.png"></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>数据库</tag>
      
      <tag>Redis</tag>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis（一）入门：NoSQL OR SQL，看完这篇你就懂了</title>
    <link href="/2022/09/19/redis-NoSQL-SQL/"/>
    <url>/2022/09/19/redis-NoSQL-SQL/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>关系型数据库（MySql、Oracle）无法满足我们对存储的所有要求，因此对底层存储的选型，对每种存储引擎的理解非常重要。<br>MySQL不香吗，为什么还要有NoSQL？请听我慢慢细说！</p></blockquote><h1 id="一、结构化数据、非结构化数据与半结构化数据"><a href="#一、结构化数据、非结构化数据与半结构化数据" class="headerlink" title="一、结构化数据、非结构化数据与半结构化数据"></a>一、结构化数据、非结构化数据与半结构化数据</h1><p>文章的开始，了解一下结构化数据、非结构化数据与半结构化数据，因为数据特点的不同，将在技术上直接影响存储引擎的选型。</p><p><img src="/img/Redis_NoSQL_SQL/redis1.png"></p><h2 id="1、结构化数据"><a href="#1、结构化数据" class="headerlink" title="1、结构化数据"></a>1、结构化数据</h2><p>结构化数据，根据定义是指<code>由二维表结构来逻辑表达和实现的数据，严格遵循数据格式与长度规范，也称为行数据。</code></p><p>特点：数据以行为单位，二维表结构下一行数据就表示一个实体的信息，每一列数据的属性都是相同的。</p><p><img src="/img/Redis_NoSQL_SQL/redis2.png"></p><blockquote><p>因此关系型数据库刚好契合了结构化数据的特点，关系型数据库也是关系型数据最主要的存储与管理引擎。</p></blockquote><h2 id="2、非结构化数据"><a href="#2、非结构化数据" class="headerlink" title="2、非结构化数据"></a>2、非结构化数据</h2><p>非结构数据，根据定义是指<code>数据结构不规则或不完整，没有任何预定义的数据模型，不方便用二维逻辑表来表现数据</code>，例如网页日志、文本文档、图像、视频和音频文件等。</p><p>特点：没有固定组织原则的未经过滤的信息，通常被称为<code>原始数据</code>。通过对非结构化数据进行搜索和分析，可以提取有用的信息。</p><p><img src="/img/Redis_NoSQL_SQL/redis3.png"></p><h2 id="3、半结构化数据"><a href="#3、半结构化数据" class="headerlink" title="3、半结构化数据"></a>3、半结构化数据</h2><p>半结构化数据，根据定义是指<code>以非传统方式捕获或格式化的数据</code>。常见的半结构化数据有XML和JSON。</p><p>特点：半结构化数据不遵循表格数据模型或关系型数据库的格式，因为它没有固定的架构。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">person</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>linzy<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>18<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">phone</span>&gt;</span>12345<span class="hljs-tag">&lt;/<span class="hljs-name">phone</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">person</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>这种结构也被成为自描述的结构。<br>半结构化数据的优点是，与结构化数据相比，它更灵活，更易于扩展。</p></blockquote><h1 id="二、关系型数据库-SQL"><a href="#二、关系型数据库-SQL" class="headerlink" title="二、关系型数据库 SQL"></a>二、关系型数据库 SQL</h1><h2 id="1、什么是关系型数据库？"><a href="#1、什么是关系型数据库？" class="headerlink" title="1、什么是关系型数据库？"></a>1、什么是关系型数据库？</h2><p>关系型数据库，是指采用了<code>关系模型</code>来组织数据的数据库，其以行和列的形式存储数据，以便于用户理解，关系型数据库这一系列的行和列被称为表，一组表组成了数据库。</p><h2 id="2、什么是关系模型？"><a href="#2、什么是关系模型？" class="headerlink" title="2、什么是关系模型？"></a>2、什么是关系模型？</h2><p>关系模型是<code>采用二维表格结构表达实体类型及实体间联系的数据模型</code>。关系模型允许设计者通过数据库规范化的提炼，去建立一个信息的一致性的模型。</p><h2 id="3、以关系型数据库的方式做存储的架构演进"><a href="#3、以关系型数据库的方式做存储的架构演进" class="headerlink" title="3、以关系型数据库的方式做存储的架构演进"></a>3、以关系型数据库的方式做存储的架构演进</h2><p><img src="/img/Redis_NoSQL_SQL/redis4.png"></p><ul><li><p><strong>阶段一</strong>：企业刚发展的阶段，最简单，一个应用服务器配一个关系型数据库，每次直接访问数据库进行读写操作。</p></li><li><p><strong>阶段二</strong>：无论是使用MySQL还是Oracle还是别的关系型数据库，数据库通常不会先成为性能瓶颈，通常随着企业规模的扩大，一台应用服务器扛不住上游过来的流量且一台应用服务器会产生单点故障的问题，因此<code>加应用服务器并且在流量入口使用Nginx做一层负载均衡</code>，保证把流量均匀打到应用服务器上。</p></li><li><p><strong>阶段三</strong>：随着企业规模的继续扩大，此时由于读写都在同一个数据库上，数据库性能出现一定的瓶颈，此时简单地做一层<code>读写分离</code>，每次写主库，读备库，主备库之间通过binlog同步数据，就能很大程度上解决这个阶段的数据库性能问题。</p></li><li><p><strong>阶段四</strong>：企业发展越来越好了，业务越来越大了，做了读写分离数据库压力还是越来越大，这时候怎么办呢，一台数据库扛不住，那我们就分几台吧，<code>做分库分表，对表做垂直拆分，对库做水平拆分</code>。以扩数据库为例，扩出两台数据库，以一定的单号（例如交易单号），以一定的规则（例如取模），交易单号对2取模为0的丢到数据库1去，交易单号对2取模为1的丢到数据库2去，通过这样的方式将写数据库的流量均分到两台数据库上。<code>一般分库分表会使用Shard的方式，通过一个中间件，便于连接管理、数据监控且客户端无需感知数据库ip</code>。</p></li></ul><h2 id="4、关系型数据库的优点"><a href="#4、关系型数据库的优点" class="headerlink" title="4、关系型数据库的优点"></a>4、关系型数据库的优点</h2><ul><li><p><strong>易理解</strong><br>采用二维表结构非常贴近正常开发逻辑（关系型数据模型相对层次型数据模型和网状型数据模型等其他模型来说更容易理解）。</p></li><li><p><strong>操作方便</strong><br>支持通用的SQL（结构化查询语言）语句，通用的SQL语言使得操作关系型数据库非常方便，支持join等复杂查询，SQL + 二维关系是关系型数据库最无可比拟的优点，这种易用性非常贴近开发者。</p></li><li><p><strong>数据一致性</strong><br>支持<code>ACID特性</code>，事务开始前和结束后，数据库的完整性约束没有被破坏 。比如 A 向 B 转账，不可能 A 扣了钱，B 却没收到。在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。 这里的<code>一致性是指系统从一个正确的状态, 迁移到另一个正确的状态， 这是个逻辑层面的正确性。</code></p></li><li><p><strong>对事务的支持</strong><br>能保证系统中事务的正确执行，同时提供事务的恢复、回滚、并发控制和死锁问题的解决。</p></li><li><p><strong>数据稳定</strong><br>数据持久化到磁盘，没有丢失数据风险，支持海量数据存储，安全可靠。</p></li><li><p><strong>服务稳定</strong><br>最常用的关系型数据库产品MySql、Oracle服务器性能卓越，服务稳定，通常很少出现宕机异常。</p></li></ul><h2 id="5、关系型数据库的不足"><a href="#5、关系型数据库的不足" class="headerlink" title="5、关系型数据库的不足"></a>5、关系型数据库的不足</h2><blockquote><p>随着互联网技术的不断发展，数据也日益增多，关系型数据库面对海量的数据时有些不足也体现出来</p></blockquote><ul><li><p><strong>高并发下IO压力大</strong><br>数据按行存储，即使只针对其中某一列进行运算，也会将整行数据从存储设备中读入内存，导致IO较高。对于网站的并发量高，往往达到每秒上万次的请求，对于传统关系型数据库来说，硬盘 I&#x2F;O 有限，不能满足很多人同时连接。</p></li><li><p><strong>为维护索引付出的代价大</strong><br>为了提供丰富的查询能力，通常热点表都会有多个<code>二级索引</code>，一旦有了二级索引，数据的新增必然伴随着所有二级索引的新增，数据的更新也必然伴随着所有二级索引的更新，<code>这不可避免地降低了关系型数据库的读写能力，且索引越多读写能力越差。</code></p></li><li><p><strong>为维护数据一致性付出的代价大</strong><br>数据一致性是关系型数据库的核心，但是同样为了维护数据一致性的代价也是非常大的。我们都知道SQL标准为事务定义了不同的隔离级别，从低到高依次是读未提交、读已提交、可重复度、串行化，事务隔离级别越低，可能出现的并发异常越多，但是通常而言能提供的并发能力越强。那么<code>为了保证事务一致性，数据库就需要提供并发控制与故障恢复两种技术，前者用于减少并发异常，后者可以在系统异常的时候保证事务与数据库状态不会被破坏。</code>对于并发控制，其核心思想就是加锁，无论是乐观锁还是悲观锁，只要提供的隔离级别越高，那么读写性能必然越差。</p></li><li><p><strong>可扩展性不足</strong><br>在基于web的结构中，数据库是最难以水平拓展的，当一个应用系统的用户量和访问量与日俱增的时候，<code>数据库没有办法像web Server那样简单的通过添加更多的硬件和服务节点来拓展性能和负载能力</code>。</p></li><li><p><strong>水平扩展后带来的种种问题难处理</strong><br>随着企业规模扩大，一种方式是对数据库做分库，做了分库之后，数据迁移（1个库的数据按照一定规则打到2个库中）、跨库join（订单数据里有用户数据，两条数据不在同一个库中）、分布式事务处理都是需要考虑的问题，尤其是分布式事务处理，业界当前都没有特别好的解决方案。</p></li><li><p><strong>表结构扩展不方便</strong><br>由于数据库存储的是结构化数据，因此表结构schema是固定的，扩展不方便，如果需要修改表结构，需要<code>执行DDL（data definition language）语句修改，修改期间会导致锁表，部分服务不可用。</code></p></li><li><p><strong>全文搜索功能弱</strong><br>例如like “%中国真伟大%”，只能搜索到”2022年中国真伟大，爱祖国”，无法搜索到”中国真是太伟大了”这样的文本，即<code>不具备分词能力</code>，且like查询在”%中国真伟大”这样的搜索条件下，无法命中索引，将会导致查询效率大大降低</p></li></ul><blockquote><p>核心问题：<code>关系型数据库在高并发下的性能时有瓶颈的，尤其在O/I读写频繁的情况下</code>，出现的结果就是数据库占用CPU高，SQL执行效率变慢，客户端数据库连接池不够等错误。例如淘宝双十一的情况下，是绝对不可能直接对数据库进行O&#x2F;I读写操作进行减去库存的。</p></blockquote><blockquote><p>可能有朋友说，数据库在高并发下的能力有瓶颈，我公司有钱，加CPU、换固态硬盘、继续买服务器加数据库做分库不就好了，问题是这是一种性价比非常低的方式，花1000万达到的效果，换其他方式可能100万就达到了，不考虑人员、服务器投入产出比的Leader就是个不合格的Leader，且关系型数据库的方式，受限于它本身的特点，可能花了钱都未必能达到想要的效果。至于什么是花100万就能达到花1000万效果的方式呢？可以继续往下看，这就是我们要说的<code>NoSQL</code>。</p></blockquote><h1 id="三、非关系型数据库-NoSQL"><a href="#三、非关系型数据库-NoSQL" class="headerlink" title="三、非关系型数据库 NoSQL"></a>三、非关系型数据库 NoSQL</h1><blockquote><p>像上文分析的，数据库作为一种关系型数据的存储引擎，存储的是关系型数据，它有优点，同时也有明显的缺点，因此通常在企业规模不断扩大的情况下，不会一味指望通过增强数据库的能力来解决数据存储问题，而是会引入其他存储，也就是我们说的<code>NoSQL</code>。</p></blockquote><h2 id="1、什么是非关系型数据库？"><a href="#1、什么是非关系型数据库？" class="headerlink" title="1、什么是非关系型数据库？"></a>1、什么是非关系型数据库？</h2><p>NoSQL 数据库（意即”不仅仅是SQL”）并非表格格式，其存储数据的方式与关系表不同。NoSQL 数据库的类型因数据模型而异。主要类型包括文档、键值(KV)、列式和图形。它们提供了灵活的模式，可以随大量数据和高用户负载而轻松扩展。</p><p>非关系型数据库，是对关系型数据库的一种<code>补充</code>，特别注意补充这两个字，这意味着NoSql与关系型数据库并不是对立关系，二者各有优劣，取长补短，在合适的场景下选择合适的存储引擎才是正确的做法。</p><h2 id="2、常见的NoSQL数据库"><a href="#2、常见的NoSQL数据库" class="headerlink" title="2、常见的NoSQL数据库"></a>2、常见的NoSQL数据库</h2><ol><li>键值数据库：Redis、Memcached、Riak</li><li>图形数据库：Neo4j、InfoGrid</li><li>列式数据库：Bigtable、HBase、Cassandra</li><li>文档数据库：MongoDB、CouchDB、MarkLogic</li></ol><p><img src="/img/Redis_NoSQL_SQL/redis5.png"></p><h2 id="3、结合NoSql的方式做存储的架构演进"><a href="#3、结合NoSql的方式做存储的架构演进" class="headerlink" title="3、结合NoSql的方式做存储的架构演进"></a>3、结合NoSql的方式做存储的架构演进</h2><p><img src="/img/Redis_NoSQL_SQL/redis6.png"><br>对于那些读远多于写的数据，引入一层缓存，每次读从缓存中读取，缓存中读取不到，再去数据库中取，取完之后再写入到缓存，对数据做好失效机制通常就没有大问题了。通常来说，缓存是性能优化的第一选择也是见效最明显的方案。</p><p>但是，<code>缓存通常都是键值型存储且容量有限（基于内存）</code>，无法解决所有问题，于是再进一步的优化，我们继续引入其他NoSql：<br><img src="/img/Redis_NoSQL_SQL/redis7.png"><br>数据库、缓存与其他NoSQL并行工作，充分发挥每种NoSQL的特点。当然NoSQL在性能方面大大优于关系型数据库的同时，往往也伴随着一些特性的缺失，比较常见的就是<code>事务功能的缺失</code>。</p><h2 id="4、NoSQL-数据库四种类型"><a href="#4、NoSQL-数据库四种类型" class="headerlink" title="4、NoSQL 数据库四种类型"></a>4、NoSQL 数据库四种类型</h2><h3 id="1）键值-KV-NoSql（代表—-Redis）"><a href="#1）键值-KV-NoSql（代表—-Redis）" class="headerlink" title="1）键值(KV)NoSql（代表—-Redis）"></a>1）键值(KV)NoSql（代表—-Redis）</h3><p>键值数据库是一种较简单的数据库，其中每个项目都包含键和值。Redis又是键值数据库中应用最广泛的NoSQL，键值数据库以Redis为例，键值数据库的优点：</p><ul><li>数据基于内存，读写效率高。</li><li>键值型数据，时间复杂度为O(1)，查询速度快。</li></ul><p>键值数据库最大的优点就是<code>高性能</code>，利用Redis自带的BenchMark做基准测试，<code>TPS可达到10万的级别</code>，性能非常强劲，键值数据库非常适合需要存储大量数据但无需执行复杂查询来检索数据的使用案例。常见的使用案例包括<code>存储用户首选项或缓存</code>。</p><p>Ridis也同样有所有键值数据库都有的比较明显的缺点：</p><ul><li>只能根据键去查值，key → value，无法根据值去查键。</li><li>查询方式单一，只有key → value方式，<code>不支持条件查询</code>，多条查询的唯一做法就是数据冗余，但会极大浪费存储空间。</li><li>内存始终是有限的，无法支持海量数据的存储。</li><li>由于键值数据库的存储时基于内存的，所以存在数据丢失的风险。</li></ul><blockquote><p>键值数据库非常适合需要存储大量数据但无需执行复杂查询来检索数据，也就是作为缓存来使用：</p><ul><li>读操作多于写操作</li><li>读取能力强</li><li>没有持久化的需求，可以容忍数据丢失的风险，丢失了就再查询写入即可</li></ul></blockquote><p>&#x3D;&#x3D;键值数据库作为缓存的流程例子：&#x3D;&#x3D;<br>根据用户id查询用户信息，每次根据用户id去缓存中查询一把，查到数据直接返回，查不到去关系型数据库里面根据id查询一把数据写到缓存中去。</p><p><img src="/img/Redis_NoSQL_SQL/redis8.png"></p><h3 id="2）图形NoSql（代表—-Neo4j）"><a href="#2）图形NoSql（代表—-Neo4j）" class="headerlink" title="2）图形NoSql（代表—-Neo4j）"></a>2）图形NoSql（代表—-Neo4j）</h3><p>图形数据库是以点、边为基础存储单元，以高效存储、查询图数据为设计原理的数据管理系统。<code>图形数据库可以直观地可视化关系，是存储、查询、分析高度互联数据的最优办法。</code></p><p><img src="/img/Redis_NoSQL_SQL/redis9.png"></p><p>Neo4j是一个高性能的,NOSQL图形数据库，它将结构化数据存储在网络上而不是表中。图形数据库以Neo4j为例，图形数据库的优点：</p><ul><li><p><strong>更直观的模型</strong><br>图数据模型直接还原业务场景，相比传统数据模型更直观，提升产品与工程师的沟通效率。</p></li><li><p><strong>更简洁的查询语言</strong><br>图数据库支持查询语言在关联查询中更简洁，以最通用的<code>Cypher图</code>查询语言为例，复杂关联查询时代码量比SQL大幅降低，能够帮助程序员提升开发效率。</p></li><li><p><strong>更高效的关联查询性能</strong><br>图数据库在处理关联性强的数据以及天然的图问题场景时具有强大的·关联查询性能优势·。因为传统关系型数据库在进行关联查询时需要做表连接（JOIN），会把设计的表数据全部加载到内存中，涉及到大量的IO操作及内存消耗。而<code>图数据库对关联查询有针对性的优化，能防止局部数据的查询引发全部数据的读取，可以高效查询关联数据。</code></p></li></ul><p><strong>图形数据库不足之处：</strong></p><ul><li>可能需要对整个图做计算，不利于图数据分布存储</li></ul><p><strong>什么样的场景适合用图数据库</strong></p><ul><li>需要高性能深度关系查询与分析时，例如：金融反欺诈、社交网络分析、网络安全等。</li><li>业务动态，需要灵活数据模型时，例如：商品推荐、供应链管理、资产与权限管理等。</li><li>需要执行复杂关系分析与推理时，例如：智能问答、新药研发、设备故障检测等。</li></ul><p><strong>与关系数据库对比：</strong></p><p>在关系型数据库设计的时候需要进行严格的数据规范化，将数据分成不同的表并删除其中的重复数据，这种规范化保证了数据的强一致性并支持ACID事务。然而，这也对关系查询带来的限制。</p><p><code>快速的实现逐行访问是关系型数据库的设计原理之一</code>，当数据的数据之间形成复杂的关联时，跨表的关联查询增加，就会出现问题。虽然可以通过将存在不同表中的不同属性进行关联从而实行复杂查询，但是开销是非常大的。</p><p>与关系型数据库相比，图数据库把关系也映射到数据结构中，对于关联度高的数据集查询更快，尤其适合那些面向对象的应用程序。同时图数据库可以更自然的扩展到大数据应用场景，因为图数据库Schema更加灵活，所以更加适合管理临时或不断变化的数据。</p><p>关系型数据库对大量的数据元素进行相同的操作时通常更快，因为这是在其自然的数据结构中操作数据。图数据库在很多方面比关系型数据库更具有优势，而且变得越来越流行，但是<code>图形数据库和关系型数据库并非是简单的替代关系，在具体应用场景中图数据库可以带来性能的提升和降低延迟才是适合的应用场景。</code></p><h3 id="3）列式NoSql（代表—-HBase）"><a href="#3）列式NoSql（代表—-HBase）" class="headerlink" title="3）列式NoSql（代表—-HBase）"></a>3）列式NoSql（代表—-HBase）</h3><p>列式数据库针对快速检索数据列进行了优化，通常用于分析应用程序。适用于数据库表的列式存储是分析查询性能的一个重要组成部分，因为它<code>极大地降低了整体磁盘 I/O 要求，并减少了需要从磁盘载入的数据量。</code></p><p>列式NoSql是基于列式存储的，那么什么是列式存储呢，列式NoSql和关系型数据库一样都有主键的概念，区别在于关系型数据库是按照行组织的数据：</p><p><strong>关系型数据库：</strong></p><p><img src="/img/Redis_NoSQL_SQL/redis10.png"></p><blockquote><p>关系型数据库是基于行存储方式的，例子中每行有name、phone、address三个字段，即使存在Null值的数据，它也是占空间的。</p></blockquote><p><strong>列式数据库，它是按每一列进行组织的数据：</strong><br><img src="/img/Redis_NoSQL_SQL/redis11.png"><br><img src="/img/Redis_NoSQL_SQL/redis12.png"><br><strong>列式数据库这样的好处：</strong></p><ul><li>查询时只有指定的列会被读取，不会读取所有列(与关系数据库最主要的区别)。</li><li>存储上节约空间，Null值不会被存储，一列中有时候会有很多重复数据（尤其是枚举数据，性别、状态等），这类<code>数据可压缩</code>，行式数据库压缩率通常在3:1–5:1之间，列式数据库的压缩率一般在8:1–30:1左右。</li><li>列数据被组织到一起，一次磁盘IO可以将一列数据一次性读取到内存中。</li></ul><p><strong>关于数据压缩，我们对字典表压缩作为举例：</strong></p><p>要构建表级别字典，系统会扫描表以查找重复模式。<code>系统将检查所有行（而不仅仅是检查这些行的某些字段或者某些部分）以了解是否存在重复的条目或模式。</code></p><p>收集重复的条目之后，数据库管理器将构建一个<code>压缩字典</code>，并为这些条目指定简短的数字键。通常来讲，文本字符串的压缩机率高于数字数据；压缩数字数据涉及将一个数字替换为另一个数字。根据要替换的数字的大小，节省的存储空间可能不像压缩文本时节省的存储空间那么多。</p><p><img src="/img/Redis_NoSQL_SQL/redis13.png"></p><blockquote><p>关于列式数据库的优缺点总结：<br>优点：</p><ul><li>海量数据无限存储，PB级别数据随便存，底层基于HDFS（Hadoop文件系统），数据持久化</li><li>读写性能好，只要没有滥用造成数据热点，读写基本随便玩</li><li>横向扩展在关系型数据库及非关系型数据库中都是最方便的之一，只需要添加新机器就可以实现数据容量的线性增长，且可用在廉价服务器上，节省成本</li><li>本身没有单点故障，可用性高</li><li>可存储结构化或者半结构化的数据</li><li>列数理论上无限，HBase本身只对列族数量有要求，建议1~3个</li></ul><p>缺点：</p><ul><li>HBase是Hadoop生态的一部分，因此它本身是一款比较重的产品，依赖很多Hadoop组件，数据规模不大没必要用，运维还是有点复杂的</li><li>KV式，不支持条件查询，或者说条件查询非常非常弱吧，HBase在Scan扫描一批数据的情况下还是提供了前缀匹配这种API的，条件查询除非定义多个RowKey做数据冗余</li><li>不支持分页查询，因为统计不了数据总数</li></ul></blockquote><h3 id="4）文档型NoSql（代表—-MongoDB）"><a href="#4）文档型NoSql（代表—-MongoDB）" class="headerlink" title="4）文档型NoSql（代表—-MongoDB）"></a>4）文档型NoSql（代表—-MongoDB）</h3><p>文档数据库将<code>数据存储在类似于 JSON（JavaScript 对象表示法）对象的文档中</code>。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括<code>字符串、数字、布尔值、数组或对象等</code>，并且它们的结构通常与开发者在代码中使用的对象保持一致。</p><p><img src="/img/Redis_NoSQL_SQL/redis14.png"></p><p>由于字段值类型和强大的查询语言的多样性，因此文档数据库非常适合各种各样的使用案例，并且可以用作通用数据库。它们可以横向扩展以适应大量数据，<code>因此文档型NoSql的出现是解决关系型数据库表结构扩展不方便的问题的。</code></p><p>MongoDB是文档型NoSql的代表产品，同时也是所有NoSql产品中的明星产品之一，因此这里以MongoDB为例。</p><p><img src="/img/Redis_NoSQL_SQL/redis15.png"></p><blockquote><p>关系型数据库是按部就班地每个字段一列存，在MongDB里面就是一个JSON字符串存储。关系型数据可以为name、phone建立索引，MongoDB使用<code>createIndex</code>命令一样可以为列建立索引，建立索引之后可以大大提升查询效率。</p></blockquote><p>其他方面而言，就大的基本概念，二者之间基本也是类似的：</p><p><img src="/img/Redis_NoSQL_SQL/redis16.png"></p><blockquote><p>因此，对于MongDB，我们只要理解成一个Free-Schema的关系型数据库就完事了，它的优缺点比较一目了然。<br>优点：</p><ul><li>没有预定义的字段，扩展字段容易</li><li>相较于关系型数据库，读写性能优越，命中二级索引的查询不会比关系型数据库慢，对于非索引字段的查询则是全面胜出</li></ul><p>缺点：</p><ul><li>多表之间的关联查询不支持（虽然有嵌入文档的方式），join查询还是需要多次操作</li><li>空间占用较大，这个是MongDB的设计问题，空间预分配机制 + 删除数据后空间不释放，只有用db.repairDatabase()去修复才能释放</li></ul></blockquote><h1 id="四、总结：关系型数据库与NoSQL间的对比"><a href="#四、总结：关系型数据库与NoSQL间的对比" class="headerlink" title="四、总结：关系型数据库与NoSQL间的对比"></a>四、总结：关系型数据库与NoSQL间的对比</h1><h2 id="1、何时选用关系型数据库，何时选用非关系型数据库？"><a href="#1、何时选用关系型数据库，何时选用非关系型数据库？" class="headerlink" title="1、何时选用关系型数据库，何时选用非关系型数据库？"></a>1、何时选用关系型数据库，何时选用非关系型数据库？</h2><p>如何选择关系型数据库和非关系型数据库，需要考虑两个问题：</p><ol><li>数据间是否有一致性的需求？</li><li>是否核心数据且有多字段组合查询场景<br><img src="/img/Redis_NoSQL_SQL/redis17.png"></li></ol><blockquote><ol><li>非关系型数据库都是通过牺牲了<code>ACID特性</code>来获取更高的性能的，假设两张表之间有比较强的一致性需求，那么这类数据是不适合放在非关系型数据库中的。</li><li><code>核心数据不走非关系型数据库</code>，例如用户表、订单表，但是这有一个前提，就是这一类核心数据会有多种查询模式，例如用户表有ABCD四个字段，可能根据AB查，可能根据AC查，可能根据D查，假设核心数据，但是就是个KV形式，比如用户的聊天记录，那么HBase一存就完事了。</li><li>非核心数据尤其是<code>日志、流水一类中间数据</code>千万不要写在关系型数据库中，这一类数据通常有两个特点：<br> - 写远高于读<br> - 写入量巨大</li><li>一旦使用关系型数据库作为存储引擎，将大大降低关系型数据库的能力，正常读写QPS不高的核心服务会受这一类数据读写的拖累。</li></ol></blockquote><h2 id="2、选用非关系型数据库，使用哪种非关系型数据库？"><a href="#2、选用非关系型数据库，使用哪种非关系型数据库？" class="headerlink" title="2、选用非关系型数据库，使用哪种非关系型数据库？"></a>2、选用非关系型数据库，使用哪种非关系型数据库？</h2><table><thead><tr><th>NoSQL</th><th align="left">代表产品</th><th align="left">解决关系型数据库的什么问题</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td>键值(KV)NoSql</td><td align="left">Redis</td><td align="left">（1）需要存储大量数据但无需执行复杂查询来检索数据的使用<br> （2）热点KV型数据读写QPS高，读写性能受高QPS写数据的直接影响</td><td align="left">（1）数据基于内存，读写效率高。<br> （2）键值型数据，时间复杂度为O(1)，查询速度快。<br> （3）原子命令的特性可用于分布式锁</td><td align="left">（1）数据无法持久化。<br> （2）不支持条件查询。<br> （3）基础内存存储，存储空间有限</td></tr><tr><td>图形NoSql</td><td align="left">Neo4j</td><td align="left">（1）数据的数据之间形成复杂的关联时，跨表的关联查询增加，开销很大。<br>（2）管理临时或不断变化的数据。</td><td align="left">（1）利用图结构相关算法(最短路径、节点度关系查找等)。<br>（2）图数据库支持查询语言在关联查询中更简洁。<br>（3）图数据库在处理关联性强的数据以及天然的图问题场景时具有强大的关联查询性能优势。</td><td align="left">（1）可能需要对整个图做计算，不利于图数据分布存储。<br> （2）高度结构化的数据处理能力不及关系型数据库。</td></tr><tr><td>列式NoSql</td><td align="left">HBase</td><td align="left">（1）海量数据存储后读写性能低。</td><td align="left">（1）支持海量数据存储，特别适合数据增长不可预估的场景。<br>（2）KV方式读写性能高。<br>（3）横向扩展方便。<br>（4）可直接部署廉价服务器，成本低</td><td align="left">（1）基本没有条件查询能力。<br>（2）不支持分页查询。（3）运维复杂。<br>（4）需要开发者有一定的能力。</td></tr><tr><td>文档型NoSql</td><td align="left">MongoDB</td><td align="left">（1）表Schema扩展不方便</td><td align="left">（1）没有预定义的Schema，可随意变更字段。<br>（2）命中二级索引时性能高于关系型数据库，非索引字段查询远远胜出。</td><td align="left">（1）空间占用大。</td></tr></tbody></table><blockquote><p>参考文章：<br><a href="https://www.cnblogs.com/xrq730/p/11039384.html">《Sql Or NoSql，看完这一篇你就懂了》</a><br>NoSQL四种类型参考百度百科。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>数据库</tag>
      
      <tag>Redis</tag>
      
      <tag>NoSQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile概述与用法</title>
    <link href="/2022/09/06/docker-Dockerfile/"/>
    <url>/2022/09/06/docker-Dockerfile/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>学习本文需要一些了解Docker的概念以及一些名词。</p></blockquote><h1 id="一、Docker概述"><a href="#一、Docker概述" class="headerlink" title="一、Docker概述"></a>一、Docker概述</h1><h2 id="1、Docker简介"><a href="#1、Docker简介" class="headerlink" title="1、Docker简介"></a>1、Docker简介</h2><p><code>Docker 镜像是通过读取Dockerfile来构建镜像文件的</code>。Dockerfile是一个文本文档，它包含用户可以在命令行上调用的所有命令来组装镜像，<code>每条指令都是独立运行的，并会创建一个新的镜像层 </code>。使用docker build 命令用户用户可以创建一个自动构建，该构建可以连续执行几个命令行指令。</p><h2 id="2、为什么要用Dockerfile？"><a href="#2、为什么要用Dockerfile？" class="headerlink" title="2、为什么要用Dockerfile？"></a>2、为什么要用Dockerfile？</h2><p>为什么要用Dockerfile？这个问题的本身其实是说为什么我们要自定义镜像，明明Docker Hub上有这么多镜像可以用，我们还要自己费心思做镜像。</p><p><img src="/img/docker_Dockerfile/docker1.png"></p><p><img src="/img/docker_Dockerfile/docker2.png"></p><blockquote><p>主要原因：Docker Hub上许多官方镜像只是基础包，很多功能都没有，需要我们自己对官方镜像做扩展，以打包成我们生产应用的镜像。<br>参考我的第一篇文章Docker入门篇：《<a href="https://linzyblog.netlify.app/2022/08/15/docker-begin/">Docker的入门与安装</a>》</p></blockquote><h1 id="二、docker-build工作原理"><a href="#二、docker-build工作原理" class="headerlink" title="二、docker build工作原理"></a>二、docker build工作原理</h1><h2 id="1、镜像构建过程"><a href="#1、镜像构建过程" class="headerlink" title="1、镜像构建过程"></a>1、镜像构建过程</h2><p>docker build命令从 Dockerfile 和 context 构建一个镜像。构建的 context 是位于指定位置PATH或URL的一组文件。PATH是本地文件系统上的一个目录。URL是Git存储库位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build [OPTIONS] PATH | URL | -<br></code></pre></td></tr></table></figure><p>完整的镜像架构图：<br><img src="/img/docker_Dockerfile/docker3.png"><br><code>构建context是递归处理的。每条指令都是独立运行的，并会创建一个新的镜像层。 </code></p><p>例子中docker build后面使用(.)表示当前目录，作为指定context的路径:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build .</span><br><br>Send build context to Docker daemon 6.51MB<br>...<br></code></pre></td></tr></table></figure><p><code>构建由 Docker 守护程序运行，而不是由 CLI 运行</code>。构建过程所做的第一件事是将整个 context（递归）发送到守护进程。</p><h2 id="2、context-上下文"><a href="#2、context-上下文" class="headerlink" title="2、context(上下文)"></a>2、context(上下文)</h2><p><code>Docker使用客户端-服务器架构</code>。Docker客户端 与 Docker守护进程 通信，守护进程 负责构建、运行和分发Docker容器。Docker客户端 和 守护进程 可以运行在同一个系统上，或者将 Docker客户端 连接到远程的Docker守护进程。<code>Docker客户端 和 守护进程 通过UNIX套接字或网络接口使用REST API进行通信</code>。另一个 Docker客户端 是Docker Compose，它允许使用由一组容器组成的应用程序。</p><p> Docker客户端(Docker) 是许多Docker用户与Docker交互的主要方式。使用docker 命令时，则是通过docker API 与 Docker守护进程进行<strong>交互</strong>，从而完成各种功能，Docker客户端 可以与多个 守护进程 通信。因此，<code>虽然表面上我们是在本机执行各种 docker 功能，但实际上，客户端会将这些命令发送到 Docker守护进程 执行它们</code>。也因为这种 C&#x2F;S 设计，让我们操作远程服务器的 Docker守护进程 变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker守护进程构建的。</p><blockquote><p>那么在这种客户端&#x2F;服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了<code>context(上下文)</code>的概念。当构建的时候，用户会指定构建镜像<code>context(上下文)</code>的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker守护进程。这样Docker守护进程收到这个<code>context(上下文)</code>包后，展开就会获得构建镜像所需的一切文件。</p></blockquote><p><img src="/img/docker_Dockerfile/docker4.png"><br>如果要在构建上下文中使用文件，Dockerfile引用指令中指定的文件，例如COPY指令。<code>要提高构建的性能，可以通过在context目录中添加.dockerignore文件来排除文件和目录。</code></p><p>传统上，Dockerfile位于上下文的根目录中。实际上，Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，在docker build中使用-f标志来指向文件系统中的任何位置的Dockerfile。</p><p><code>一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</code></p><blockquote><p>注意：不要将根目录<code>/</code>用作PATH构建上下文，因为它会导致构建将硬盘驱动器的全部内容传输到 Docker 守护程序。</p></blockquote><h1 id="三、Dockerfile指令"><a href="#三、Dockerfile指令" class="headerlink" title="三、Dockerfile指令"></a>三、Dockerfile指令</h1><h2 id="1、约定"><a href="#1、约定" class="headerlink" title="1、约定"></a>1、约定</h2><ol><li><code>指令必须大写</code>，以便更容易地将它们与参数区分开来。</li><li><code>Dockerfile必须以FROM指令开始</code> 。</li><li>以# 开头视为注释。</li></ol><h2 id="2、FROM"><a href="#2、FROM" class="headerlink" title="2、FROM"></a>2、FROM</h2><ul><li>作用：指定基础镜像，Dockerfile必须以FROM指令开始。</li><li>格式：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>(1)FROM [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]<br>(2)FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]<br>(3)FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]<br><br>解释：<br>[--platform=&lt; platform &gt;]：如果引用多平台镜像，可选 --platform 标志可用于指定镜像的平台。<br>[AS &lt;name&gt;]：通过向FROM指令添加AS name，可以为新的构建阶段指定一个名称。<br><br>注：<br>   tag或digest是可选的，如果不使用这两个值时，会使用latest版本的基础镜像<br>   <br>示例：<br>FROM centos<br></code></pre></td></tr></table></figure><ul><li>说明：</li></ul><p><code>Docker Hub中的大部分镜像都是从基础镜像 FROM scratch构建的，在基础镜像之上构建软件和配置</code>。FROM指令初始化一个新的构建阶段，并为后续指令设置基本镜像。因此，一个有效的Dockerfile必须以一个FROM指令开始。</p><p>镜像可以是任何有效的镜像—从Docker Hub提取镜像尤其容易。</p><h2 id="3、RUN"><a href="#3、RUN" class="headerlink" title="3、RUN"></a>3、RUN</h2><ul><li>作用：构建镜像时需要执行的命令</li><li>格式：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>shell形式(命令运行在shell中，Linux默认为/bin/sh -c, Windows默认为cmd /S /C)<br>(1)RUN &lt;command&gt;<br><br>exec形式(exec形式可以避免shell字符串混杂，并使用不包含指定的shell可执行文件的基本镜像运行命令)<br>(2)RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]<br><br>注：<br>RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。<br><br>示例：<br>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]<br>    RUN apk update<br>    RUN [&quot;/etc/execfile&quot;, &quot;arg1&quot;, &quot;arg1&quot;]<br></code></pre></td></tr></table></figure><ul><li>说明：</li></ul><p>镜像构建的时候需要运行的命令，有两种命令执行方式。RUN指令将在当前镜像之上的新层中执行任何命令并提交结果。生成的提交镜像将用于Dockerfile。</p><blockquote><p>注意：在下一次构建期间，<code>RUN</code>指令的缓存不会自动失效。像<code>RUN apt-get distupgrade -y</code>这样的指令的缓存将在下一次构建期间被重用。RUN指令的缓存可以通过使用<code>--no-cache</code>标志来失效，例如<code>docker build——no-cache</code>。</p></blockquote><h2 id="4、CMD"><a href="#4、CMD" class="headerlink" title="4、CMD"></a>4、CMD</h2><ul><li>作用：在构建镜像之后调用，容器启动时调用命令</li><li>格式：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>(1)CMD [&quot;executable&quot;，&quot;param1&quot;，&quot;param2&quot;] (exec形式，这是首选形式)<br>(2)CMD [&quot;param1&quot;，&quot;param2&quot;](作为ENTRYPOINT的默认参数)<br>(3)CMD command param1 param2(shell形式)<br><br>注：<br>Dockerfile中只能有一个CMD指令。如果列出多个CMD，则只有最后一个CMD生效。<br><br>示例：<br>FROM ubuntu<br>CMD echo &quot;This is a test.&quot; | wc -<br><br>FROM ubuntu<br>CMD [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]<br></code></pre></td></tr></table></figure><ul><li>说明：</li></ul><p>CMD的主要目的是<code>为容器提供默认的执行命令。</code>包括可执行文件，也可以省略可执行文件，在这种情况下，您必须同时指定一个ENTRYPOINT指令。</p><blockquote><p>注意：<br><code>CMD</code>不同于<code>RUN</code>，<code>CMD</code>在构建时不执行任何操作，<code>CMD</code>是容器启动时执行的指令，<code>RUN</code>是镜像构建时执行的指令。</p></blockquote><h2 id="5、ENTRYPOINT"><a href="#5、ENTRYPOINT" class="headerlink" title="5、ENTRYPOINT"></a>5、ENTRYPOINT</h2><ul><li>作用：在构建镜像之后调用，容器启动时调用命令</li><li>格式：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>(1)ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;](exec形式，这是首选形式)<br>(2)ENTRYPOINT command param1 param2(shell形式)<br><br>注：<br>指定 ENTRYPOINT 指令为 exec 模式时，命令行上指定的参数会作为参数添加到 ENTRYPOINT 指定命令的参数列表中。<br><br>示例：<br>FROM ubuntu<br>ENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]<br>CMD [&quot;-c&quot;]<br></code></pre></td></tr></table></figure><ul><li>说明：</li></ul><p>ENTRYOINT与CMD作用一样，都是在容器运行时执行命令，两者都是重要的指令。</p><blockquote><p>注意：<br><code>ENTRYPOINT</code>与<code>CMD</code>非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给CMD。<br><code>Dockerfile中只允许有一个ENTRYPOINT命令</code>，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令。<br>通常情况下，ENTRYPOINT 与CMD一起使用，ENTRYPOINT 写默认命令，当需要参数时候 使用CMD传参。</p></blockquote><h2 id="6、CMD-vs-ENTRYPOINT"><a href="#6、CMD-vs-ENTRYPOINT" class="headerlink" title="6、CMD vs ENTRYPOINT"></a>6、CMD vs ENTRYPOINT</h2><p>《<a href="https://docs.docker.com/engine/reference/builder/#entrypoint">Docker官方文档</a>》<br>《<a href="https://blog.csdn.net/hhd1988/article/details/109223849?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166234481916782244857786%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166234481916782244857786&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-109223849-null-null.142%5Ev46%5Epc_rank_34_default_3&utm_term=ENTRYPOINT&spm=1018.2226.3001.4187">Dockerfile 的 CMD 与 ENTRYPOINT 傻傻分不清楚</a>》<br>《<a href="http://www.johnzaccone.io/entrypoint-vs-cmd-back-to-basics/">ENTRYPOINT vs CMD: Back to Basics</a>》</p><h2 id="7、LABEL"><a href="#7、LABEL" class="headerlink" title="7、LABEL"></a>7、LABEL</h2><ul><li>作用：LABEL指令向镜像添加元数据。</li><li>格式：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...<br><br>注：<br>一个镜像可以有多个标签，可以在一行中指定多个标签。<br><br>示例：<br>一条指令中指定多个标签：<br>(1)LABEL multi.label1=&quot;value1&quot; multi.label2=&quot;value2&quot; other=&quot;value3&quot;<br>(2)LABEL multi.label1=&quot;value1&quot; \<br>      multi.label2=&quot;value2&quot; \<br>      other=&quot;value3&quot;<br><br></code></pre></td></tr></table></figure><ul><li>说明：</li></ul><p>LABEL指令向镜像添加元数据。LABEL是一个<code>键-值对</code>。要在LABEL值中包含空格，请在命令行解析中那样使用引号和反斜杠。</p><blockquote><p>注意：<br>基础或父镜像（FROM行中的镜像）中包含的标签由你的镜像继承。如果标签已存在但具有不同的值，则<code>最近应用的值将覆盖任何先前设置的值</code>。</p></blockquote><h2 id="8、MAINTAINER-已弃用"><a href="#8、MAINTAINER-已弃用" class="headerlink" title="8、MAINTAINER (已弃用)"></a>8、MAINTAINER (已弃用)</h2><ul><li>作用：MAINTAINER指令设置生成的镜像的作者信息。</li><li>格式：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>MAINTAINER &lt;name&gt;<br><br>示例：<br>    MAINTAINER linzy<br>    MAINTAINER xxx@qq.com<br>    MAINTAINER linzy &lt;xxx@qq.com&gt;<br></code></pre></td></tr></table></figure><h2 id="9、EXPOSE"><a href="#9、EXPOSE" class="headerlink" title="9、EXPOSE"></a>9、EXPOSE</h2><ul><li>作用：EXPOSE指令告诉Docker容器在运行时<code>监听指定的网口</code>。</li><li>格式：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]<br><br>注：<br>EXPOSE指令实际上并不发布端口。它在构建镜像的人和运行容器的人之间充当一种文档，说明哪些端口将被发布。<br>要在运行容器时真正发布端口，需要在docker run运行容器时通过-p来发布这些端口，或通过-P参数来发布EXPOSE导出的所有端口。<br><br>示例：<br>EXPOSE 8080<br><br>同时在 TCP 和 UDP 上公开：<br>EXPOSE 80/tcp<br>EXPOSE 80/udp<br></code></pre></td></tr></table></figure><ul><li>说明：</li></ul><p>EXPOSE指令告诉Docker容器在运行时监听指定的网口。可以指定端口侦听的协议类型是TCP还是UDP，<code>如果不指定协议类型，默认为TCP</code>。</p><blockquote><p>注意：<br>如果没有发布端口，后期也可以通过-p 8080:80方式映射端口，但是不能通过-P形式映射</p></blockquote><h2 id="10、ENV"><a href="#10、ENV" class="headerlink" title="10、ENV"></a>10、ENV</h2><ul><li>作用：ENV指令将设置环境变量。</li><li>格式：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>ENV &lt;key&gt; &lt;value&gt;  <br><span class="hljs-meta prompt_">#</span><span class="language-bash">&lt;key&gt;之后的所有内容均会被视为其&lt;value&gt;的组成部分，因此，一次只能设置一个变量。</span><br>    ENV &lt;key&gt;=&lt;value&gt; ...  <br>    #可以设置多个变量，每个变量为一个&quot;&lt;key&gt;=&lt;value&gt;&quot;的键值对。<br><br>注：<br>如果&lt;key&gt;中包含空格，可以使用\来进行转义，也可以通过&quot;&quot;来进行标示；另外，反斜线也可以用于续行。<br>示例：<br>ENV MY_NAME=&quot;linzy&quot;<br>ENV MY_DOG=Wang\ Cai<br>ENV MY_CAT=Mei\ Lao\ Ban<br></code></pre></td></tr></table></figure><ul><li>说明：</li></ul><p><code>ENV</code>当容器从生成的图像运行时，使用ENV设置的环境变量将一直存在。你可以使用 <code>docker inspect</code>查看这些值，并使用 <code>docker run --env &lt; key &gt;=&lt; value &gt;</code> 更改它们。</p><blockquote><p>注意：<br><code>ENV</code>指令还允许使用另一种语法<code>ENV &lt; key &gt; &lt; value &gt;</code>，省略<code>=</code>，例如：<br>ENV MY_VAR my-value</p></blockquote><h2 id="11、ADD"><a href="#11、ADD" class="headerlink" title="11、ADD"></a>11、ADD</h2><ul><li>作用：将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget。</li><li>格式：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>(1)ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;<br>(2)ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]<br><br>注：<br>该--chown功能仅在用于构建 Linux 容器的 Dockerfile 上受支持，不适用于 Windows 容器。由于用户和组所有权概念不能在 Linux 和 Windows 之间转换，因此使用/etc/passwd并/etc/group用于将用户和组名转换为 ID 会限制此功能仅适用于基于 Linux 操作系统的容器。<br><br>示例：<br>ADD hom* /mydir/ # 添加所有以“hom”开头的文件<br>ADD hom?.txt /mydir/ # ?替换为任何单个字符，例如“home.txt”。<br>ADD test.txt relativeDir/ # 使用相对路径，将“test.txt”添加到&lt;WORKDIR&gt;/relativeDir/<br>ADD test.txt /absoluteDir/ # 使用绝对路径，将“test.txt”添加到/absoluteDir/<br></code></pre></td></tr></table></figure><ul><li>说明：</li></ul><p>该<code>ADD</code>指令从<code>&lt;src&gt;</code>路径复制新文件、目录或远程文件 URL，并将它们添加到镜像的文件系统中<code>&lt;dest&gt;</code>。<code>&lt;src&gt;</code>可以指定多个资源，但如果它们是文件或目录，则它们的路径被解释为相对于构建context(上下文)的源。</p><blockquote><p><strong>ADD遵守以下规则</strong>：</p><ol><li><code>&lt;src&gt;</code>路径必须在构建的上下文中；你不能<code>ADD ../something /something</code>，因为<code>docker build</code>的第一步是将上下文目录（和子目录）发送到 docker 守护进程。</li><li>如果<code>&lt;src&gt;</code>是一个URL，且<code>&lt;dest&gt;</code>不是以斜杠结尾，则从该URL下载文件并复制到<code>&lt;dest&gt;</code>。</li><li>如果<code>&lt;src&gt;</code>是一个URL，且<code>&lt;dest&gt;</code>是以斜杠结尾，则从 URL 推断文件名并将文件下载到 <code>&lt;dest&gt;/&lt;filename&gt;</code>.。例如：<code>ADD http://example.com/foobar /</code>将创建文件<code>/foobar</code>。 URL 必须有一个重要的路径，以便在这种情况下可以找到适当的文件名（<code>http://example.com</code> 将不起作用）。</li><li>如果<code>&lt;src&gt;</code>是目录，则复制目录的全部内容，包括文件系统元数据。</li><li>如果<code>&lt;src&gt;</code>是可识别压缩格式（identity、gzip、bzip2 或 xz）的本地tar 存档，则将其解压缩为目录。<code>来自远程URL 的资源不会被解压缩</code>。当一个目录被复制或解包时，它的行为与 相同<code>tar -x</code>。<br> - 文件是否被识别为可识别的压缩格式完全取决于文件的内容，而不是文件的名称。例如，如果一个空文件恰好以此结尾，<code>.tar.gz</code>则不会被识别为压缩文件，也不会生成任何类型的解压缩错误消息，而是将文件简单地复制到目标位置。</li><li>如果<code>&lt;src&gt;</code>是任何其他类型的文件，它将与它的元数据一起被单独复制。在这种情况下，如果<code>&lt;dest&gt;</code>以斜杠结尾&#x2F;，它将被视为一个目录，其内容<code>&lt;src&gt;</code>将写入<code>&lt;dest&gt;/base(&lt;src&gt;)</code>。</li><li><code>&lt;src&gt;</code>直接指定了多个资源，或者使用了通配符，则<code>&lt;dest&gt;</code>必须是目录，并且必须以斜杠结尾<code>/</code>。</li><li>如果<code>&lt;dest&gt;</code>不以斜杠结尾，它将被认为是一个普通文件，其<code>&lt;src&gt;</code>的内容将写入<code>&lt;dest&gt;</code>。</li><li>如果<code>&lt;dest&gt;</code>不存在，它会连同其路径中所有缺失的目录一起创建。</li></ol></blockquote><h2 id="12、COPY"><a href="#12、COPY" class="headerlink" title="12、COPY"></a>12、COPY</h2><ul><li>作用：将本地文件添加到容器中，但是是不会自动解压文件，也不能访问网络资源。</li><li>格式：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>(1)COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;<br>(2)COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]<br><br>注：<br>该--chown功能仅在用于构建 Linux 容器的 Dockerfile 上受支持，不适用于 Windows 容器。<br><br>示例：<br>COPY hom* /mydir/ # 添加所有以“hom”开头的文件<br>COPY hom?.txt /mydir/ # ?替换为任何单个字符，例如“home.txt”<br>COPY test.txt relativeDir/ # 使用相对路径，并将“test.txt”添加到&lt;WORKDIR&gt;/relativeDir/<br>COPY test.txt /absoluteDir/ # 使用绝对路径，并将“test.txt”添加到/absoluteDir/<br></code></pre></td></tr></table></figure><ul><li>说明：</li></ul><p>COPY指令从路径复制新文件或目录<code>&lt;src&gt;</code> 并将它们添加到容器的文件系统中<code>&lt;dest&gt;</code>。<code>&lt;src&gt;</code>可以指定多个资源，但文件和目录的路径将被解释为相对于构建上下文的源。</p><blockquote><p><strong>COPY遵守以下规则</strong>：</p><ol><li><code>&lt;src&gt;</code>路径必须在构建的上下文中；你不能<code>ADD ../something /something</code>，因为<code>docker build</code>的第一步是将上下文目录（和子目录）发送到 docker 守护进程。</li><li>如果<code>&lt;src&gt;</code>是目录，则复制目录的全部内容，包括文件系统元数据。</li><li>如果<code>&lt;src&gt;</code>是任何其他类型的文件，它将与它的元数据一起被单独复制。在这种情况下，如果<code>&lt;dest&gt;</code>以斜杠结尾&#x2F;，它将被视为一个目录，其内容<code>&lt;src&gt;</code>将写入<code>&lt;dest&gt;/base(&lt;src&gt;)</code>。</li><li><code>&lt;src&gt;</code>直接指定了多个资源，或者使用了通配符，则<code>&lt;dest&gt;</code>必须是目录，并且必须以斜杠结尾<code>/</code>。</li><li>如果<code>&lt;dest&gt;</code>不以斜杠结尾，它将被认为是一个普通文件，其<code>&lt;src&gt;</code>的内容将写入<code>&lt;dest&gt;</code>。</li><li>如果<code>&lt;dest&gt;</code>不存在，它会连同其路径中所有缺失的目录一起创建。</li></ol></blockquote><h2 id="13、VOLUME"><a href="#13、VOLUME" class="headerlink" title="13、VOLUME"></a>13、VOLUME</h2><ul><li>作用：用于指定持久化目录（指定此目录可以被挂载出去）</li><li>格式：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>VOLUME [&quot;/data&quot;]<br><br>注：<br>卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：<br>1.卷可以容器间共享和重用<br>2.容器并不一定要和其它容器共享卷<br>3.修改卷后会立即生效<br>4.对卷的修改不会对镜像产生影响<br>5.卷会一直存在，直到没有容器在使用它<br>6.卷可以在 Linux 和 Windows 容器上运行。<br><br>示例：<br>VOLUME [&quot;/data&quot;]<br>    VOLUME [&quot;/var/mysql&quot;, &quot;/var/log/mysql&quot;, &quot;/etc/mysql&quot;]<br>    <br>FROM ubuntu<br>RUN mkdir /myvol<br>RUN echo &quot;hello world&quot; &gt; /myvol/greeting<br>VOLUME /myvol<br></code></pre></td></tr></table></figure><ul><li>说明：</li></ul><p>VOLUME指令创建具有指定名称的挂载点，并将其标记为保存来自本机主机或其他容器的外部挂载卷。<br>参考<a href="https://linzyblog.netlify.app/2022/08/31/docker-volumes/">《Docker卷(volumes)》</a></p><blockquote><p><strong>关于指定卷的注意事项：</strong></p><ol><li><code>基于 Windows 的容器上的卷</code>：使用基于 Windows 的容器时，容器内卷的目标必须是以下之一：<br> - 不存在或为空的目录<br> - C盘以外的驱动器</li><li><code>从 Dockerfile 中更改卷</code>：如果任何构建步骤在声明卷后更改了卷中的数据，则这些更改将被丢弃。</li><li><code>JSON 格式</code>：列表被解析为 JSON 数组。必须用双引号 ( “) 而不是单引号 ( ‘) 将单词括起来。</li><li><code>主机目录在容器运行时声明</code>：主机目录（挂载点）本质上是依赖于主机的。这是为了保持镜像的可移植性，因为不能保证给定的主机目录在所有主机上都可用。由于这个原因，你不能从Dockerfile内挂载主机目录。<code>VOLUME</code>指令不支持指定<code>host-dir</code>参数。<code>在创建或运行容器时，必须指定挂载点</code>。</li></ol></blockquote><h2 id="14、USER"><a href="#14、USER" class="headerlink" title="14、USER"></a>14、USER</h2><ul><li>作用：设置用户名（或 UID）和可选的用户组（或 GID）。</li><li>格式：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>(1)USER &lt;user&gt;[:&lt;group&gt;]<br>(2)USER &lt;UID&gt;[:&lt;GID&gt;]<br><br>注：<br>使用USER指定用户后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT都将使用该用户。<br>　　镜像构建完成后，通过docker run运行容器时，可以通过-u参数来覆盖所指定的用户。<br><br>示例：<br>USER linzy<br></code></pre></td></tr></table></figure><ul><li>说明：</li></ul><p>指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。使用USER指定用户时，可以使用用户名、UID或GID，或是两者的组合。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户。</p><blockquote><p>注意：<br>在 Windows 上，如果用户不是内置帐户，则必须先创建用户。这可以通过net user作为 Dockerfile 的一部分调用的命令来完成。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM microsoft/windowsservercore<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Create Windows user <span class="hljs-keyword">in</span> the container</span><br>RUN net user /add linzy<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Set it <span class="hljs-keyword">for</span> subsequent commands</span><br>USER linzy<br></code></pre></td></tr></table></figure><h2 id="15、WORKDIR"><a href="#15、WORKDIR" class="headerlink" title="15、WORKDIR"></a>15、WORKDIR</h2><ul><li>作用：设置工作目录。</li><li>格式：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">格式：<br>WORKDIR /path/to/workdir<br><br>注：<br>通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行。<br>在使用docker run运行容器时，可以通过-w参数覆盖构建时所设置的工作目录。<br><br>示例：<br>WORKDIR /a  (这时工作目录为/a)<br>    WORKDIR b  (这时工作目录为/a/b)<br>    WORKDIR c  (这时工作目录为/a/b/c)<br>RUN pwd # 最终pwd命令的输出Dockerfile将是/a/b/c.<br></code></pre></td></tr></table></figure><ul><li>说明：</li></ul><p><code>WORKDIR</code>设置工作目录，类似于cd命令。设置工作目录后，Dockerfile中其后的命令<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>、<code>ADD</code>、<code>COPY</code>等命令都会在该目录下执行。如果不存在，即使它没有在任何后续指令中使用，它也会被创建。</p><blockquote><p>注意：<br>Dockerfile里<code>WORKDIR</code>指令使用之前设置的环境变量 <code>ENV</code>，例如：</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ENV DIRPATH=/path<br>WORKDIR <span class="hljs-variable">$DIRPATH</span>/<span class="hljs-variable">$DIRNAME</span><br>RUN <span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure><blockquote><p>最终<code>pwd</code>命令的输出Dockerfile将是 <code>/path/$DIRNAME</code>。<br>如果未指定，默认工作目录为<code>/</code>。在实践中，如果你不是从头开始构建Dockerfile, <code>WORKDIR</code>可能由你正在使用的基础镜像设置。<br>因此，为了避免在未知目录中进行意外操作，<code>最好是显式设置WORKDIR</code>。</p></blockquote><h2 id="16、ARG"><a href="#16、ARG" class="headerlink" title="16、ARG"></a>16、ARG</h2><ul><li>作用：用于指定传递给构建运行时的变量(给Dockerfile传参)，相当于构建镜像时可以在外部为里面传参</li><li>格式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell">格式：<br>ARG &lt;name&gt;[=&lt;<span class="hljs-type">default</span> <span class="hljs-type">value</span>&gt;]<br><br>注：<br><span class="hljs-literal">--build-arg</span> &lt;varname&gt;=&lt;value&gt; 将变量传递给构建器。如果用户指定了未在Dockerfile中定义的构建参数，那么构建将输出一个警告。<br><br>示例：<br>FROM busybox<br>ARG user1<br>ARG buildno<br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><ul><li>说明：</li></ul><p><code>ARG</code>指令定义了一个变量，用户可以在构建时通过使用 标志的<code>docker build</code>命令将其传递给构建器。</p><blockquote><p>注意：<br><code>不建议使用构建时变量来传递 github 密钥、用户凭据等机密信息</code>。使用该<code>docker history</code>命令的映像的任何用户都可以看到构建时变量值。</p></blockquote><h3 id="1）默认值"><a href="#1）默认值" class="headerlink" title="1）默认值"></a>1）默认值</h3><p><code>ARG</code>指令可以设置默认值：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">FROM busybox<br>ARG user1=someuser<br>ARG buildno=<span class="hljs-number">1</span><br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><p>如果<code>ARG</code>指令具有默认值并且在构建时没有传递任何值，则构建器将使用默认值。</p><h3 id="2）使用-ARG-变量"><a href="#2）使用-ARG-变量" class="headerlink" title="2）使用 ARG 变量"></a>2）使用 ARG 变量</h3><p>可以使用<code>ARG</code>或<code>ENV</code>指令指定<code>RUN</code>指令可用的变量。使用<code>ENV</code>指令定义的环境变量总是覆盖同名的<code>ARG</code>指令。</p><p>带有<code>ENV</code> 和 <code>ARG</code>指令的 <code>Dockerfile</code> 例子：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">FROM ubuntu<br>ARG CONT_IMG_VER<br>ENV CONT_IMG_VER=v1.<span class="hljs-number">0.0</span><br>RUN <span class="hljs-built_in">echo</span> <span class="hljs-variable">$CONT_IMG_VER</span><br></code></pre></td></tr></table></figure><p>镜像是用这个命令构建的：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker build <span class="hljs-literal">--build-arg</span> CONT_IMG_VER=v2.<span class="hljs-number">0.1</span> .<br></code></pre></td></tr></table></figure><p><code>RUN</code>指令使用v1.0.0而不是<code>ARG</code>用户传递的设置。</p><h2 id="17、ONBUILD"><a href="#17、ONBUILD" class="headerlink" title="17、ONBUILD"></a>17、ONBUILD</h2><ul><li>作用：向镜像添加了一条触发指令。</li><li>格式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">格式：<br>ONBUILD &lt;INSTRUCTION&gt;<br><br>注：<br>任何构建指令都可以注册为触发器。<br><br>示例：<br>ONBUILD ADD . /app/src<br>ONBUILD RUN /usr/local/bin/python<span class="hljs-literal">-build</span> <span class="hljs-literal">--dir</span> /app/src<br></code></pre></td></tr></table></figure><ul><li>说明：</li></ul><p>ONBUILD指令向镜像添加了一条触发指令。</p><p>NNBUID后面跟指令，当该镜像被用作另一个构建的基础镜像时，触发器将在其构建的上下文中执行。<code>就好像它是FROM 在指令之后立即插入的一样Dockerfile。</code></p><p>如果你正在构建一个镜像，该镜像将用作构建其他镜像的基础，例如可以特定于用户的配置定制的应用程序构建环境或守护进程。</p><blockquote><p>注意：<br><code>ONBUILD</code>指令可能不会触发<code>FROM</code>或<code>MAINTAINER</code>指令。</p></blockquote><h2 id="18、Dockerfile常用指令"><a href="#18、Dockerfile常用指令" class="headerlink" title="18、Dockerfile常用指令"></a>18、Dockerfile常用指令</h2><p><img src="/img/docker_Dockerfile/docker5.png"></p><table><thead><tr><th>指令</th><th align="left">描述</th></tr></thead><tbody><tr><td>FROM</td><td align="left">构建新镜像使用的基础镜像</td></tr><tr><td>MAINTAINER（已弃用）</td><td align="left">构建镜像的作者或邮件地址</td></tr><tr><td>RUN</td><td align="left">构建镜像时执行命令</td></tr><tr><td>COPY</td><td align="left">拷贝文件或目录到镜像中</td></tr><tr><td>ENV</td><td align="left">设置环境变量</td></tr><tr><td>USER</td><td align="left">为RUN、CMD和ENTRYPOINT等执行命令指定运行用户</td></tr><tr><td>EXPOSE</td><td align="left">声明容器运行的服务端口</td></tr><tr><td>WORKDIR</td><td align="left">为RUN、CMD、ENTRYPOINT、COPY和ADD设置工作目录</td></tr><tr><td>ENTRYPOINT</td><td align="left">运行容器时执行，如果由多个ENTRYPOINT指令，最后一个生效，可以追加命令</td></tr><tr><td>CMD</td><td align="left">运行容器时执行，如果由多个CMD 指令，最后一个生效，可被替代</td></tr><tr><td>LABEL</td><td align="left">设置镜像的标签</td></tr><tr><td>VOLUME</td><td align="left">设置容器的挂载卷</td></tr><tr><td>ARG</td><td align="left">指令定义了一个变量</td></tr><tr><td>ONBUILD</td><td align="left">向镜像添加了一条触发指令</td></tr></tbody></table><h1 id="四、构建自己的镜像"><a href="#四、构建自己的镜像" class="headerlink" title="四、构建自己的镜像"></a>四、构建自己的镜像</h1><h2 id="1、构建镜像步骤"><a href="#1、构建镜像步骤" class="headerlink" title="1、构建镜像步骤"></a>1、构建镜像步骤</h2><p>构建镜像步骤：</p><ol><li>编写一个<code>Dockerfile</code> 文件</li><li>通过 <code>docker build</code> 命令构建成一个镜像</li><li><code>docker run</code> 命令运行镜像</li><li><code>docker push</code> 命令发布镜像到<code>Docker Hub</code></li></ol><blockquote><p>注意：</p><ul><li>如果有多个<code>RUN</code>,自上而下依次运行，每次运行都会形成新的层，建议&amp;&amp; 放入一行运行</li><li>如果有多个<code>CMD</code>,只有最后一个运行</li><li>如果有多个<code>ENTRYPOINT</code> ，只有最后一个运行</li><li>如果<code>CMD</code>和<code>ENTRYPOINT</code>共存，只有<code>ENTRYPOINT</code> 运行，且最后的<code>CMD</code>会当做<code>ENTRYPOINT</code> 的参数</li></ul></blockquote><h2 id="2、编写Dockerfile文件"><a href="#2、编写Dockerfile文件" class="headerlink" title="2、编写Dockerfile文件"></a>2、编写Dockerfile文件</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 基础镜像</span><br>FROM centos<br><br><span class="hljs-comment">#MAINTAINER 维护者信息</span><br>MAINTAINER linzy&lt;<span class="hljs-number">2350621012</span>@qq.com&gt;<br><br><span class="hljs-comment">#ENV 设置环境变量</span><br>ENV MYPATH /usr/local<br><br><span class="hljs-comment">#WORKDIR 相当于cd</span><br>WORKDIR <span class="hljs-variable">$MYPATH</span><br><br><span class="hljs-comment">#RUN 执行命令</span><br>RUN yum <span class="hljs-literal">-y</span> install vim <br>RUM yum <span class="hljs-literal">-y</span> install net<span class="hljs-literal">-tools</span><br><br><span class="hljs-comment">#EXPOSE 映射端口</span><br>EXPOSE <span class="hljs-number">80</span><br><br><span class="hljs-comment">#CMD 运行命令</span><br>CMD <span class="hljs-built_in">echo</span> <span class="hljs-variable">$MYPATH</span><br>CMD <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----end----&quot;</span><br>CMD /bin/bash<br><br></code></pre></td></tr></table></figure><blockquote><p>逐行解释该<code>Dockerfile</code>文件的指令：</p><ol><li><code>FROM centos</code> ：该image文件继承官方的centos，他会先在你本地寻找centos镜像</li><li><code>ENV MYPATH /usr/local</code>：设置环境变量MYPATH</li><li><code>WORKDIR $MYPATH</code>：直接使用上面设置的环境变量，指定&#x2F;usr&#x2F;local为工作目录</li><li><code>RUN yum -y install vim &amp;&amp; RUM yum -y install net-tools</code>：在&#x2F;usr&#x2F;local目录下，运行yum -y install vim和yum -y install net-tools命令安装工具，注意安装后的所有依赖和工具都会打包到image文件中</li><li><code>EXPOSE 80</code>·：将容器80端口暴露出来，允许外部连接这个端口</li><li><code>CMD</code>：指定容器启动的时候运行命令<br> - CMD echo $MYPATH：输出MYPATH环境变量<br> - CMD echo “—–end—-“：输出—–end—-<br> - CMD &#x2F;bin&#x2F;bash：进入&#x2F;bin&#x2F;bash命令行</li></ol></blockquote><h2 id="3、执行build命令构建镜像"><a href="#3、执行build命令构建镜像" class="headerlink" title="3、执行build命令构建镜像"></a>3、执行build命令构建镜像</h2><p>执行build命令生成image文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker build <span class="hljs-literal">-t</span> mycentos:<span class="hljs-number">1.0</span> .<br></code></pre></td></tr></table></figure><p><img src="/img/docker_Dockerfile/docker6.png"><br>如果出现<code>Error: Failed to download metadata for repo &#39;appstream&#39;: Cannot prepare internal mirrorlist: No URLs in mirrorlist</code> 错误，不要惊慌！</p><p>报错信息的意思是：<code>从仓库 ‘appstream’ 下载元数据失败：由于镜像列表中没有 URL，不能准备内部镜像列表。</code></p><blockquote><p>错误原因：</p><ol><li>可能的情况便是网络连接问题。检查是否可以连接外部网络，可以使用 <code>ping baidu.com</code> 查看是否有丢包情况。如果丢包，则进一步检查网络连接是否正常；如果没有丢包，继续阅读下文</li><li>第二种情况，便是 CentOS 已经停止维护的问题。2020 年 12 月 8 号，CentOS 官方宣布了停止维护 CentOS Linux 的计划，并推出了 CentOS Stream 项目，CentOS Linux 8 作为 RHEL 8 的复刻版本，生命周期缩短，于 2021 年 12 月 31 日停止更新并停止维护（EOL）。</li></ol></blockquote><h3 id="解决Error-Failed-to-download-metadata-for-repo-39-appstream-39-Cannot-prepare-internal-mirrorlist-No-URLs-in-mirrorlist错误"><a href="#解决Error-Failed-to-download-metadata-for-repo-39-appstream-39-Cannot-prepare-internal-mirrorlist-No-URLs-in-mirrorlist错误" class="headerlink" title="解决Error: Failed to download metadata for repo &#39;appstream&#39;: Cannot prepare internal mirrorlist: No URLs in mirrorlist错误"></a>解决<code>Error: Failed to download metadata for repo &#39;appstream&#39;: Cannot prepare internal mirrorlist: No URLs in mirrorlist</code>错误</h3><blockquote><p>因为我们的<code>Dockerfile</code>的基础镜像是可以基于本地的镜像，所以我们只需要修改本地的<code>centos</code>镜像，再用我们的<code>commit</code>指令生成新的镜像用来当我们<code>Dockerfile</code>的基础镜像<br><code>commit指令</code>参考文章《<a href="https://linzyblog.netlify.app/2022/08/31/docker-images/">Docker镜像概述和分层原理</a>》</p></blockquote><ol><li>运行centos镜像，并进入交互界面</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker run <span class="hljs-literal">-it</span> <span class="hljs-literal">-P</span> centos<br></code></pre></td></tr></table></figure><p><img src="/img/docker_Dockerfile/docker7.png"></p><ol start="2"><li>进入到 yum 的 repos 目录</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">cd</span> /etc/yum.repos.d/<br></code></pre></td></tr></table></figure><ol start="3"><li>修改 centos 文件内容</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">sed <span class="hljs-literal">-i</span> <span class="hljs-string">&#x27;s/mirrorlist/#mirrorlist/g&#x27;</span> /etc/yum.repos.d/CentOS-*<br>sed <span class="hljs-literal">-i</span> <span class="hljs-string">&#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27;</span> /etc/yum.repos.d/CentOS-*<br></code></pre></td></tr></table></figure><ol start="4"><li>生成缓存更新（第一次更新，速度稍微有点慢，耐心等待两分钟左右）</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">yum makecache<br></code></pre></td></tr></table></figure><p><img src="/img/docker_Dockerfile/docker8.png"></p><ol start="5"><li>运行 yum update (更新的东西很多，大约五分钟)</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">yum update <span class="hljs-literal">-y</span><br></code></pre></td></tr></table></figure><p><img src="/img/docker_Dockerfile/docker9.png"><br><img src="/img/docker_Dockerfile/docker10.png"><br>出现Complete的就是成功了</p><ol start="6"><li>使用<code>docker commit</code> 将容器保存为新的镜像</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker commit c638ed426e64  mycentos:<span class="hljs-number">0.1</span><br></code></pre></td></tr></table></figure><p><img src="/img/docker_Dockerfile/docker12.png"></p><ol start="7"><li>修改一下我们的Dockerfile里的FROM基础镜像这块</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 基础镜像 修改为mycentos:0.1</span><br>FROM mycentos:<span class="hljs-number">0.1</span><br><br><span class="hljs-comment">#MAINTAINER 维护者信息</span><br>MAINTAINER linzy&lt;<span class="hljs-number">2350621012</span>@qq.com&gt;<br><br><span class="hljs-comment">#ENV 设置环境变量</span><br>ENV MYPATH /usr/local<br><br><span class="hljs-comment">#WORKDIR 相当于cd</span><br>WORKDIR <span class="hljs-variable">$MYPATH</span><br><br><span class="hljs-comment">#RUN 执行命令</span><br>RUN yum <span class="hljs-literal">-y</span> install vim <br>RUN yum <span class="hljs-literal">-y</span> install net<span class="hljs-literal">-tools</span><br><br><span class="hljs-comment">#EXPOSE 映射端口</span><br>EXPOSE <span class="hljs-number">80</span><br><br><span class="hljs-comment">#CMD 运行命令</span><br>CMD <span class="hljs-built_in">echo</span> <span class="hljs-variable">$MYPATH</span><br>CMD <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----end----&quot;</span><br>CMD /bin/bash<br></code></pre></td></tr></table></figure><ol start="8"><li>重新执行<code>build</code>命令</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker build <span class="hljs-literal">-t</span> mycentos:<span class="hljs-number">1.0</span> .<br></code></pre></td></tr></table></figure><p><img src="/img/docker_Dockerfile/docker13.png"><br><img src="/img/docker_Dockerfile/docker14.png"><br>构建centos镜像成功！</p><h2 id="4、测试运行"><a href="#4、测试运行" class="headerlink" title="4、测试运行"></a>4、测试运行</h2><h3 id="1）使用-docker-history-镜像id-查看镜像构建过程"><a href="#1）使用-docker-history-镜像id-查看镜像构建过程" class="headerlink" title="1）使用 docker history 镜像id 查看镜像构建过程"></a>1）使用 <code>docker history</code> 镜像id 查看镜像构建过程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">E:\dockerfile&gt;docker <span class="hljs-built_in">history</span>  2b92daa4f916<br>IMAGE          CREATED          CREATED BY                                      SIZE      COMMENT<br>2b92daa4f916   29 minutes ago   CMD [<span class="hljs-string">&quot;/bin/sh&quot;</span> <span class="hljs-string">&quot;-c&quot;</span> <span class="hljs-string">&quot;/bin/bash&quot;</span>]                0B        buildkit.dockerfile.v0<br>&lt;missing&gt;      29 minutes ago   CMD [<span class="hljs-string">&quot;/bin/sh&quot;</span> <span class="hljs-string">&quot;-c&quot;</span> <span class="hljs-string">&quot;echo \&quot;-----end----\&quot;&quot;</span>]    0B        buildkit.dockerfile.v0<br>&lt;missing&gt;      29 minutes ago   CMD [<span class="hljs-string">&quot;/bin/sh&quot;</span> <span class="hljs-string">&quot;-c&quot;</span> <span class="hljs-string">&quot;echo <span class="hljs-variable">$MYPATH</span>&quot;</span>]             0B        buildkit.dockerfile.v0<br>&lt;missing&gt;      29 minutes ago   EXPOSE map[80/tcp:&#123;&#125;]                           0B        buildkit.dockerfile.v0<br>&lt;missing&gt;      29 minutes ago   RUN /bin/sh -c yum -y install net-tools <span class="hljs-comment"># bu…   28.7MB    buildkit.dockerfile.v0</span><br>&lt;missing&gt;      29 minutes ago   RUN /bin/sh -c yum -y install vim <span class="hljs-comment"># buildkit    67.2MB    buildkit.dockerfile.v0</span><br>&lt;missing&gt;      29 minutes ago   WORKDIR /usr/local                              0B        buildkit.dockerfile.v0<br>&lt;missing&gt;      29 minutes ago   ENV MYPATH=/usr/local                           0B        buildkit.dockerfile.v0<br>&lt;missing&gt;      29 minutes ago   MAINTAINER linzy&lt;2350621012@qq.com&gt;             0B        buildkit.dockerfile.v0<br>&lt;missing&gt;      32 minutes ago   /bin/bash                                       302MB<br>&lt;missing&gt;      11 months ago    /bin/sh -c <span class="hljs-comment">#(nop)  CMD [&quot;/bin/bash&quot;]            0B</span><br>&lt;missing&gt;      11 months ago    /bin/sh -c <span class="hljs-comment">#(nop)  LABEL org.label-schema.sc…   0B</span><br>&lt;missing&gt;      11 months ago    /bin/sh -c <span class="hljs-comment">#(nop) ADD file:805cb5e15fb6e0bb0…   231MB</span><br></code></pre></td></tr></table></figure><h3 id="2）运行容器，看看是否能够执行ifconfig-及vim命令"><a href="#2）运行容器，看看是否能够执行ifconfig-及vim命令" class="headerlink" title="2）运行容器，看看是否能够执行ifconfig 及vim命令"></a>2）运行容器，看看是否能够执行<code>ifconfig</code> 及<code>vim</code>命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">E:\dockerfile&gt;docker run -it mycentos:1.0<br>[root@392bed5a0bcd <span class="hljs-built_in">local</span>]<span class="hljs-comment"># pwd</span><br>/usr/local<br>[root@392bed5a0bcd <span class="hljs-built_in">local</span>]<span class="hljs-comment"># ifconfig</span><br>eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255<br>        ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)<br>        RX packets 11  bytes 906 (906.0 B)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 0  bytes 0 (0.0 B)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536<br>        inet 127.0.0.1  netmask 255.0.0.0<br>        loop  txqueuelen 1000  (Local Loopback)<br>        RX packets 0  bytes 0 (0.0 B)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 0  bytes 0 (0.0 B)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>[root@392bed5a0bcd <span class="hljs-built_in">local</span>]<span class="hljs-comment"># vim</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>Docker</tag>
      
      <tag>go</tag>
      
      <tag>容器</tag>
      
      <tag>linux</tag>
      
      <tag>云原生</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker卷(volumes)</title>
    <link href="/2022/08/31/docker-volumes/"/>
    <url>/2022/08/31/docker-volumes/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>学习本文需要一些了解Docker的概念以及一些名词。</p></blockquote><h1 id="一、在Docker中管理数据"><a href="#一、在Docker中管理数据" class="headerlink" title="一、在Docker中管理数据"></a>一、在Docker中管理数据</h1><h2 id="1、为什么要挂载？"><a href="#1、为什么要挂载？" class="headerlink" title="1、为什么要挂载？"></a>1、为什么要挂载？</h2><p>默认情况下，在容器内创建的所有文件都存储在可写容器层上。这意味着：</p><ul><li>当该容器被删除时，数据也会被同样删除，如果有另一个进程需要数据，就很难从容器中取出数据。</li><li><strong>容器的可写层与运行容器的宿主机紧密耦合</strong>，你无法将数据移动到其他地方。</li><li>写入容器的可写层需要存储驱动程序来管理文件系统。存储驱动程序提供了一个联合文件系统，使用 Linux 内核。与使用直接写入主机文件系统的数据卷相比，这种额外的抽象会降低性能 。</li></ul><blockquote><p>Docker有两种方法：<strong>volumes</strong> 卷 和 <strong>bind mounts</strong> 绑定挂载 可以让容器在主机上存储文件，以便即使容器停止或删除后文件也能持久化保存。<br>Docker 还支持将文件存储在主机内存中的容器。此类文件不会持久保存。如果您在 Linux 上运行 Docker，则使用tmpfs 挂载将文件存储在主机的系统内存中。如果您在 Windows 上运行 Docker，命名管道用于将文件存储在主机的系统内存中。</p></blockquote><h2 id="2、选择正确的挂载方式"><a href="#2、选择正确的挂载方式" class="headerlink" title="2、选择正确的挂载方式"></a>2、选择正确的挂载方式</h2><p>无论你选择那种挂载的方式，容器内的数据看起来都是一样的。数据以目录或文件系统中的单个文件的形式公开。</p><p><strong>卷(volumes)、绑定挂载(bind mounts)和 tmpfs挂载(tmpfs mounts) 之间的差异就是数据在Docker主机上的位置不同。</strong></p><p><img src="/img/docker_volumes/docker1.png"></p><ul><li><strong>卷(volumes)<strong>：存储在由 Docker（&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;在 Linux 上）管理的主机文件系统的一部分中。非 Docker 进程不应修改文件系统的这一部分。</strong>卷是在 Docker 中持久化数据的最佳方式。</strong></li><li><strong>绑定挂载(bind mounts)<strong>：可以存储在主机系统的任何位置。它们甚至可能是重要的系统文件或目录。</strong>Docker 主机或 Docker 容器上的非 Docker 进程可以随时修改它们。</strong></li><li>**tmpfs挂载(tmpfs mounts)**：仅存储在主机系统的内存中，永远不会写入主机系统的文件系统。</li></ul><h1 id="二、卷-volume"><a href="#二、卷-volume" class="headerlink" title="二、卷(volume)"></a>二、卷(volume)</h1><h2 id="1、卷的概述"><a href="#1、卷的概述" class="headerlink" title="1、卷的概述"></a>1、卷的概述</h2><p><strong>卷(volume)提供了将容器的特定文件系统路径连接回主机的能力</strong>，简单来说就是将容器的目录映射到主机上。如果容器中的目录已挂载，则该目录中的更改也会在主机上看到。如果我们在容器重启时挂载相同的目录，我们会看到相同的文件，这就是容器的持久化和同步操作。</p><blockquote><ul><li>Docker Volume 命令能让容器从宿主机中读取文件，或从容器中持久化数据到宿主机中，让容器与容器产生的数据分离开来，<strong>一个容器可以挂载多个不同的目录</strong>。</li><li>Volume的生命周期是独立于容器的生命周期之外的，即使容器删除了，Volume也会被保留下来，Docker不会因为这个Volume没有被容器使用而自动回收。</li><li>在容器中，添加或修改这个文件夹里的文件也不会影响到容器的联合文件系统。</li></ul></blockquote><h2 id="2、卷的优点"><a href="#2、卷的优点" class="headerlink" title="2、卷的优点"></a>2、卷的优点</h2><p><strong>卷是Docker容器生成和使用数据的首选保存机制</strong>。绑定挂载依赖于主机的目录结构和操作系统，但卷是完全由Docker管理。</p><ul><li>卷比绑定挂载更容易备份或迁移数据。</li><li>卷可以直接使用Docker CLI 命令或 Docker API 管理。</li><li>卷可以在 Linux 和 Windows 容器上运行。</li><li>卷可以在多个容器之间更安全的共享。</li><li>卷允许将卷挂载到远程主机或云服务器上，以加密卷的内容或添加其他功能。</li><li>新卷的内容可以由容器预先填充。</li><li>Docker Desktop 上的卷比 来自Mac 和 Windows 主机的绑定挂载具有更高的性能。</li></ul><p> 此外，与将数据持久化到容器的可写层相比，卷通常是更好的选择，因为卷不会增加使用它的容器的大小，而且卷的内容存在于给定容器的生命周期之外</p><p><img src="/img/docker_volumes/docker2.png"></p><blockquote><p>注意：如果你的容器需要生成非持久化状态数据，优先选择tmpfs 挂载以避免将数据永久存储在任何地方，并且避免写入容器的可写层来提高容器性能。</p></blockquote><h2 id="3、卷的使用"><a href="#3、卷的使用" class="headerlink" title="3、卷的使用"></a>3、卷的使用</h2><ul><li>格式：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">docker run -it -v 主机目录:容器内目录<br></code></pre></td></tr></table></figure><ul><li>测试：</li></ul><ol><li>使用卷将容器内&#x2F;home目录挂载绑定到主机的E:&#x2F;home&#x2F;test目录下，Docker会自动在主机创建目录<br><img src="/img/docker_volumes/docker3.png"></li></ol><p><img src="/img/docker_volumes/docker4.png"><br>2. 用docker inspect 命令查看容器挂载数据，找到Mounts数据<br><img src="/img/docker_volumes/docker5.png"></p><p><img src="/img/docker_volumes/docker6.png"></p><ul><li><strong>Type</strong>：挂载的类型，可以是bind、volume或 tmpfs。</li><li><strong>Source</strong>：主机内目录路径地址。</li><li><strong>Destination</strong>：Docker容器内目录的路径地址。</li></ul><ol start="3"><li>在容器的&#x2F;home目录下进行操作</li></ol><p><img src="/img/docker_volumes/docker7.png"></p><p><img src="/img/docker_volumes/docker8.png"><br>在主机目录也会同时创建一个test.go。</p><p>这是同步的过程，双方目录挂载后，双方各自的操作是双向绑定的。</p><ol start="4"><li>停止Docker 容器后，修改主机目录内的文件内容，启动容器后，数据是否还是会同步到容器</li></ol><p><img src="/img/docker_volumes/docker9.png"></p><p><img src="/img/docker_volumes/docker10.png"></p><p><img src="/img/docker_volumes/docker11.png"><br>是可以的，挂载目录是双向绑定的，以后只需在本地修改即可，容器内也会自动同步</p><h2 id="4、实战-持久化数据"><a href="#4、实战-持久化数据" class="headerlink" title="4、实战:持久化数据"></a>4、实战:持久化数据</h2><h3 id="1）MySQL容器为什么挂载数据卷？"><a href="#1）MySQL容器为什么挂载数据卷？" class="headerlink" title="1）MySQL容器为什么挂载数据卷？"></a>1）MySQL容器为什么挂载数据卷？</h3><p>我们每次启动一个MySQL容器，数据库都是空的。删除容器后，数据也同样丢失，如果有其他进程也在访问这个数据库，就会取不出数据。</p><blockquote><p><strong>数据卷</strong>：设计用来持久化数据的，它的生命周期独立于容器，不会因为容器被删除后自动删除，并且也不存在<strong>垃圾回收</strong>这样的机制来处理没有任何容器引用的 数据卷。</p></blockquote><h3 id="2）MySQL容器挂载数据卷"><a href="#2）MySQL容器挂载数据卷" class="headerlink" title="2）MySQL容器挂载数据卷"></a>2）MySQL容器挂载数据卷</h3><ol><li>拉取MySQL镜像，运行容器的时候做挂载数据卷，<strong>启动MySQL容器需要配置密码</strong></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">docker run -d -p <span class="hljs-number">3310</span>:<span class="hljs-number">3306</span> -v E:/home/mysql/conf:/etc/mysql/conf.d -v E:/home/mysql/data:/<span class="hljs-keyword">var</span>/lib/mysql -e MYSQL_ROOT_PASSWORD=<span class="hljs-number">123456</span> --name mysqltest mysql:<span class="hljs-number">5.7</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>可选项名称</th><th align="left">说明</th></tr></thead><tbody><tr><td>-d</td><td align="left">在后台运行容器并打印容器 ID</td></tr><tr><td>-p</td><td align="left">-p xxxx:yyyy：宿主机上xxxx端口对应容器中yyyy端口，在外部访问时用的是宿主机上的端口</td></tr><tr><td>-v</td><td align="left">卷挂载</td></tr><tr><td>-e</td><td align="left">环境配置</td></tr><tr><td>–name</td><td align="left">容器名称</td></tr></tbody></table><p><img src="/img/docker_volumes/docker12.png"></p><ol start="2"><li>启动容器成功之后，本地用navicat连接数据库测试一下</li></ol><p><img src="/img/docker_volumes/docker13.png"></p><p><img src="/img/docker_volumes/docker14.png"><br>3. 新建一个test数据库，建立test数据表，并插入几条数据。</p><p><img src="/img/docker_volumes/docker15.png"></p><ol start="4"><li>删除MySQL容器，在重新运行后，测试一下数据是否还存在，数据是否是持久化的。</li></ol><p><img src="/img/docker_volumes/docker16.png"></p><p><img src="/img/docker_volumes/docker17.png"></p><blockquote><p>我们可以看到数据依旧存在，我们挂载在本地的数据并没有随着容器的删除而丢失，它的生命周期已经独立于容器，这就实现了容器数据持久化。</p></blockquote><h2 id="5、Volume命令"><a href="#5、Volume命令" class="headerlink" title="5、Volume命令"></a>5、Volume命令</h2><h3 id="1）docker-volume-create"><a href="#1）docker-volume-create" class="headerlink" title="1）docker volume create"></a>1）docker volume create</h3><ul><li>作用：创建数据卷</li><li>格式：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">docker volume create [OPTIONS] [卷名]<br></code></pre></td></tr></table></figure><ul><li>说明</li></ul><p>创建容器可以使用和存储数据的新卷。如果未指定名称，Docker 会生成一个随机名称。</p><ul><li>可选项：</li></ul><table><thead><tr><th>名称，简写</th><th>默认</th><th align="left">描述</th></tr></thead><tbody><tr><td>–driver,-d</td><td>local</td><td align="left">指定卷驱动程序名称</td></tr><tr><td>–label</td><td></td><td align="left">为卷设置元数据</td></tr><tr><td>–name</td><td></td><td align="left">指定卷名</td></tr><tr><td>–opt,-o</td><td></td><td align="left">设置驱动程序特定选项</td></tr></tbody></table><ul><li>例子：<br><img src="/img/docker_volumes/docker18.png"></li></ul><h3 id="2）docker-volume-inspect"><a href="#2）docker-volume-inspect" class="headerlink" title="2）docker volume inspect"></a>2）docker volume inspect</h3><ul><li>作用：显示一个或多个卷的详细信息</li><li>格式：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">docker volume inspect [OPTIONS] 卷名 [卷名...]<br></code></pre></td></tr></table></figure><ul><li>说明：</li></ul><p>返回有关卷的信息。默认情况下，此命令将所有结果呈现在 JSON 数组中。您可以指定替代格式来为每个结果执行给定的模板。Go 的 text&#x2F;template包描述了该格式的所有细节。</p><ul><li>可选项：</li></ul><table><thead><tr><th>名称，简写</th><th>默认</th><th align="left">描述</th></tr></thead><tbody><tr><td>–format,-f</td><td></td><td align="left">使用给定的 Go 模板格式化输出</td></tr></tbody></table><ul><li>例子：</li></ul><p><img src="/img/docker_volumes/docker19.png"></p><blockquote><ul><li>当你创建一个Volume，Docker都会默认在宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes目录下自动创建一个子目录，默认情况下都是目录名都是一串UUID。</li><li>如果指定了名称，则目录名是Volume名称。Volume里的数据都存储在这个子目录的_data目录下。</li></ul></blockquote><h3 id="3）docker-volume-ls"><a href="#3）docker-volume-ls" class="headerlink" title="3）docker volume ls"></a>3）docker volume ls</h3><ul><li>作用：查看本地数据卷列表</li><li>格式：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">docker volume ls [OPTIONS]<br></code></pre></td></tr></table></figure><ul><li>说明：</li></ul><p>列出 Docker 已知的所有卷。可以使用 -f or –filter标志进行过滤。</p><ul><li>可选项：</li></ul><table><thead><tr><th>名称，简写</th><th>默认</th><th align="left">描述</th></tr></thead><tbody><tr><td>–filter,-f</td><td></td><td align="left">提供过滤器值（例如 ‘dangling&#x3D;true’）</td></tr><tr><td>–format</td><td></td><td align="left">使用 Go 模板格式化打印卷</td></tr><tr><td>–quiet,-q</td><td></td><td align="left">只显示卷名</td></tr></tbody></table><ul><li>例子：</li></ul><p><img src="/img/docker_volumes/docker20.png"></p><h3 id="4）docker-volume-prune"><a href="#4）docker-volume-prune" class="headerlink" title="4）docker volume prune"></a>4）docker volume prune</h3><ul><li>作用：删除所有<strong>未使用</strong>的本地卷</li><li>格式：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">docker volume prune [OPTIONS]<br></code></pre></td></tr></table></figure><ul><li>说明：</li></ul><p>删除所有未使用的本地卷。未使用的本地卷是那些未被任何容器引用的本地卷</p><ul><li>可选项：</li></ul><table><thead><tr><th>名称，简写</th><th>默认</th><th align="left">描述</th></tr></thead><tbody><tr><td>–filter</td><td></td><td align="left">提供过滤器值（例如 ‘label&#x3D;<label>‘）</td></tr><tr><td>–force,-f</td><td></td><td align="left">不提示确认</td></tr></tbody></table><ul><li>例子：</li></ul><p><img src="/img/docker_volumes/docker21.png"></p><h3 id="5）docker-volume-rm"><a href="#5）docker-volume-rm" class="headerlink" title="5）docker volume rm"></a>5）docker volume rm</h3><ul><li>作用：删除一个或多个卷</li><li>格式：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">docker volume rm [OPTIONS] 卷名[卷名...]<br></code></pre></td></tr></table></figure><ul><li>说明：</li></ul><p>删除一个或多个卷。您不能删除容器正在使用的卷。</p><ul><li>可选项：</li></ul><table><thead><tr><th>名称，简写</th><th>默认</th><th align="left">描述</th></tr></thead><tbody><tr><td>–force,-f</td><td></td><td align="left">强制删除一个或多个卷</td></tr></tbody></table><ul><li>例子：</li></ul><p><img src="/img/docker_volumes/docker22.png"></p><h2 id="6、匿名挂载和具名挂载"><a href="#6、匿名挂载和具名挂载" class="headerlink" title="6、匿名挂载和具名挂载"></a>6、匿名挂载和具名挂载</h2><h3 id="1）匿名挂载"><a href="#1）匿名挂载" class="headerlink" title="1）匿名挂载"></a>1）匿名挂载</h3><p>没有给数据卷名字的挂载。<br><img src="/img/docker_volumes/docker23.png"><br>除了最后一条由具体名字的挂载，其他都是匿名挂载的</p><p>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">docker run -d -P -v 容器内路径 镜像名:tag1<br></code></pre></td></tr></table></figure><p><img src="/img/docker_volumes/docker24.png"></p><h3 id="2）具名挂载"><a href="#2）具名挂载" class="headerlink" title="2）具名挂载"></a>2）具名挂载</h3><p>给数据卷指定名字的挂载。</p><p><img src="/img/docker_volumes/docker25.png"></p><p>最后一条是具名挂载的数据卷</p><p>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">docker run -d -P --name 容器名称 -v 卷名称:容器内路径 镜像名:tag<br></code></pre></td></tr></table></figure><p><img src="/img/docker_volumes/docker26.png"></p><h3 id="3）如何区分挂载？"><a href="#3）如何区分挂载？" class="headerlink" title="3）如何区分挂载？"></a>3）如何区分挂载？</h3><blockquote><p>如何区分匿名挂载、具名挂载还是指定路径挂载呢？</p><ol><li>匿名挂载：-v 容器内路径 </li><li>具名挂载 ：-v 卷名：容器内路径</li><li>指定路径挂载：-v &#x2F;宿主机路径：容器内路径</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>Docker容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>Docker</tag>
      
      <tag>go</tag>
      
      <tag>容器</tag>
      
      <tag>linux</tag>
      
      <tag>云原生</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker镜像概述和分层原理</title>
    <link href="/2022/08/31/docker-images/"/>
    <url>/2022/08/31/docker-images/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>学习本文需要一些了解Docker的概念以及一些名词。</p></blockquote><h1 id="一、Docker镜像概述"><a href="#一、Docker镜像概述" class="headerlink" title="一、Docker镜像概述"></a>一、Docker镜像概述</h1><h2 id="1、镜像是什么？"><a href="#1、镜像是什么？" class="headerlink" title="1、镜像是什么？"></a>1、镜像是什么？</h2><p>镜像是一种轻量级、可执行的<strong>独立软件包</strong>，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时的库、环境变量和配置文件。</p><p>镜像是一个<strong>只读模板</strong>，带有创建Docker容器的说明。通常，一个镜像基于另一个镜像，并带有一些额外的定制。例如，您可以构建一个基于ubuntu镜像的镜像，但是要安装Apache web服务器和您的应用程序，以及运行应用程序所需的配置细节。</p><blockquote><p>Docker 镜像（Image），就相当于是一个 模板，其中包含创建 Docker 容器的说明，可以通过模板来创建容器服务，通过这个镜像我们可以创建多个容器，最终服务运行或项目运行都是在容器中的。</p></blockquote><h2 id="2、如何获取镜像？"><a href="#2、如何获取镜像？" class="headerlink" title="2、如何获取镜像？"></a>2、如何获取镜像？</h2><p>你可以创建自己的镜像，也可以只使用其他人创建并在Docker Hub中发布的镜像。要构建自己的镜像，需要创建一个Dockerfile，使用简单的语法定义创建和运行镜像所需的步骤。Dockerfile中的每一条指令都会在图像中创建一个层。当你更改Dockerfile并重新构建镜像时，只有那些已经更改的层才会重新构建。与其他虚拟化技术相比，这是镜像如此轻量级、小巧和快速的原因之一。</p><ul><li>从Docker Hub上拉取镜像(常用)</li><li>自己制作镜像 Dockerfile 创建</li><li>从别人那边拷贝一份</li></ul><h1 id="二、Docker镜像加载原理"><a href="#二、Docker镜像加载原理" class="headerlink" title="二、Docker镜像加载原理"></a>二、Docker镜像加载原理</h1><h2 id="1、UnionFs-联合文件系统"><a href="#1、UnionFs-联合文件系统" class="headerlink" title="1、UnionFs 联合文件系统"></a>1、UnionFs 联合文件系统</h2><p>Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统被称为UnionFS。</p><ul><li><p><strong>Union文件系统</strong>(UnionFs)是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，而且目录的物理位置是分开的。</p></li><li><p>Union文件系统可以把只读和可读写文件系统合并在一起，具有<strong>Copy-on-Write</strong>功能，允许只读文件系统的修改可以保存到可写文件系统当中。</p></li><li><p>Union文件系统是Docker镜像的基础。<strong>镜像可以通过分层来进行继承</strong>，基于基础镜像(没有父镜像)，可以制作各种具体的应用镜像。</p></li></ul><blockquote><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统回包含所有底层的文件和目录。</p></blockquote><h2 id="2、Docker镜像加载原理"><a href="#2、Docker镜像加载原理" class="headerlink" title="2、Docker镜像加载原理"></a>2、Docker镜像加载原理</h2><h3 id="1）base镜像"><a href="#1）base镜像" class="headerlink" title="1）base镜像"></a>1）base镜像</h3><p>base 镜像简单来说就是<strong>不依赖其他任何镜像</strong>，完全从0开始建起，其他镜像都是建立在他的之上，可以比喻为大楼的地基，docker镜像的鼻祖。</p><p>base 镜像的特性：<br>（1）不依赖其他镜像，从 scratch 构建。<br>（2）其他镜像可以之为基础进行扩展。</p><p>所以，能称作 base 镜像的通常都是各种 Linux 发行版的 Docker 镜像，比如 Ubuntu, Debian, CentOS 等。</p><p>我们以 CentOS 为例查看 base 镜像包含哪些内容。<br><img src="/img/docker_images/docker1.png"></p><blockquote><p>提问：docker cnetos的镜像大小200多M，和平时的所用的发行版的大小（几G）相差很大，为什么？</p></blockquote><p>Linux 操作系统由内核空间和用户空间组成。</p><ol><li>内核空间是 kernel，Linux 刚启动时会加载 bootfs 文件系统，之后 bootfs 会被卸载掉。</li><li>用户空间的文件系统是 rootfs，包含我们熟悉的 &#x2F;dev, &#x2F;proc, &#x2F;bin 等目录。</li></ol><p><img src="/img/docker_images/docker2.png"></p><p><strong>对于 base 镜像来说，底层直接用 Host 的 kernel，自己只需要提供 rootfs 就行了</strong>。<br>而对于一个精简的 OS，rootfs 可以很小，只需要包括最基本的命令、工具和程序库就可以了。相比其他 Linux 发行版，CentOS 的 rootfs 已经算臃肿的了，alpine 还不到 10MB。</p><p>由此可见对于不同的Linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。</p><p>我们平时安装的 CentOS 除了 rootfs 还会选装很多软件、服务、图形桌面等，需要好几个 GB 就不足为奇了。</p><p>base 镜像提供的是最小安装的 Linux 发行版。</p><h3 id="2）bootfs"><a href="#2）bootfs" class="headerlink" title="2）bootfs"></a>2）bootfs</h3><p>bootfs(boot file system)：主要包含 bootloader 和 kernel。</p><ul><li>bootloader 主要是<strong>引导加载kernel</strong>，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs，这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含bootfs加载器和内核。当bootfs加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</li></ul><h3 id="3）rootfs"><a href="#3）rootfs" class="headerlink" title="3）rootfs"></a>3）rootfs</h3><p>rootfs(root file system)：在bootfs之上，包含类似于典型Linux系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc等标准目录文件。</p><ul><li>rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等。</li></ul><h1 id="三、分层原理"><a href="#三、分层原理" class="headerlink" title="三、分层原理"></a>三、分层原理</h1><p>参考文章：<a href="https://blog.51cto.com/wzlinux/2044797">https://blog.51cto.com/wzlinux/2044797</a></p><p>Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的。比如我们现在构建一个新的镜像，Dockerfile 如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Version: 0.0.1</span><br>FROM debian               1.新镜像不再是从 scratch 开始，而是直接在 Debian base 镜像上构建。<br>MAINTAINER wzlinux<br>RUN apt-get update &amp;&amp; apt-get install -y emacs        2.安装 emacs 编辑器。<br>RUN apt-get install -y apache2             3.安装 apache2。<br>CMD [&quot;/bin/bash&quot;]              4.容器启动时运行 bash。<br></code></pre></td></tr></table></figure><p>构建过程：</p><p><img src="/img/docker_images/docker3.png"></p><blockquote><p>可以看到，Docker镜像都起始于一个基础镜像层，新镜像是从 Base 镜像一层一层叠加生成的。<br>当进行修改或增加新的内容时，就会在当前镜像层上，创建新的镜像层。</p></blockquote><h2 id="1、思考：为什么Docker镜像采用分层的结构呢？"><a href="#1、思考：为什么Docker镜像采用分层的结构呢？" class="headerlink" title="1、思考：为什么Docker镜像采用分层的结构呢？"></a>1、思考：为什么Docker镜像采用分层的结构呢？</h2><ol><li>分层最大的优点是<strong>共享资源</strong>。</li><li>多个镜像都可以基于相同的 Base 镜像构建而来，那么宿主机只需在磁盘上保存一份base 镜像即可。</li><li>同时内存中也只需要加载一份 Base 镜像，就可以为所有容器服务，而且镜像的每一层都可以被共享。</li></ol><blockquote><p>如果多个容器共享一份基础镜像，当某个容器修改了基础镜像的内容，比如 &#x2F;etc 下的文件，这时其他容器的 &#x2F;etc 是否也会被修改？<br>答案是不会！<br>修改会被限制在单个容器内。<br>这就是我们接下来要说的容器 <strong>Copy-on-Write(COW)</strong> 特性。</p><ol><li>新数据会直接存放在最上面的容器层。</li><li>修改现有数据会先从镜像层将数据复制到容器层，修改后的数据直接保存在容器层中，镜像层保持不变。</li><li>如果多个层中有命名相同的文件，用户只能看到最上面那层中的文件。</li></ol></blockquote><h2 id="2、Copy-on-Write-COW"><a href="#2、Copy-on-Write-COW" class="headerlink" title="2、Copy-on-Write(COW)"></a>2、Copy-on-Write(COW)</h2><p>Copy-on-write 是一种共享和复制文件以实现最大效率的策略。当我们试图读取一个文件时，Docker 会从上到下一层层去找这个文件，找到的第一个就是我们的文件,所以下面层相同的文件就被“覆盖”了。<br>而修改就是当我们找到这个文件时，将它“复制”到读写层并修改，这样读写层的文件就是我们修改后的文件，并且“覆盖”了镜像中的文件了。这最大限度地减少了 I&#x2F;O 和每个后续层的大小。而删除就是创建了一个特殊的 whiteout 文件，这个 whiteout 文件覆盖的文件即表示删除了。</p><h2 id="3、理解"><a href="#3、理解" class="headerlink" title="3、理解"></a>3、理解</h2><p>这是一个三层的镜像分层结构图，在外部看整个镜像只有6个文件，app2.0 是 app1.0的更新版。</p><p><img src="/img/docker_images/docker4.png"></p><p> 在这种情况下，上层镜像层中的文件会覆盖底层镜像层的文件。这样就使得文件的更新版本作为新镜像层添加到镜像中。</p><blockquote><p>Docker 通过存储引擎(新版本采用快照机制)的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。</p><ul><li>存储引擎的选择文档：<a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/">https://docs.docker.com/storage/storagedriver/select-storage-driver/</a></li></ul></blockquote><p> Linux 上可用存储引擎有 AUFS、Overlay2、Device Mapper、Btrfs 以及 ZFS。顾名思义，每种存储引擎都基于 Linux 中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。</p><p>Docker 在 Windows 上仅支持 Windowsfilter 一种存储引擎，该引擎基于 NTFS 文件系统之上实现了分层和COW。</p><p><img src="/img/docker_images/docker5.png"></p><h2 id="4、特点"><a href="#4、特点" class="headerlink" title="4、特点"></a>4、特点</h2><p>Docker 镜像都是<strong>只读</strong>的，当你创建一个新的容器时，你会在基础层之上添加一个新的可写层，该层通常都称为 <strong>容器层</strong>。</p><p>对正在运行的容器所做的所有更改，例如写入新文件、修改现有文件和删除文件，都被写入这个可写的容器层。</p><p>下图显示了基于ubuntu:15.04图像的容器。<br><img src="/img/docker_images/docker6.png"><br>存储引擎处理有关这些层相互交互方式的详细信息。有不同的存储引擎可用，它们在不同的情况下各有优缺点。</p><h1 id="四、Commit镜像"><a href="#四、Commit镜像" class="headerlink" title="四、Commit镜像"></a>四、Commit镜像</h1><h2 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h2><p>将容器提交后，创建为一个新的镜像，命令与git原理类似。</p><h2 id="2、格式："><a href="#2、格式：" class="headerlink" title="2、格式："></a>2、格式：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">docker commit [OPTIONS] 容器id [目标镜像名[:TAG]]<br></code></pre></td></tr></table></figure><h2 id="3、可选项："><a href="#3、可选项：" class="headerlink" title="3、可选项："></a>3、可选项：</h2><table><thead><tr><th>名称，简写</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td>–author,-a</td><td></td><td>作者</td></tr><tr><td>–change,-c</td><td></td><td>将 Dockerfile 指令应用于创建的镜像</td></tr><tr><td>–message,-m</td><td></td><td>提交的描述消息</td></tr><tr><td>–pause,-p</td><td>true</td><td>提交期间暂停容器</td></tr></tbody></table><h2 id="4、说明："><a href="#4、说明：" class="headerlink" title="4、说明："></a>4、说明：</h2><p>将容器的文件更改或设置后创建为新镜像。这允许您通过运行交互式shell调试容器，或者将工作数据集导出到另一个服务器。一般来说，<strong>最好使用Dockerfiles以文档化和可维护的方式来管理映像。</strong></p><p>提交操作将不包括容器内挂载的卷中包含的任何数据。</p><p>默认情况下，正在提交的容器及其进程将在映像提交时暂停。这减少了在创建提交过程中遇到数据损坏的可能性。如果不希望出现这种行为，请将 –pause 选项设置为false。</p><p>–change选项将对所创建的映像应用Dockerfile指令。<br>支持的Dockerfile指令:CMD | ENTRYPOINT | ENV | EXPOSE | LABEL | ONBUILD | USER | VOLUME | WORKDIR</p><h2 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h2><h3 id="1）提交一个容器"><a href="#1）提交一个容器" class="headerlink" title="1）提交一个容器"></a>1）提交一个容器</h3><p>docker ps 找到一个新的容器，用commit命令提交一个容器，新增了一个命名为commit&#x2F;test的镜像 tag为test1.0，用docker images查看本地镜像是否成功提交了。<br><img src="/img/docker_images/docker7.png"></p><h3 id="2）提交一个新配置的容器"><a href="#2）提交一个新配置的容器" class="headerlink" title="2）提交一个新配置的容器"></a>2）提交一个新配置的容器</h3><p>用docker inspect命令查看容器的环境变量<br><img src="/img/docker_images/docker8.png"></p><p>提交一个新配置的容器，新增了一个命名为commit&#x2F;test的镜像 tag为test2.0，跟上一个例子区分</p><p><img src="/img/docker_images/docker9.png"></p><h3 id="3）实战测试"><a href="#3）实战测试" class="headerlink" title="3）实战测试"></a>3）实战测试</h3><ol><li>拉取并启动一个tomcat:9.0的镜像。</li></ol><p><img src="/img/docker_images/docker10.png"></p><ol start="2"><li>我们用docker exec命令进入tomcat 容器中，官方默认的tomcat镜像时没有 webapps 应用，需要将webapps.dist目录下的基本文件拷贝到webapps目录下。</li></ol><p><img src="/img/docker_images/docker11.png"></p><ol start="3"><li>验证tomcat，访问<a href="http://localhost:8088/">http://localhost:8088/</a></li></ol><p><img src="/img/docker_images/docker12.png"></p><ol start="4"><li>将操作过后的tomcat容器提交为一个镜像，下次用的时候直接运行这个修改后的tomcat镜像即可。</li></ol><p><img src="/img/docker_images/docker13.png"></p>]]></content>
    
    
    <categories>
      
      <category>Docker容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>Docker</tag>
      
      <tag>go</tag>
      
      <tag>容器</tag>
      
      <tag>linux</tag>
      
      <tag>云原生</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker底层原理和常用命令</title>
    <link href="/2022/08/26/docker-CommonComands/"/>
    <url>/2022/08/26/docker-CommonComands/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言 :)"></a>前言 :)</h1><blockquote><p>友情提示<br>本文学习需要了解一些Linux简单命令</p></blockquote><h1 id="一、Docker底层原理"><a href="#一、Docker底层原理" class="headerlink" title="一、Docker底层原理"></a>一、Docker底层原理</h1><h2 id="1、Docker是怎么工作的？"><a href="#1、Docker是怎么工作的？" class="headerlink" title="1、Docker是怎么工作的？"></a>1、Docker是怎么工作的？</h2><p>Docker 使用客户端-服务器 (C&#x2F;S) 架构模式，使用远程API来管理和创建Docker容器。Docker的守护进程运行在宿主机上，通过Socket从客户端访问！DockerServer 接收到 Docker-Client 的指令，就会执行这个命令。</p><ul><li>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</li><li>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</li></ul><blockquote><p>容器的实质是进程，与宿主机上的其他进程是共用一个内核，但与直接在宿主机执行的进程不同，容器进程运行在属于自己的独立的命名空间。命名空间隔离了进程间的资源，使得 a,b 进程可以看到 S 资源，而 c 进程看不到。</p></blockquote><p><img src="/img/docker_CommonComands/docker1.png"></p><h2 id="2、Docker为什么比VM快？"><a href="#2、Docker为什么比VM快？" class="headerlink" title="2、Docker为什么比VM快？"></a>2、Docker为什么比VM快？</h2><ol><li><p>Docker有着比虚拟机更少的抽象层。<br> 1）虚拟机是<strong>硬件层抽象</strong>，虚拟硬件和操作系统。<br> 2）Docker是<strong>应用层抽象</strong>，只虚拟化操作系统 。</p></li><li><p>Docker是基于宿主机的内核，VM是基于虚拟机虚拟化后的内核。<br> 1）当新建一个<strong>容器</strong>时，docker不需要像虚拟机需要加载一个<strong>操作系统内核</strong>。然而避免引寻、加载操作系统内核是比较费时费资源的过程。<br> 2）当新建一个<strong>虚拟机</strong>时，虚拟机软件需要加载Guest OS，返回一个新建过程至少是分钟级别的。<br> 3）docker由于<strong>直接利用宿主机的操作系统</strong>，则省略了返回过程，因此新建一个docker容器只需要几秒钟。</p></li><li><p>Docker相比虚拟机更加轻量级和便携。<br><img src="/img/docker_CommonComands/docker2.png"></p></li></ol><table><thead><tr><th>特性</th><th>Docker容器</th><th>虚拟机(VM)</th></tr></thead><tbody><tr><td>操作系统</td><td>与宿主机共享OS</td><td>宿主机OS上运行虚拟机OS</td></tr><tr><td>存储大小</td><td>镜像小，便于存储和传输</td><td>镜像庞大(vmdk\vdi)等</td></tr><tr><td>运行性能</td><td>几乎无额外性能损失</td><td>操作系统额外的CPU、内存消耗</td></tr><tr><td>移植性</td><td>轻便、灵活，适应于Linux</td><td>笨重，与虚拟化技术耦合度高</td></tr><tr><td>硬件亲和性</td><td>面向软件开发者</td><td>面向硬件运维者</td></tr><tr><td>部署速度</td><td>快速，秒级</td><td>较慢，10s以上</td></tr></tbody></table><h2 id="3、Docker-所使用的底层技术"><a href="#3、Docker-所使用的底层技术" class="headerlink" title="3、Docker 所使用的底层技术"></a>3、Docker 所使用的底层技术</h2><p>学习一下大佬的文章：<a href="https://blog.csdn.net/Tencent_TEG/article/details/109505143?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166122025416782391822038%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166122025416782391822038&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-4-109505143-null-null.142%5Ev42%5Epc_rank_34,185%5Ev2%5Econtrol&utm_term=docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86&spm=1018.2226.3001.4187">https://blog.csdn.net/Tencent_TEG&#x2F;article&#x2F;details&#x2F;109505143?ops_request_misc&#x3D;%257B%2522request%255Fid%2522%253A%2522166122025416782391822038%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id&#x3D;166122025416782391822038&amp;biz_id&#x3D;0&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>first_rank_ecpm_v1~pc_rank_34-4-109505143-null-null.142^v42^pc_rank_34,185^v2^control&amp;utm_term&#x3D;docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86&amp;spm&#x3D;1018.2226.3001.4187</a></p><h1 id="二、Docker常用命令"><a href="#二、Docker常用命令" class="headerlink" title="二、Docker常用命令"></a>二、Docker常用命令</h1><p>帮助文档地址：<a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p><h2 id="1、基础命令"><a href="#1、基础命令" class="headerlink" title="1、基础命令"></a>1、基础命令</h2><h3 id="1）-docker-命令-–help"><a href="#1）-docker-命令-–help" class="headerlink" title="1） docker 命令 –help"></a>1） docker 命令 –help</h3><ul><li>作用：查看命令的帮助文档</li><li>格式：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker 命令 <span class="hljs-literal">--help</span><br></code></pre></td></tr></table></figure></li><li>例子：</li></ul><p><img src="/img/docker_CommonComands/docker3.png"></p><h3 id="2）docker-version"><a href="#2）docker-version" class="headerlink" title="2）docker version"></a>2）docker version</h3><ul><li>作用：显示Docker的版本信息。</li><li>格式：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker version [<span class="hljs-type">OPTIONS</span>]<br></code></pre></td></tr></table></figure></li><li>可选项：</li></ul><table><thead><tr><th>名称，简写</th><th>默认</th><th align="left">解释</th></tr></thead><tbody><tr><td>–format,-f</td><td></td><td align="left">使用给定的 Go 模板格式化输出</td></tr></tbody></table><ul><li>例子：</li></ul><p><img src="/img/docker_CommonComands/docker4.png"></p><h3 id="3）docker-info"><a href="#3）docker-info" class="headerlink" title="3）docker info"></a>3）docker info</h3><ul><li>作用：显示docker的系统信息，显示的信息包括内核版本、容器数量和映像。</li><li>格式：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker info [<span class="hljs-type">OPTIONS</span>]<br></code></pre></td></tr></table></figure></li><li>可选项：</li></ul><table><thead><tr><th>名称，简写</th><th>默认</th><th align="left">解释</th></tr></thead><tbody><tr><td>–format,-f</td><td></td><td align="left">使用给定的 Go 模板格式化输出</td></tr></tbody></table><ul><li>例子：</li></ul><p><img src="/img/docker_CommonComands/docker5.png"></p><h2 id="2、镜像命令"><a href="#2、镜像命令" class="headerlink" title="2、镜像命令"></a>2、镜像命令</h2><h3 id="1）docker-images"><a href="#1）docker-images" class="headerlink" title="1）docker images"></a>1）docker images</h3><ul><li>作用：显示所有镜像、它们的存储库和标签以及它们的大小。</li><li>格式：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker images [<span class="hljs-type">OPTIONS</span>] [<span class="hljs-type">REPOSITORY</span>[:<span class="hljs-type">TAG</span>]]<br></code></pre></td></tr></table></figure></li><li>可选项：</li></ul><table><thead><tr><th>名称，简写</th><th>默认</th><th align="left">解释</th></tr></thead><tbody><tr><td>–all,-a</td><td></td><td align="left">显示所有镜像（默认隐藏中间镜像）</td></tr><tr><td>–filter,-f</td><td></td><td align="left">根据提供的条件过滤输出</td></tr><tr><td>–format</td><td></td><td align="left">使用 Go 模板格式化打印镜像</td></tr><tr><td>–quiet,-q</td><td></td><td align="left">仅显示图像 ID</td></tr></tbody></table><ul><li><strong>[REPOSITORY[:TAG]]参数</strong><blockquote><p>该docker images命令采用一个可选[REPOSITORY[:TAG]]参数，将列表限制为与参数匹配的镜像。如果您指定 REPOSITORY但 no TAG，该docker images命令会列出给定存储库中的所有镜像。</p></blockquote></li></ul><p><img src="/img/docker_CommonComands/docker6.png"></p><ul><li>例子：</li></ul><p><img src="/img/docker_CommonComands/docker7.png"></p><table><thead><tr><th>名词</th><th>解释</th></tr></thead><tbody><tr><td>REPOSITORY</td><td>镜像的仓库源</td></tr><tr><td>TAG</td><td>镜像的标签</td></tr><tr><td>IMAGE ID</td><td>镜像的id</td></tr><tr><td>CREATED</td><td>镜像的创建时间</td></tr><tr><td>SIZE</td><td>镜像的大小</td></tr></tbody></table><h3 id="2）docker-search"><a href="#2）docker-search" class="headerlink" title="2）docker search"></a>2）docker search</h3><ul><li>作用：在Docker Hub上搜索镜像</li><li>格式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker search [<span class="hljs-type">OPTIONS</span>] 镜像名<br></code></pre></td></tr></table></figure><ul><li>可选项：</li></ul><table><thead><tr><th>名称，简写</th><th>默认</th><th align="left">解释</th></tr></thead><tbody><tr><td>–filter,-f</td><td></td><td align="left">根据提供的条件过滤输出</td></tr><tr><td>–format</td><td></td><td align="left">使用 Go 模板格式化打印搜索</td></tr><tr><td>–limit</td><td>25</td><td align="left">最大搜索结果数</td></tr></tbody></table><ul><li>例子：</li></ul><p><img src="/img/docker_CommonComands/docker8.png"></p><blockquote><p>–filter filter   通过搜索来过滤，例如–filter&#x3D;STARS&#x3D;300表示搜索出来的镜像STARS大于300的</p></blockquote><p><img src="/img/docker_CommonComands/docker9.png"></p><h3 id="3）docker-pull"><a href="#3）docker-pull" class="headerlink" title="3）docker pull"></a>3）docker pull</h3><ul><li>作用：从Docker Hub上拉取镜像， 如果没有提供标签，Docker 引擎将使用该:latest标签作为默认值。此命令提取debian:latest镜像。</li><li>格式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker pull [<span class="hljs-type">OPTIONS</span>] 镜像名[:<span class="hljs-type">tag</span>|@<span class="hljs-type">DIGEST</span>]<br></code></pre></td></tr></table></figure><ul><li>可选项：</li></ul><table><thead><tr><th>名称，简写</th><th>默认</th><th align="left">解释</th></tr></thead><tbody><tr><td>–all-tags,-a</td><td></td><td align="left">下载存储库中的所有标记镜像</td></tr><tr><td>–disable-content-trust</td><td>true</td><td align="left">跳过镜像验证</td></tr><tr><td>–platform</td><td></td><td align="left">如果服务器支持多平台，则设置平台</td></tr><tr><td>–quiet,-q</td><td></td><td align="left">抑制详细输出</td></tr></tbody></table><ul><li>例子：</li></ul><p><img src="/img/docker_CommonComands/docker10.png"><br><img src="/img/docker_CommonComands/docker11.png"></p><blockquote><p>注意：Docker 镜像可以由多个层组成。图层可以被镜像重用，例如，debian:jessie图像与debian:latest.拉取debian:jessie镜像只会拉取其元数据，而不是其层，因为所有层都已在本地存在。</p></blockquote><p><img src="/img/docker_CommonComands/docker12.png"></p><blockquote><p>Docker 使用内容可寻址的镜像存储，镜像 ID 是涵盖镜像配置和层的 SHA256 摘要。在上面的示例中， debian:jessie并且debian:latest具有相同的图像 ID，因为它们实际上是用不同名称标记的相同图像。因为它们是同一个镜像，所以它们的层只存储一次，不会消耗额外的磁盘空间。</p></blockquote><h3 id="4）docker-rmi"><a href="#4）docker-rmi" class="headerlink" title="4）docker rmi"></a>4）docker rmi</h3><ul><li>作用：删除一个或多个镜像</li><li>格式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker rmi [<span class="hljs-type">OPTIONS</span>] 镜像id [镜像<span class="hljs-type">id...</span>]<br></code></pre></td></tr></table></figure><ul><li>可选项：</li></ul><table><thead><tr><th>名称，简写</th><th>默认</th><th align="left">解释</th></tr></thead><tbody><tr><td>–force,-f</td><td></td><td align="left">强制删除镜像</td></tr></tbody></table><ul><li>例子：</li></ul><p><img src="/img/docker_CommonComands/docker13.png"><br><img src="/img/docker_CommonComands/docker14.png"><br><strong>删除所有镜像:</strong> </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker rmi <span class="hljs-operator">-f</span> <span class="hljs-variable">$</span>(docker images <span class="hljs-literal">-aq</span>)<br></code></pre></td></tr></table></figure><h2 id="3、容器命令"><a href="#3、容器命令" class="headerlink" title="3、容器命令"></a>3、容器命令</h2><blockquote><p>注意：必须存在镜像才能运行容器</p></blockquote><p>我们这里使用centos作为例子来理解容器命令，需要先拉取centos的镜像</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker pull centos<br></code></pre></td></tr></table></figure><h3 id="1）docker-run"><a href="#1）docker-run" class="headerlink" title="1）docker run"></a>1）docker run</h3><ul><li><p>作用：创建一个新的容器并运行一个镜像</p></li><li><p>Docker的流程图：<br><img src="/img/docker_CommonComands/docker15.png"></p></li><li><p>格式：</p></li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker run [<span class="hljs-type">OPTIONS</span>] 镜像id [<span class="hljs-type">COMMAND</span>] [<span class="hljs-type">ARG...</span>]<br></code></pre></td></tr></table></figure><ul><li>可选项</li></ul><table><thead><tr><th>名称，简写</th><th>默认</th><th align="left">参数说明</th></tr></thead><tbody><tr><td>–name</td><td></td><td align="left">为容器分配名称，用来区分容器</td></tr><tr><td>–detach,-d</td><td></td><td align="left">在后台运行容器并打印容器 ID</td></tr><tr><td>-it</td><td></td><td align="left">使用交互式运行，进入容器查看内容</td></tr><tr><td>-p</td><td></td><td align="left">-p xxxx:yyyy：宿主机上xxxx端口对应容器中yyyy端口，在外部访问时用的是宿主机上的端口</td></tr><tr><td>-P(大写)</td><td></td><td align="left">随机指定端口</td></tr></tbody></table><ul><li>例子：</li></ul><p>启动并进入容器</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker run <span class="hljs-literal">-it</span> centos bin/bash<br></code></pre></td></tr></table></figure><p><img src="/img/docker_CommonComands/docker16.png"></p><blockquote><p>注意：<br>如果出现这个错误，请用管理员权限执行即可。<br><img src="/img/docker_CommonComands/docker17.png"></p></blockquote><h3 id="2）docker-ps"><a href="#2）docker-ps" class="headerlink" title="2）docker ps"></a>2）docker ps</h3><ul><li>作用：查看所有的容器</li><li>格式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">ps</span> [<span class="hljs-type">OPTIONS</span>]<br></code></pre></td></tr></table></figure><ul><li>可选项：</li></ul><table><thead><tr><th>名称，简写</th><th>默认</th><th align="left">参数说明</th></tr></thead><tbody><tr><td>–all,-a</td><td></td><td align="left">显示所有容器（默认显示刚刚运行）</td></tr><tr><td>–last,-n</td><td>-1</td><td align="left">显示 n 个最后创建的容器（包括所有状态）</td></tr><tr><td>–quiet,-q</td><td></td><td align="left">仅显示容器 ID</td></tr></tbody></table><ul><li>例子：</li></ul><p><img src="/img/docker_CommonComands/docker18.png"></p><h3 id="3）exit-Ctrl-P-Q"><a href="#3）exit-Ctrl-P-Q" class="headerlink" title="3）exit | Ctrl + P + Q"></a>3）exit | Ctrl + P + Q</h3><ul><li>作用：退出容器</li><li>格式：</li></ul><ol><li>exit 直接停止容器并退出<br><img src="/img/docker_CommonComands/docker19.png"></li><li>Ctrl + P + Q 容器不停止退出<br><img src="/img/docker_CommonComands/docker20.png"></li></ol><h3 id="4）docker-rm"><a href="#4）docker-rm" class="headerlink" title="4）docker rm"></a>4）docker rm</h3><ul><li>作用：删除一个或多个容器，不能删除正在运行的容器，除非用-f强制删除</li><li>格式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">rm</span> [<span class="hljs-type">OPTIONS</span>] 容器id [容器<span class="hljs-type">id...</span>] <br></code></pre></td></tr></table></figure><ul><li>可选项：</li></ul><table><thead><tr><th>名称，简写</th><th>默认</th><th align="left">参数说明</th></tr></thead><tbody><tr><td>–force,-f</td><td></td><td align="left">强制删除正在运行的容器（使用 SIGKILL）</td></tr><tr><td>–link,-l</td><td></td><td align="left">删除指定链接</td></tr><tr><td>–volumes,-v</td><td></td><td align="left">删除与容器关联的匿名卷</td></tr></tbody></table><ul><li>例子：</li></ul><p><img src="/img/docker_CommonComands/docker21.png"></p><p><strong>删除所有容器：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> <span class="hljs-variable">$</span>(docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-aq</span>)<br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> <span class="hljs-literal">-q</span>|xargs docker <span class="hljs-built_in">rm</span><br></code></pre></td></tr></table></figure><p><strong>强制删除容器：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> 容器id<br></code></pre></td></tr></table></figure><p><img src="/img/docker_CommonComands/docker22.png"></p><h3 id="5）docker-start-restart-stop-kill"><a href="#5）docker-start-restart-stop-kill" class="headerlink" title="5）docker start | restart | stop | kill"></a>5）docker start | restart | stop | kill</h3><ul><li>作用：启动 | 重启 | 停止 | 杀死 容器的操作</li><li>格式：</li></ul><ol><li>docker start 启动容器<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">start</span> 容器id<br></code></pre></td></tr></table></figure></li><li>docker restart 重启容器<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker restart 容器id<br></code></pre></td></tr></table></figure></li><li>docker stop 停止容器<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker stop 容器id<br></code></pre></td></tr></table></figure></li><li>docker kill 杀死容器<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">kill</span> 容器id<br></code></pre></td></tr></table></figure></li></ol><h2 id="4、常用的其他命令"><a href="#4、常用的其他命令" class="headerlink" title="4、常用的其他命令"></a>4、常用的其他命令</h2><h3 id="1）-docker-run-d"><a href="#1）-docker-run-d" class="headerlink" title="1） docker run -d"></a>1） docker run -d</h3><ul><li>作用：后台启动容器</li><li>格式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker run <span class="hljs-literal">-d</span> 镜像名<br></code></pre></td></tr></table></figure><ul><li>例子：</li></ul><p><img src="/img/docker_CommonComands/docker23.png"></p><blockquote><p>注意：docker 容器后台运行的时候，必须要有一个前台进程运行，如果docker发现没有应用，就会自动停止容器。</p></blockquote><h3 id="2）docker-logs"><a href="#2）docker-logs" class="headerlink" title="2）docker logs"></a>2）docker logs</h3><ul><li>作用：获取容器的日志</li><li>格式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker logs [<span class="hljs-type">OPTIONS</span>] CONTAINER<br></code></pre></td></tr></table></figure><ul><li>可选项：</li></ul><table><thead><tr><th>名称，简写</th><th>默认</th><th align="left">解释</th></tr></thead><tbody><tr><td>–details</td><td></td><td align="left">显示提供给日志的额外详细信息</td></tr><tr><td>–follow,-f</td><td></td><td align="left">关注日志输出</td></tr><tr><td>–since</td><td></td><td align="left">显示自时间戳（例如 2013-01-02T13:23:37Z）或相对时间（例如 42m 42 分钟）以来的日志</td></tr><tr><td>–tail,-n</td><td>all</td><td align="left">从日志末尾显示的行数</td></tr><tr><td>–timestamps,-t</td><td></td><td align="left">显示时间戳</td></tr><tr><td>–until</td><td></td><td align="left">在时间戳（例如 2022-08-24T17:57:37Z）或相对时间（e.g. 42m for 42 minutes）之前显示日志</td></tr></tbody></table><ul><li>例子：</li></ul><p>自己先编写一段shell脚本，以便容器可以有进程运行，不会自动停止：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker run <span class="hljs-literal">-d</span> centos /bin/bash <span class="hljs-literal">-c</span> <span class="hljs-string">&quot;while true;do echo linzy;sleep 1;done&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>shell脚本：一直循环，每秒输出一条日志信息linzy</p></blockquote><p><img src="/img/docker_CommonComands/docker24.png"></p><h3 id="3）docker-top"><a href="#3）docker-top" class="headerlink" title="3）docker top"></a>3）docker top</h3><ul><li>作用：显示容器的运行进程，查看容器中的进程信息。</li><li>格式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker top 容器id<br></code></pre></td></tr></table></figure><ul><li>例子：</li></ul><p><img src="/img/docker_CommonComands/docker25.png"></p><h3 id="4）docker-inspect"><a href="#4）docker-inspect" class="headerlink" title="4）docker inspect"></a>4）docker inspect</h3><ul><li>作用：查看镜像或容器的元数据</li><li>格式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker inspect [<span class="hljs-type">OPTIONS</span>] 镜像id|镜像名 [镜像<span class="hljs-type">id</span>|镜像名<span class="hljs-type">...</span>]<br></code></pre></td></tr></table></figure><ul><li>可选项：</li></ul><table><thead><tr><th>名称，简写</th><th>默认</th><th align="left">解释</th></tr></thead><tbody><tr><td>–format,-f</td><td></td><td align="left">使用给定的 Go 模板格式化输出</td></tr><tr><td>–size,-s</td><td></td><td align="left">如果类型是容器，则显示总文件大小</td></tr><tr><td>–type</td><td></td><td align="left">返回指定类型的 JSON</td></tr></tbody></table><ul><li>例子：</li></ul><p><img src="/img/docker_CommonComands/docker26.png"><br><img src="/img/docker_CommonComands/docker27.png"></p><h3 id="5）docker-exec-it"><a href="#5）docker-exec-it" class="headerlink" title="5）docker exec -it"></a>5）docker exec -it</h3><ul><li>作用：进入正在运行的容器中，打开新的终端并运行新的命令</li><li>格式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker exec <span class="hljs-literal">-it</span> 容器id baseShell<br></code></pre></td></tr></table></figure><ul><li>例子：</li></ul><p><img src="/img/docker_CommonComands/docker28.png"></p><h3 id="6）docker-attach"><a href="#6）docker-attach" class="headerlink" title="6）docker attach"></a>6）docker attach</h3><ul><li>作用： 进入正在运行的容器中</li><li>格式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker attach 容器id<br></code></pre></td></tr></table></figure><ul><li>例子：</li></ul><p><img src="/img/docker_CommonComands/docker29.png"></p><h1 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h1><p><img src="/img/docker_CommonComands/docker30.png"></p><table><thead><tr><th>命令</th><th align="left">作用</th></tr></thead><tbody><tr><td>attach</td><td align="left">当前 shell 下 attach 连接指定运行镜像</td></tr><tr><td>build</td><td align="left">通过 Dockerfile 定制镜像</td></tr><tr><td>commit</td><td align="left">提交当前容器为新的镜像</td></tr><tr><td>cp</td><td align="left">从容器中拷贝指定文件或者目录到宿主机中</td></tr><tr><td>create</td><td align="left">创建一个新的容器，同 run 但不启动容器</td></tr><tr><td>diff</td><td align="left">查看 docker 容器变化</td></tr><tr><td>events</td><td align="left">从 docker 服务获取容器实时事件</td></tr><tr><td>exec</td><td align="left">在已存在的容器上运行命令</td></tr><tr><td>export</td><td align="left">导出容器的内容流作为一个 tar 归档文件[对应 import]</td></tr><tr><td>history</td><td align="left">展示一个镜像形成历史</td></tr><tr><td>images</td><td align="left">列出系统当前的镜像</td></tr><tr><td>import</td><td align="left">从 tar 包中的内容创建一个新的文件系统映像[对应 export]</td></tr><tr><td>info</td><td align="left">显示系统相关信息</td></tr><tr><td>inspect</td><td align="left">查看容器或镜像的详细信息</td></tr><tr><td>kill</td><td align="left">杀死指定 docker 容器</td></tr><tr><td>load</td><td align="left">从一个 tar 包中加载一个镜像[对应 save]</td></tr><tr><td>login</td><td align="left">注册或登录一个docker hub</td></tr><tr><td>logout</td><td align="left">从当前 docker history 退出</td></tr><tr><td>logs</td><td align="left">输出当前容器日志信息</td></tr><tr><td>port</td><td align="left">查看映射端口对应的容器内部源端口</td></tr><tr><td>pause</td><td align="left">暂停容器</td></tr><tr><td>ps</td><td align="left">列出容器列表</td></tr><tr><td>pull</td><td align="left">从docker hub拉取镜像</td></tr><tr><td>push</td><td align="left">推送指定镜像或库镜像到docker hub</td></tr><tr><td>restart</td><td align="left">重启运行容器</td></tr><tr><td>rm</td><td align="left">移除一个或多个容器</td></tr><tr><td>rmi</td><td align="left">移除一个或多个镜像[无容器使用该镜像才能删除，否则要删除相关容器或者 -f 强制删除]</td></tr><tr><td>run</td><td align="left">创建一个新的容器并运行一个命令</td></tr><tr><td>save</td><td align="left">保存一个镜像为 tar 包[对应 load]</td></tr><tr><td>search</td><td align="left">在docker hub 中搜索镜像</td></tr><tr><td>start</td><td align="left">启动容器</td></tr><tr><td>stop</td><td align="left">停止容器</td></tr><tr><td>tag</td><td align="left">给源中镜像打标签</td></tr><tr><td>top</td><td align="left">查看容器中运行的进程信息</td></tr><tr><td>unpause</td><td align="left">取消暂停容器</td></tr><tr><td>version</td><td align="left">查看容器版本号</td></tr><tr><td>wait</td><td align="left">截取容器停止时的退出状态值</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Docker容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>Docker</tag>
      
      <tag>go</tag>
      
      <tag>容器</tag>
      
      <tag>linux</tag>
      
      <tag>云原生</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker部署Golang项目和Mysql镜像</title>
    <link href="/2022/08/15/docker-go-mysql-deployment/"/>
    <url>/2022/08/15/docker-go-mysql-deployment/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><strong>友情提示</strong><br> 本文学习需要了解一些Linux简单命令和Docker的一些命令<br> 使用的项目我已经上传到github：<a href="https://github.com/Gopherlinzy/gin-gorm-example">https://github.com/Gopherlinzy/gin-gorm-example</a></p></blockquote><h1 id="一、获取一个可执行的项目"><a href="#一、获取一个可执行的项目" class="headerlink" title="一、获取一个可执行的项目"></a>一、获取一个可执行的项目</h1><p>我自己写了一个简单的gin-gorm项目，github下载地址：<a href="https://github.com/Gopherlinzy/gin-gorm-example">https://github.com/Gopherlinzy/gin-gorm-example</a><br><img src="/img/docker_go_mysql_deployment/docker1.png"></p><h2 id="1、拉取项目"><a href="#1、拉取项目" class="headerlink" title="1、拉取项目"></a>1、拉取项目</h2><p>打开Windows终端，输入命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">go get github.com/Gopherlinzy/<span class="hljs-built_in">gin</span><span class="hljs-literal">-gorm-example</span><br></code></pre></td></tr></table></figure><h2 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h2><p>只需要拉取下来，修改 conf&#x2F;app.ini 配置文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">[<span class="hljs-type">database</span>]<br><span class="hljs-built_in">Type</span> = mysql<br>User = 数据库名称<br>Password = 数据库密码<br>//数据库的IP地址<br>Host = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">3306</span><br>//数据库名称 <br>Name = blog<br>TablePrefix = blog_<br></code></pre></td></tr></table></figure><h1 id="二、编写Dockerfile文件"><a href="#二、编写Dockerfile文件" class="headerlink" title="二、编写Dockerfile文件"></a>二、编写Dockerfile文件</h1><p><strong>Dockerfile文件就是单纯的文件并没有文件后缀</strong>，我们来了解一下，Dockerfile的作用。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">FROM golang:latest<br><br>ENV GOPROXY https://goproxy.cn,direct<br>WORKDIR <span class="hljs-variable">$GOPATH</span>/github.com/Gopherlinzy/go<span class="hljs-literal">-gorm-example</span><br><span class="hljs-built_in">COPY</span> . <span class="hljs-variable">$GOPATH</span>/github.com/Gopherlinzy/go<span class="hljs-literal">-gorm-example</span><br>RUN go build .<br><br>EXPOSE <span class="hljs-number">8080</span><br>ENTRYPOINT [<span class="hljs-string">&quot;./gin-gorm-example&quot;</span>]<br></code></pre></td></tr></table></figure><h2 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h2><ol><li>golang:latest 镜像为基础镜像，将工作目录设置为 <strong>$GOPATH&#x2F;src&#x2F;gin-gorm-example</strong> ，并将当前上下文目录的内容复制到 $GOPATH&#x2F;src&#x2F;gin-gorm-example 中。</li><li>在进行 go build 编译完毕后，将容器启动程序设置为 <strong>.&#x2F;gin-gorm-example</strong>，也就是我们所编译的可执行文件。</li><li>注意：<strong>gin-gorm-example</strong> 在 docker 容器里编译，并没有在宿主机现场编译</li></ol><h2 id="2、说明"><a href="#2、说明" class="headerlink" title="2、说明"></a>2、说明</h2><p>Dockerfile 文件是用于定义 Docker 镜像生成流程的配置文件，文件内容是一条条指令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建；这些指令应用于基础镜像并最终创建一个新的镜像</p><h3 id="1）FROM"><a href="#1）FROM" class="headerlink" title="1）FROM"></a>1）FROM</h3><p>指定基础镜像（必须有的指令，并且必须是第一条指令）</p><h3 id="2）WORKDIR"><a href="#2）WORKDIR" class="headerlink" title="2）WORKDIR"></a>2）WORKDIR</h3><p>使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如果目录不存在，WORKDIR 会帮你建立目录</p><p>格式： WORKDIR &lt;工作目录路径&gt;</p><h3 id="3）COPY"><a href="#3）COPY" class="headerlink" title="3）COPY"></a>3）COPY</h3><p><strong>COPY</strong> 指令将从构建上下文目录中 &lt;源路径&gt; 的文件&#x2F;目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">COPY</span> &lt;源路径&gt;... &lt;目标路径&gt;<br><span class="hljs-built_in">COPY</span> [<span class="hljs-string">&quot;&lt;源路径1&gt;&quot;</span>,<span class="hljs-type">...</span> <span class="hljs-string">&quot;&lt;目标路径&gt;&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="4）RUN"><a href="#4）RUN" class="headerlink" title="4）RUN"></a>4）RUN</h3><p>用于执行命令行命令</p><p>格式：<strong>RUN</strong> &lt;命令&gt;</p><h3 id="5）EXPOSE"><a href="#5）EXPOSE" class="headerlink" title="5）EXPOSE"></a>5）EXPOSE</h3><p><strong>EXPOSE</strong> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务</p><p>格式： <strong>EXPOSE</strong> &lt;端口 1&gt; [&lt;端口 2&gt;…]</p><p>在 Dockerfile 中写入这样的声明有两个好处</p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射</li><li>运行时使用随机端口映射时，也就是 <strong>docker run -P</strong> 时，会自动随机映射 <strong>EXPOSE</strong> 的端口</li></ul><h3 id="6）ENTRYPOINT"><a href="#6）ENTRYPOINT" class="headerlink" title="6）ENTRYPOINT"></a>6）ENTRYPOINT</h3><p><strong>ENTRYPOINT</strong> 指令是指定容器启动程序及参数</p><p>ENTRYPOINT 的格式和 RUN 指令格式一样，分为两种格式</p><ul><li>exec 格式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&lt;ENTRYPOINT&gt; <span class="hljs-string">&quot;&lt;CMD&gt;&quot;</span><br></code></pre></td></tr></table></figure><ul><li>shell 格式：</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ENTRYPOINT [ <span class="hljs-string">&quot;curl&quot;</span>, <span class="hljs-string">&quot;-s&quot;</span>, <span class="hljs-string">&quot;http://ip.cn&quot;</span> ]<br></code></pre></td></tr></table></figure><h1 id="三、构建Docker镜像"><a href="#三、构建Docker镜像" class="headerlink" title="三、构建Docker镜像"></a>三、构建Docker镜像</h1><p>gin-gorm-example 的项目根目录下执行 <strong>docker build -t gin-gorm-docker .</strong><br>该命令作用是创建&#x2F;构建镜像，-t 指定名称为 gin-gorm-docker，**.** 构建内容为当前上下文目录<br><img src="/img/docker_go_mysql_deployment/docker2.png"></p><h1 id="四、验证镜像"><a href="#四、验证镜像" class="headerlink" title="四、验证镜像"></a>四、验证镜像</h1><p>查看所有的镜像，确定刚刚构建的 <strong>gin-gorm-docker</strong>  镜像是否存在<br><img src="/img/docker_go_mysql_deployment/docker3.png"></p><h1 id="五、创建并运行一个新容器"><a href="#五、创建并运行一个新容器" class="headerlink" title="五、创建并运行一个新容器"></a>五、创建并运行一个新容器</h1><p>执行命令 docker run -p 8080:8080 gin-gorm-docker<br><img src="/img/docker_go_mysql_deployment/docker4.png"></p><p>测试我们项目的API文档网址：<a href="http://localhost:8080/swagger/index.html">http://localhost:8080/swagger/index.html</a></p><p><img src="/img/docker_go_mysql_deployment/docker5.png"></p><p>运行成功了么？</p><p>我们再测试一下用户登录这块，我在用户表自动创建这块自动插入了一条用户信息用户：admin和密码:123456，用我们的postman测试一下，测试网址：<a href="http://localhost:8080/auth?username=admin&password=123456">http://localhost:8080/auth?username=admin&password=123456</a>。<br><img src="/img/docker_go_mysql_deployment/docker6.png"></p><p>我们仔细看看控制台的输出了一条错误<br><img src="/img/docker_go_mysql_deployment/docker7.png"></p><p>我们可以发现问题是在访问MySQL数据库的时候，连接数据库超时了！</p><p>这就是我们接下来要解决的问题</p><h1 id="六、MySQL"><a href="#六、MySQL" class="headerlink" title="六、MySQL"></a>六、MySQL</h1><h2 id="1、拉取镜像"><a href="#1、拉取镜像" class="headerlink" title="1、拉取镜像"></a>1、拉取镜像</h2><p>从 Docker 的公共仓库 Dockerhub 下载 MySQL 镜像（国内建议配个镜像），用pull指令拉取镜像，格式指令 docker pull 镜像名:版本号，不写版本号默认拉取最新版。</p><p>我们这里就用5.7版本的MySQL数据库就好了。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker pull mysql:<span class="hljs-number">5.7</span><br></code></pre></td></tr></table></figure><h2 id="2、创建并运行一个MySQL容器"><a href="#2、创建并运行一个MySQL容器" class="headerlink" title="2、创建并运行一个MySQL容器"></a>2、创建并运行一个MySQL容器</h2><p>用run指令创建并运行容器</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker run <span class="hljs-literal">--name</span> mysql <span class="hljs-literal">-p</span> <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> <span class="hljs-literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="hljs-number">123456</span> <span class="hljs-literal">-d</span> mysql<br></code></pre></td></tr></table></figure><blockquote><p>说明：<br>–name mysql：指定容器名称为mysql，方便查找和使用<br>-p xxxx:yyyy：宿主机上xxxx端口对应容器中yyyy端口，在外部访问时用的是宿主机上的端口<br>-e MYSQL_ROOT_PASSWORD&#x3D;123456：给root用户设置默认密码为123456<br>-d：容器后台运行<br>mysql：镜像名称</p></blockquote><h2 id="3、连接数据库"><a href="#3、连接数据库" class="headerlink" title="3、连接数据库"></a>3、连接数据库</h2><p>我用的是Navicat连接MySQL。<br><img src="/img/docker_go_mysql_deployment/docker8.png"></p><p>初始化的 Mysql 应该如图<br><img src="/img/docker_go_mysql_deployment/docker9.png"><br>创建我们的blog数据库，后续测试需要<br><img src="/img/docker_go_mysql_deployment/docker10.png"></p><h1 id="七、关联Golang项目和MySQL"><a href="#七、关联Golang项目和MySQL" class="headerlink" title="七、关联Golang项目和MySQL"></a>七、关联Golang项目和MySQL</h1><h2 id="1、删除原来的项目镜像"><a href="#1、删除原来的项目镜像" class="headerlink" title="1、删除原来的项目镜像"></a>1、删除原来的项目镜像</h2><p>由于原本的镜像存在问题，我们需要修改Dockerfile文件里的数据库的地址，我们需要删除它，此处有几种做法</p><ul><li>删除原本有问题的镜像，重新构建一个新镜像</li><li>重新构建一个不同 name、tag 的新镜像</li></ul><p>删除原本的有问题的镜像，-f 是强制删除及其关联状态</p><p>若不执行 -f，你需要执行 <strong>docker ps -a</strong> 查到所关联的容器，将其 rm 解除两者依赖关系</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker rmi <span class="hljs-operator">-f</span> <span class="hljs-built_in">gin</span><span class="hljs-literal">-gorm-docker</span><br></code></pre></td></tr></table></figure><h2 id="2、修改配置文件"><a href="#2、修改配置文件" class="headerlink" title="2、修改配置文件"></a>2、修改配置文件</h2><p>将项目的配置文件 <strong>conf&#x2F;app.ini</strong>，内容修改为</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#debug or release</span><br>RUN_MODE = debug<br><br>[<span class="hljs-type">app</span>]<br>PAGE_SIZE = <span class="hljs-number">10</span><br>JWT_SECRET = <span class="hljs-number">233</span><br><br>[<span class="hljs-type">server</span>]<br>HTTP_PORT = <span class="hljs-number">8080</span><br>READ_TIMEOUT = <span class="hljs-number">60</span><br>WRITE_TIMEOUT = <span class="hljs-number">60</span><br><br>[<span class="hljs-type">database</span>]<br><span class="hljs-built_in">TYPE</span> = mysql<br>USER = root<br>PASSWORD = <span class="hljs-number">123456</span><br>//IP地址为 容器名称：端口号<br>HOST = mysql:<span class="hljs-number">3306</span><br>NAME = blog<br>TABLE_PREFIX = blog_<br></code></pre></td></tr></table></figure><h2 id="3、重新构建镜像"><a href="#3、重新构建镜像" class="headerlink" title="3、重新构建镜像"></a>3、重新构建镜像</h2><p>重复先前的步骤，回到 gin-gorm 的项目根目录下执行 </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker build <span class="hljs-literal">-t</span> <span class="hljs-built_in">gin</span><span class="hljs-literal">-gorm-docker</span> .<br></code></pre></td></tr></table></figure><h2 id="4、创建关联并运行一个新容器"><a href="#4、创建关联并运行一个新容器" class="headerlink" title="4、创建关联并运行一个新容器"></a>4、创建关联并运行一个新容器</h2><p>我们如何将项目容器和MySQL容器创建关联？</p><p>在run指令内增加命令 <strong>–link mysql:mysql</strong> 让 <strong>Golang</strong> 容器与 <strong>Mysql</strong> 容器互联；通过 <strong>–link</strong>，可以在容器内直接使用其关联的容器别名进行访问，而不通过 IP，但是–link只能解决单机容器间的关联，在分布式多机的情况下，需要通过别的方式进行连接。</p><p>执行命令 </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker run <span class="hljs-literal">--link</span> mysql:mysql <span class="hljs-literal">-p</span> <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> <span class="hljs-built_in">gin</span><span class="hljs-literal">-gorm-docker</span><br></code></pre></td></tr></table></figure><p><img src="/img/docker_go_mysql_deployment/docker11.png"><br>MySQL容器的数据库也成功自动创建了三个数据表。<br><img src="/img/docker_go_mysql_deployment/docker12.png"></p><p>我们测试一下数据库是否已经关联，用户登录测试网址：<a href="http://localhost:8080/auth?username=admin&password=123456">http://localhost:8080/auth?username=admin&password=123456</a><br><img src="/img/docker_go_mysql_deployment/docker13.png"><br>大功告成！</p><h1 id="八、持久化数据库"><a href="#八、持久化数据库" class="headerlink" title="八、持久化数据库"></a>八、持久化数据库</h1><p>我们在每次启动一个 Mysql 容器时，数据库都是空的。另外容器删除之后，数据就丢失了。<br>我们学习了Docker Volume卷技术，了解了如何将数据生命周期独立于容器的生命周期之外，来更新一下我们的Mysql容器吧！</p><blockquote><p>Docker Volume文章：<a href="https://blog.csdn.net/weixin_46618592/article/details/126591142?spm=1001.2014.3001.5501">https://blog.csdn.net/weixin_46618592&#x2F;article&#x2F;details&#x2F;126591142?spm&#x3D;1001.2014.3001.5501</a></p></blockquote><h2 id="1、数据卷"><a href="#1、数据卷" class="headerlink" title="1、数据卷"></a>1、数据卷</h2><p><strong>数据卷</strong> 是被设计用来持久化数据的，数据卷的生命周期独立于容器的生命周期，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。</p><p>数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li>数据卷可以在容器之间共享和重用。</li><li>对数据卷的修改会立马生效。</li><li>对数据卷的更新，不会影响镜像。</li><li>数据卷默认会一直存在，即使容器被删除。</li></ul><blockquote><p>注意：<br>数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷。</p></blockquote><h2 id="2、如何挂载？"><a href="#2、如何挂载？" class="headerlink" title="2、如何挂载？"></a>2、如何挂载？</h2><ol><li>首先创建一个目录用于存放数据卷；示例目录 E:&#x2F;home&#x2F;docker-mysql。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">docker run --name mysql -d -p <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> -e MYSQL_ROOT_PASSWORD=<span class="hljs-number">123456</span> -v E:/home/docker-mysql:/<span class="hljs-keyword">var</span>/lib/mysql mysql:<span class="hljs-number">5.7</span><br></code></pre></td></tr></table></figure><p><img src="/img/docker_go_mysql_deployment/docker14.png"></p><ol start="2"><li>检查目录 E:&#x2F;home&#x2F;docker-mysql，多了很多数据库文件。</li></ol><p><img src="/img/docker_go_mysql_deployment/docker15.png"></p><h2 id="3、验证"><a href="#3、验证" class="headerlink" title="3、验证"></a>3、验证</h2><ol><li>新建一个blog数据库，并启动我们的gin-gorm-docker容器</li></ol><p><img src="/img/docker_go_mysql_deployment/docker16.png"><br><img src="/img/docker_go_mysql_deployment/docker17.png"><br><img src="/img/docker_go_mysql_deployment/docker18.png"></p><ol start="2"><li>登录验证一下：<a href="http://localhost:8080/auth?username=admin&password=123456">http://localhost:8080/auth?username=admin&password=123456</a></li></ol><p><img src="/img/docker_go_mysql_deployment/docker19.png"></p><ol start="3"><li>用我们的token，去新增tags数据表的记录<br><a href="http://localhost:8080/api/v1/tags?token=(%E7%99%BB%E5%BD%95%E5%90%8E%E6%8B%BF%E5%88%B0%E7%9A%84token)&amp;name=linzy&amp;state=1&amp;created_by=linzy">http://localhost:8080/api/v1/tags?token=(登录后拿到的token)&amp;name=linzy&amp;state=1&amp;created_by=linzy</a></li></ol><p><img src="/img/docker_go_mysql_deployment/docker20.png"><br><img src="/img/docker_go_mysql_deployment/docker21.png"><br>4. 删除MySQL容器，在重新用镜像启动</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"># 查看容器列表<br>E:\goWorkspace\github.com\Gopherlinzy\gin-gorm-example&gt;docker ps<br>CONTAINER ID   IMAGE             COMMAND                  CREATED          STATUS          PORTS                               NAMES<br>e57733001baa   gin-gorm-docker   <span class="hljs-string">&quot;./go-gin-example&quot;</span>       <span class="hljs-number">7</span> minutes ago    Up <span class="hljs-number">7</span> minutes    <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">8080</span>-&gt;<span class="hljs-number">8080</span>/tcp              beautiful_curran<br>c44788bd68d4   mysql:<span class="hljs-number">5.7</span>         <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   <span class="hljs-number">35</span> minutes ago   Up <span class="hljs-number">21</span> minutes   <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">3306</span>-&gt;<span class="hljs-number">3306</span>/tcp, <span class="hljs-number">33060</span>/tcp   mysql<br><br># 停止正在运行的MySQL容器<br>E:\goWorkspace\github.com\Gopherlinzy\gin-gorm-example&gt;docker stop c44788bd68d4<br>c44788bd68d4<br><br># 删除MySQL容器<br>E:\goWorkspace\github.com\Gopherlinzy\gin-gorm-example&gt;docker rm c44788bd68d4<br>c44788bd68d4<br><br># 重新将容器挂载到原来的目录<br>E:\goWorkspace\github.com\Gopherlinzy\gin-gorm-example&gt;docker run --name mysql -d -p <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> -e MYSQL_ROOT_PASSWORD=<span class="hljs-number">123456</span> -v E:/home/docker-mysql:/<span class="hljs-keyword">var</span>/lib/mysql mysql:<span class="hljs-number">5.7</span><br><span class="hljs-number">2</span>de27acad62b21693c79cc0687453ae2c7cb3d0f8f1f478c8715303afcdf497a<br></code></pre></td></tr></table></figure><p><img src="/img/docker_go_mysql_deployment/docker22.png"></p><p><img src="/img/docker_go_mysql_deployment/docker23.png"></p><blockquote><p>验证完毕，你也可以操作一下：创建一些测试表和数据，然后删除当前容器，重新创建的容器，数据库数据也依然存在（当然了数据卷指向要一致）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Docker容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>Docker</tag>
      
      <tag>go</tag>
      
      <tag>容器</tag>
      
      <tag>linux</tag>
      
      <tag>云原生</tag>
      
      <tag>运维</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker的入门与安装</title>
    <link href="/2022/08/15/docker-begin/"/>
    <url>/2022/08/15/docker-begin/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Docker概述"><a href="#一、Docker概述" class="headerlink" title="一、Docker概述"></a>一、Docker概述</h1><h2 id="1、Docker为什么出现-热门-？"><a href="#1、Docker为什么出现-热门-？" class="headerlink" title="1、Docker为什么出现(热门)？"></a>1、Docker为什么出现(热门)？</h2><p>一款产品需要开发和上线两套环境。<br>1）应用环境<br>2）应用配置</p><p>开发 — 运维之间的存在问题：<br>开发的电脑可以运行，到运维的电脑却不行了，开发的版本更新了，到运维的电脑导致服务不可用了，运维这边就需要重新同步版本环境与配置，难度就很大了。</p><p>但是环境配置是十分麻烦的，每一台机器都要重新部署环境(集群Redis，Node.js，Mysql…)，部署错误还会重新来过，又费时又费力。</p><p>我们发布一个项目，可能需要Redis、Mysql、Node.js的环境，电脑上运行只需要一分钟，而环境配置可能一天都不一定，充电两小时用时五分钟的概念。</p><p>如果我们可以把项目和环境一起安装打包，而不是单纯的一个项目包。</p><p><strong>Docker就是来完成这个事情的技术</strong></p><ul><li>传统：开发人员就开发项目，运维来做部署这些事情</li><li>现在：开发打包部署上线，一套流程做完</li></ul><blockquote><p>概念理解：<br>exe安装包 – &gt;发布(应用商店) – &gt; 用户下载安装 – &gt; 安装即可用<br>Golang项目(环境) – &gt; 项目和环境一起打包(Docker镜像) – &gt; Docker仓库 – &gt; 用户下载发布的Docker镜像 – &gt; 下载即可用</p></blockquote><h1 id="二、Docker的思想"><a href="#二、Docker的思想" class="headerlink" title="二、Docker的思想"></a>二、Docker的思想</h1><p>看看Docker的Logo，他的思想就来自于集装箱。<br><img src="/img/docker_begin/docker1.png"><br>Docker的核心思想：<strong>隔离</strong>，打包装箱，每个箱子之间是互相隔离的</p><h2 id="1、项目部署环境问题"><a href="#1、项目部署环境问题" class="headerlink" title="1、项目部署环境问题"></a>1、项目部署环境问题</h2><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题</p><ul><li>依赖关系复杂，容易出现兼容性问题</li><li>开发、测试、生产环境有差异<br><img src="/img/docker_begin/docker2.png"></li></ul><p>在项目中部署时需要依赖于node.js、Redis、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p><h2 id="2、用Docker完美解决问题"><a href="#2、用Docker完美解决问题" class="headerlink" title="2、用Docker完美解决问题"></a>2、用Docker完美解决问题</h2><p><img src="/img/docker_begin/docker3.png"><br>这样打包好的应用包中，既包含应用本身，也保护应用所需要的环境，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p><h2 id="3、Docker解决操作系统环境差异"><a href="#3、Docker解决操作系统环境差异" class="headerlink" title="3、Docker解决操作系统环境差异"></a>3、Docker解决操作系统环境差异</h2><p>解决了不同应用的兼容问题，但是开发、测试的环境也会存在差异，操作系统版本也有差异，相对应的函数库和依赖项都是基于操作系统，从而导致不兼容。</p><p>先了解一些操作系统结构，以Ubuntu操作系统为例</p><blockquote><p>Ubuntu操作系统结构包括：</p><ol><li>计算机硬件：例如CPU、内存、磁盘等</li><li>系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供内核指令，用于操作计算机硬件。</li><li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li></ol></blockquote><p><strong>应用于计算机交互的流程如下：</strong> </p><ol><li><p>应用调用操作系统应用（函数库），实现各种功能</p></li><li><p>系统函数库是对内核指令集的封装，会调用内核指令</p></li><li><p>内核指令操作计算机硬件</p></li></ol><p>如果我们将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了</p><blockquote><p>Docker如何解决不同系统环境的问题？</p><ol><li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li><li>Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行</li></ol></blockquote><h1 id="三、Docker的历史"><a href="#三、Docker的历史" class="headerlink" title="三、Docker的历史"></a>三、Docker的历史</h1><p>2010年，几个搞IT的年轻人，在美国成立了一家公司 <strong>dotCloud</strong>， 公司业务就是做一些PasS的云计算服务，是LXC有关的容器技术。<br>他们将自己的技术(容器化技术)命名为Docker，Docker诞生的时候并没有引起行业的关注，为了让公司能够存活下去，于是他们想到了一个方法：<strong>开源</strong>，把内部的代码全部开放给所有人，大家可以一起参加进来。</p><p>2013年，Docker开源后，越来越多的工程师发现了Docker的优点，Docker火了以后，几乎每个月都会更新一个版本。</p><p>2014年4月9日，Docker1.0发布！</p><p>到现在，Docker已经是所有开发人员都必须要了解掌握的一门技术。</p><h1 id="四、Docker的优势"><a href="#四、Docker的优势" class="headerlink" title="四、Docker的优势"></a>四、Docker的优势</h1><p>Docker 是一个开源的轻量级容器技术，让开发者可以打包他们的应用以及应用运行的上下文环境到一个可移植的镜像中，然后发布到任何支持 Docker 的系统上运行。 通过容器技术，在几乎没有性能开销的情况下，Docker 为应用提供了一个隔离运行环境，Docker是基于Go语言开发的技术。</p><ul><li>简化配置</li><li>代码流水线管理</li><li>提高开发效率</li><li>隔离应用</li><li>快速、持续部署</li></ul><h2 id="1、应用更快速的交付和部署"><a href="#1、应用更快速的交付和部署" class="headerlink" title="1、应用更快速的交付和部署"></a>1、应用更快速的交付和部署</h2><ul><li>传统：一堆的帮助文档，安装程式，部署环境</li><li>Docker：打包镜像发布测试，一键运行</li></ul><h2 id="2、更快捷的升级和扩缩容"><a href="#2、更快捷的升级和扩缩容" class="headerlink" title="2、更快捷的升级和扩缩容"></a>2、更快捷的升级和扩缩容</h2><p>使用Docker之和，部署应用就跟搭积木一样，项目打包为一个镜像，可以扩展到服务器。</p><h2 id="3、更简单的系统运维"><a href="#3、更简单的系统运维" class="headerlink" title="3、更简单的系统运维"></a>3、更简单的系统运维</h2><p>容器化之后，开发、运维、测试环境都是高度一致的。</p><h2 id="4、更高效的计算资源利用"><a href="#4、更高效的计算资源利用" class="headerlink" title="4、更高效的计算资源利用"></a>4、更高效的计算资源利用</h2><p>Docker是内核级别的虚拟机，可以在一个物理机上可以运行很多的容器示例，服务器的性能可以被压榨到极致。</p><h1 id="五、Docker与虚拟机的区别"><a href="#五、Docker与虚拟机的区别" class="headerlink" title="五、Docker与虚拟机的区别"></a>五、Docker与虚拟机的区别</h1><p>在Docker容器技术还没出来之前，我们都是使用虚拟机技术。</p><ul><li><strong>虚拟机</strong>：在Windows操作系统做我们安装一VMware，通过这个软件我们可以虚拟一台或多台电脑，虚拟机是属于虚拟化技术。<ul><li>优点：虚拟机跟真实电脑是差不多，可以在操作系统中模拟硬件设备。</li><li>缺点：虚拟机很笨重，启动时间很慢，虚拟机所占用的空间都很大，如果只是一些简单命令，就是大材小用。</li></ul></li><li><strong>Docker容器技术</strong>：Docker是一个系统进程，Docker容器技术也是虚拟化技术，最大的区别就是体量的不同。<ul><li>优点：十分小巧，只是把项目和环境一起打包成Docker镜像，运行镜像就可用了，启动时间很快，秒级启动。</li><li>缺点：并没有模拟操作系统。</li></ul></li></ul><p>Docker和虚拟机的区别对比：</p><table><thead><tr><th>特性</th><th>Docker</th><th>虚拟机</th></tr></thead><tbody><tr><td>性能</td><td>接近原生</td><td>性能差</td></tr><tr><td>硬盘占用</td><td>一般为MB</td><td>一般为GB</td></tr><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr></tbody></table><ul><li>传统虚拟机虚拟出一套硬件，模拟了一个完整的操作系统，然后在这个系统上安装和运行软件。</li><li>容器内的应用直接运行在宿主机上的，容器没有自己的内核，也没有虚拟出硬件，所以比虚拟机轻便小巧。</li><li>每个容器间都是互相隔离的，每个容器内都有一个属于自己的文件系统，互不影响。</li></ul><h1 id="六、Docker基本架构"><a href="#六、Docker基本架构" class="headerlink" title="六、Docker基本架构"></a>六、Docker基本架构</h1><p>Docker 包括三个基本概念:</p><ul><li><strong>镜像</strong>（Image）：Docker 镜像（Image），就相当于是一个 模板，可以通过模板来创建容器服务，通过这个镜像我们可以创建多个容器，最终服务运行或项目运行都是在容器中的。</li><li><strong>容器</strong>（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，Docker利用容器技术，独立运行一个或一组应用，都是通过镜像来创建的，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li><li><strong>仓库</strong>（Repository）：仓库可看成一个代码控制中心，用来保存镜像，仓库分为公有仓库和私用仓库。</li></ul><p>Docker 使用客户端-服务器 (C&#x2F;S) 架构模式，使用远程API来管理和创建Docker容器。</p><ul><li>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</li><li>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</li></ul><p><img src="/img/docker_begin/docker4.png"></p><h1 id="七、Docker安装"><a href="#七、Docker安装" class="headerlink" title="七、Docker安装"></a>七、Docker安装</h1><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a><br>文档地址：<a href="https://docs.docker.com/">https://docs.docker.com/</a><br>仓库地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a> 类似于Github的远程仓库</p><h2 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h2><p>Docker Desktop 是 Docker 在 Windows 10 和 macOS 操作系统上的官方安装方式，这个方法依然属于先在虚拟机中安装 Linux 然后再安装 Docker 的方法。</p><p>Docker Desktop 官方下载地址： <a href="https://docs.docker.com/desktop/install/windows-install/">https://hub.docker.com/editions/community/docker-ce-desktop-windows</a></p><blockquote><p>注意：此方法仅适用于 Windows 10 操作系统专业版、企业版、教育版和部分家庭版！</p></blockquote><h2 id="2、安装-Hyper-V"><a href="#2、安装-Hyper-V" class="headerlink" title="2、安装 Hyper-V"></a>2、安装 Hyper-V</h2><p>Hyper-V 是微软开发的虚拟机，类似于 VMWare 或 VirtualBox，仅适用于 Windows 10。这是 Docker Desktop for Windows 所使用的虚拟机。</p><p>但是，这个虚拟机一旦启用，QEMU、VirtualBox 或 VMWare Workstation 15 及以下版本将无法使用！如果你必须在电脑上使用其他虚拟机（例如开发 Android 应用必须使用的模拟器），请不要使用 Hyper-V！</p><h2 id="3、开启-Hyper-V"><a href="#3、开启-Hyper-V" class="headerlink" title="3、开启 Hyper-V"></a>3、开启 Hyper-V</h2><h3 id="1）打开Windows设置"><a href="#1）打开Windows设置" class="headerlink" title="1）打开Windows设置"></a>1）打开Windows设置</h3><p><img src="/img/docker_begin/docker5.png"></p><h3 id="2）选择应用拉到最底下选择程序和功能"><a href="#2）选择应用拉到最底下选择程序和功能" class="headerlink" title="2）选择应用拉到最底下选择程序和功能"></a>2）选择应用拉到最底下选择程序和功能</h3><p><img src="/img/docker_begin/docker6.png"></p><h3 id="3）选择启用或关闭Windows功能"><a href="#3）选择启用或关闭Windows功能" class="headerlink" title="3）选择启用或关闭Windows功能"></a>3）选择启用或关闭Windows功能</h3><p><img src="/img/docker_begin/docker7.png"></p><h3 id="4）选中Hyper-V"><a href="#4）选中Hyper-V" class="headerlink" title="4）选中Hyper-V"></a>4）选中Hyper-V</h3><p><img src="/img/docker_begin/docker8.png"><br>也可以通过命令来启用 Hyper-V ，请右键开始菜单并以管理员身份运行 PowerShell，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All<br></code></pre></td></tr></table></figure><h2 id="3、安装"><a href="#3、安装" class="headerlink" title="3、安装"></a>3、安装</h2><p>安装非常简单，不赘述。安装成功后查看windows任务栏会出现docker的经典logo，小鲸鱼 安装完成后，会出现一个弹出框，<br><strong>提示：close and restart 此时需要重新启动计算机</strong><br>打开我们的windows Terminal(CMD)，输入docker -v看看是否安装成功了<br><img src="/img/docker_begin/docker9.png"></p><h2 id="4、启动-Docker-Desktop"><a href="#4、启动-Docker-Desktop" class="headerlink" title="4、启动 Docker Desktop"></a>4、启动 Docker Desktop</h2><p><img src="/img/docker_begin/docker10.png"><br>可以开始我们的操作了</p><h2 id="5、验证Docker-Desktop"><a href="#5、验证Docker-Desktop" class="headerlink" title="5、验证Docker Desktop"></a>5、验证Docker Desktop</h2><p>打开刚才下载的windows Terminal运行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run hello-world<br></code></pre></td></tr></table></figure><p>看到以下输出则表示安装成功，且能正常工作：<br><img src="/img/docker_begin/docker10.png"><br>Docker Desktop已经存在hello-world镜像，表示已经拉取成功了<br><img src="/img/docker_begin/docker11.png"><br>至此我们的Docker Desktop安装成功，同样的我们也可以通过命令行进行安装，这里就不一一介绍了</p><p>详细参考官方文档：<a href="https://docs.docker.com/desktop/install/windows-install/">https://docs.docker.com/desktop/install/windows-install/</a></p><h1 id="八、Docker命令"><a href="#八、Docker命令" class="headerlink" title="八、Docker命令"></a>八、Docker命令</h1><h2 id="1、查看docker版本信息"><a href="#1、查看docker版本信息" class="headerlink" title="1、查看docker版本信息"></a>1、查看docker版本信息</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker version<br></code></pre></td></tr></table></figure><p><img src="/img/docker_begin/docker12.png"></p><h2 id="2、查看docker镜像"><a href="#2、查看docker镜像" class="headerlink" title="2、查看docker镜像"></a>2、查看docker镜像</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker images<br></code></pre></td></tr></table></figure><p><img src="/img/docker_begin/docker13.png"></p><h2 id="3、删除docker镜像"><a href="#3、删除docker镜像" class="headerlink" title="3、删除docker镜像"></a>3、删除docker镜像</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker rmi 镜像ID<br></code></pre></td></tr></table></figure><p>现在想删除镜像hello-world，则可以使用下述命令：<br><img src="/img/docker_begin/docker14.png"><br><img src="/img/docker_begin/docker15.png"><br>hello-world镜像已经不见了</p><p><strong>如果出现这个错误，表示有容器使用这个镜像要先把容器删除才能删除这个镜像</strong><br><img src="/img/docker_begin/docker16.png"></p><h2 id="4、查看所有的容器"><a href="#4、查看所有的容器" class="headerlink" title="4、查看所有的容器"></a>4、查看所有的容器</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span><br></code></pre></td></tr></table></figure><p><img src="/img/docker_begin/docker17.png"></p><h2 id="5、删除容器"><a href="#5、删除容器" class="headerlink" title="5、删除容器"></a>5、删除容器</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">rm</span> 容器ID<br></code></pre></td></tr></table></figure><p><img src="/img/docker_begin/docker18.png"><br>如上图所示，docker中存在容器ID名为“b3aa29b38d53”的容器，如果我们想删除这一个容器，那么在该容器得<strong>停止</strong>后可以使用下述命令：</p><p><img src="/img/docker_begin/docker19.png"><br>可以看到在使用了上述删除某一个容器之后，再次查看容器列表发现之前的容器已经不存在了。</p><h2 id="6、查看docker帮助命令"><a href="#6、查看docker帮助命令" class="headerlink" title="6、查看docker帮助命令"></a>6、查看docker帮助命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-literal">--help</span><br></code></pre></td></tr></table></figure><p><img src="/img/docker_begin/docker20.png"></p><h2 id="7、查看容器的数据卷"><a href="#7、查看容器的数据卷" class="headerlink" title="7、查看容器的数据卷"></a>7、查看容器的数据卷</h2><p>我们想查看容器的配置情况，可以使用这个命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker inspect 容器ID<br></code></pre></td></tr></table></figure><p><img src="/img/docker_begin/docker21.png"><br>我们想查看容器”cf559505fc9c”的配置情况，可以直接输入命令：<br><img src="/img/docker_begin/docker22.png"></p><h2 id="8、拉取镜像"><a href="#8、拉取镜像" class="headerlink" title="8、拉取镜像"></a>8、拉取镜像</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker pull 镜像名:指定版本<br></code></pre></td></tr></table></figure><p><img src="/img/docker_begin/docker23.png"><br><img src="/img/docker_begin/docker24.png"><br>Docker就存在两个MySQL了，一个是刚拉取的最新版MySQL镜像，另一个是指定版本安装的MySQL镜像。</p>]]></content>
    
    
    <categories>
      
      <category>Docker容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>Docker</tag>
      
      <tag>go</tag>
      
      <tag>容器</tag>
      
      <tag>linux</tag>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习目录</title>
    <link href="/2022/08/15/docker-directory/"/>
    <url>/2022/08/15/docker-directory/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker学习过程目录"><a href="#Docker学习过程目录" class="headerlink" title="Docker学习过程目录"></a>Docker学习过程目录</h1><h2 id="Docker入门"><a href="#Docker入门" class="headerlink" title="Docker入门"></a><a href="https://linzyblog.netlify.app/2022/08/15/docker-begin/">Docker入门</a></h2><ul><li>Docker概述</li><li>Docker的思想</li><li>Docker的历史</li><li>Docker的优势</li><li>Docker与虚拟机的区别</li><li>Docker安装</li><li>Docker基本架构</li><li>Docker命令</li></ul><h2 id="Docker底层原理和Docker常用命令"><a href="#Docker底层原理和Docker常用命令" class="headerlink" title="Docker底层原理和Docker常用命令"></a><a href="https://linzyblog.netlify.app/2022/08/26/docker-commoncomands/">Docker底层原理和Docker常用命令</a></h2><ul><li>Docker底层原理<ul><li>Docker是怎么工作的？</li><li>Docker为什么比VM快？</li><li>Docker 所使用的底层技术</li></ul></li><li>Docker常用命令<ul><li>镜像命令</li><li>容器命令</li><li>操作命令</li><li>常用其他命令</li></ul></li></ul><h2 id="Docker部署Golang项目和Mysql镜像"><a href="#Docker部署Golang项目和Mysql镜像" class="headerlink" title="Docker部署Golang项目和Mysql镜像"></a><a href="https://linzyblog.netlify.app/2022/08/15/docker-go-mysql-deployment/">Docker部署Golang项目和Mysql镜像</a></h2><h2 id="Docker镜像概述和分层原理-重点"><a href="#Docker镜像概述和分层原理-重点" class="headerlink" title="Docker镜像概述和分层原理(*重点)"></a><a href="https://linzyblog.netlify.app/2022/08/31/docker-volumes/">Docker镜像概述和分层原理(*重点)</a></h2><h2 id="Docker卷-volumes-重点"><a href="#Docker卷-volumes-重点" class="headerlink" title="Docker卷(volumes)(*重点)"></a><a href="https://linzyblog.netlify.app/2022/08/31/docker-volumes/">Docker卷(volumes)(*重点)</a></h2><h2 id="Dockerfile概述与用法"><a href="#Dockerfile概述与用法" class="headerlink" title="Dockerfile概述与用法"></a><a href="https://linzyblog.netlify.app/2022/09/06/docker-dockerfile/">Dockerfile概述与用法</a></h2><h2 id="Docker网络原理"><a href="#Docker网络原理" class="headerlink" title="Docker网络原理"></a>Docker网络原理</h2><p>我会以实战的方法来学习Docker，本文只是个索引目录</p>]]></content>
    
    
    <categories>
      
      <category>Docker容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>Docker</tag>
      
      <tag>go</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue学习-组件和生命周期</title>
    <link href="/2022/07/28/vue-Components-lifecycle/"/>
    <url>/2022/07/28/vue-Components-lifecycle/</url>
    
    <content type="html"><![CDATA[<h1 id="一、组件基础"><a href="#一、组件基础" class="headerlink" title="一、组件基础"></a>一、组件基础</h1><p>通常一个应用会以一棵嵌套的组件树的形式来组织：<br><img src="/img/vue-Components-lifecycle/vue1.png"><br>例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。</p><h2 id="1、为什么我们要用组件"><a href="#1、为什么我们要用组件" class="headerlink" title="1、为什么我们要用组件"></a>1、为什么我们要用组件</h2><p>了解传统方式到组件化方式的更新。<br><img src="/img/vue-Components-lifecycle/vue2.png"></p><blockquote><p>传统方式编写网页，会导致依赖关系混乱，代码复用率低，所以我们需要用到组件，不同组件的用来实现局部功能的代码和资源。</p></blockquote><p><img src="/img/vue-Components-lifecycle/vue3.png"></p><h2 id="2、基本使用"><a href="#2、基本使用" class="headerlink" title="2、基本使用"></a>2、基本使用</h2><p>为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：全局注册和局部注册。至此，我们的组件都只是通过 component 方法全局注册的：</p><h3 id="1）全局注册"><a href="#1）全局注册" class="headerlink" title="1）全局注册"></a>1）全局注册</h3><p>组件是用来实现局部功能的代码和资源的集合，是带有名称的可复用实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;&#125;)<br><br>app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;my-component-name&#x27;</span>, &#123;<br>  <span class="hljs-comment">// ... 选项 ...</span><br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>全局注册的组件可以在应用中的任何组件的模板中使用。</p></blockquote><h3 id="2）局部注册"><a href="#2）局部注册" class="headerlink" title="2）局部注册"></a>2）局部注册</h3><p>父组件 App.vue<br>子组件 header.vue、message.vue、bottom.vue</p><ul><li>header.vue</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;这里是头部子组件&quot;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>message.vue</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;这里是内容子组件&quot;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>bottom.vue</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;这里是底部子组件&quot;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>App.vue</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-comment">//导入各个组件</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> heade <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/header.vue&quot;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> bottom <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/bottom.vue&quot;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> message <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/message.vue&quot;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    heade,</span><br><span class="language-javascript">    bottom,</span><br><span class="language-javascript">    message,</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">heade</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">heade</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bottom</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bottom</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vue-Components-lifecycle/vue4.png"></p><h2 id="3、通过-Prop-向子组件传递数据"><a href="#3、通过-Prop-向子组件传递数据" class="headerlink" title="3、通过 Prop 向子组件传递数据"></a>3、通过 Prop 向子组件传递数据</h2><p>Prop 是你可以在组件上注册的一些自定义 attribute。为了给hello子组件传递一个message，我们可以用 props 选项将其包含在该组件可接受的 prop 列表中：</p><h3 id="1）传递值"><a href="#1）传递值" class="headerlink" title="1）传递值"></a>1）传递值</h3><p>App.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> hello <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/hello.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    hello</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 组件复用 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hello</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;我是头部&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">hello</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hello</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;我是内容&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">hello</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hello</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;我是底部&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">hello</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>&lt;/template &gt;<br></code></pre></td></tr></table></figure><p>hello.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;title&#x27;</span>],</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vue-Components-lifecycle/vue5.png"></p><blockquote><p>当一个值被传递给一个 <strong>prop</strong> attribute 时，它就成为该组件实例中的一个 property。该 property 的值可以在模板中访问，就像任何其他组件 property 一样。<br>一个组件可以拥有任意数量的 prop，并且在默认情况下，无论任何值都可以传递给 prop。</p></blockquote><h3 id="2）用-v-bind-来动态传递-prop"><a href="#2）用-v-bind-来动态传递-prop" class="headerlink" title="2）用 v-bind 来动态传递 prop"></a>2）用 v-bind 来动态传递 prop</h3><p><strong>App.vue</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> hello <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/hello.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello vue&quot;</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    hello</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hello</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">hello</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>父组件中<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>&lt;/template &gt;<br></code></pre></td></tr></table></figure><p><strong>hello.vue</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;msg&#x27;</span>],</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello子组件中<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vue-Components-lifecycle/vue6.png"></p><blockquote><p>我们传递给子组件的值是双向绑定的，我在父组件更新内容，子组件也会同样获取更新后的内容</p></blockquote><h2 id="4、监听子组件事件"><a href="#4、监听子组件事件" class="headerlink" title="4、监听子组件事件"></a>4、监听子组件事件</h2><p>我们在开发子组件时，它的一些功能可能需要与父级组件进行沟通，例如我在子组件改变特定值时，我们想要父组件也同样接收到，就需要父组件去监听子组件事件</p><p><strong>父组件去监听子组件事件</strong></p><ol><li>在子组件中设置方法，通过$emit来触发事件</li><li>在父组件中，通过v-on监听子组件中自定义的事件，接收子组件传来的值</li></ol><p>App.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Content</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Content.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello vue&quot;</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">Content</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">getMsg</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg);</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = msg</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 拿到子组件Content的数据，通过自定义事件 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 2、在父组件中，通过v-on监听子组件中自定义的事件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">content</span> @<span class="hljs-attr">injectMsg</span>=<span class="hljs-string">&quot;getMsg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">content</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>父级组件可以像处理原生 DOM 事件一样通过 v-on 或 @ 监听子组件实例的任意事件</p></blockquote><p>content.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Hello</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./HelloWorld.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//让每个组件都返回一个新的对象，不会造成数据污染</span></span><br><span class="language-javascript">        <span class="hljs-comment">//局部变量</span></span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;我是content&quot;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">list</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-title class_">Hello</span></span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">//1、在子组件中，通过$emit来触发事件</span></span><br><span class="language-javascript">        <span class="hljs-attr">sendParent</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// this.emit(&#x27;自定义事件名称&#x27;, &#x27;发送参数&#x27;)</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;injectMsg&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span>)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 组件是带有名称的可复用实例，带有单独模板的封装 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Hello</span> <span class="hljs-attr">:message</span>=<span class="hljs-string">&quot;msg&quot;</span> <span class="hljs-attr">aaa</span>=<span class="hljs-string">&quot;123&quot;</span> <span class="hljs-attr">:list</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Hello</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是content组件<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;msg = &#x27;你好&#x27;&quot;</span>&gt;</span>改变msg<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- &lt;Hello&gt;&lt;/Hello&gt; --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendParent&quot;</span>&gt;</span>发送数据到父组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>同时子组件可以通过调用内建的 $emit 方法并传入事件名称来触发一个事件</p></blockquote><p>helloworld.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;我是hello&quot;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>: &#123;<span class="hljs-comment">//对象</span></span><br><span class="language-javascript">    <span class="hljs-comment">//1、类型限制</span></span><br><span class="language-javascript">    <span class="hljs-attr">message</span>: <span class="hljs-title class_">String</span>,</span><br><span class="language-javascript">    <span class="hljs-comment">//2、设置默认值、必须传值</span></span><br><span class="language-javascript">    <span class="hljs-attr">message</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;我是linzy&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">list</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Array</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">default</span>: [],</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>);</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$root</span>);</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;h1&gt;&#123;&#123; aaa &#125;&#125;&lt;/h1&gt; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; list &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br></code></pre></td></tr></table></figure><blockquote><p>我们可以把props变为对象形式，这样我们在接收到的值进行条件限定，可以限定类型、设置默认值、必须传入值等。</p></blockquote><p><img src="/img/vue-Components-lifecycle/vue7.png"><br><img src="/img/vue-Components-lifecycle/vue8.png"></p><h2 id="5、插槽"><a href="#5、插槽" class="headerlink" title="5、插槽"></a>5、插槽</h2><p>和 HTML 元素一样，我们经常需要向一个组件传递内容，就是我们使用 &lt; slot&gt; 作为我们想要插入内容的占位符</p><h3 id="1）插槽内容"><a href="#1）插槽内容" class="headerlink" title="1）插槽内容"></a>1）插槽内容</h3><p>App.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Content</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Content.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello vue&quot;</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">Content</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 传递字符串 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Content</span>&gt;</span>我是插槽<span class="hljs-tag">&lt;/<span class="hljs-name">Content</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 传递一个按钮 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Content</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Content</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 传递一个文本框 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Content</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Content</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>content.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是Content组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vue-Components-lifecycle/vue9.png"></p><blockquote><p>如果有多个值，同时放入组件进行替换时，一起作为替换元素</p></blockquote><h3 id="2）渲染作用域"><a href="#2）渲染作用域" class="headerlink" title="2）渲染作用域"></a>2）渲染作用域</h3><p> 父级模板里的所有内容都在父级作用域中编译 子模板里的所有内容都是在子作用域中编译</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">todo-button</span>&gt;</span><br>  Delete a &#123;&#123; item.name &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">todo-button</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vue-Components-lifecycle/vue10.png"></p><h3 id="3）备用内容"><a href="#3）备用内容" class="headerlink" title="3）备用内容"></a>3）备用内容</h3><p>有时为一个插槽指定备用 (也就是默认的) 内容是很有用的，它只会在没有提供内容的时候被渲染。例如在一个 <submit-button> 组件中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在当我们在一个父级组件中使用 <submit-button> 并且不提供任何插槽内容时</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">submit-button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">submit-button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>备用内容“Submit”将会被渲染：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>  Submit<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>但是如果我们提供内容,则这个提供的内容将会被渲染从而取代备用内容</p></blockquote><h3 id="4）具名插槽"><a href="#4）具名插槽" class="headerlink" title="4）具名插槽"></a>4）具名插槽</h3><p>有时我们需要多个插槽，具名插槽可以根据slot的name进行分配，&lt; slot&gt; 元素有一个特殊的 attribute：name。通过它可以为不同的插槽分配<strong>独立的 ID</strong>，也就能够以此来决定内容应该渲染到什么地方。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是Content组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bottom&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>一个不带 name 的 <slot> 出口会带有隐含的名字“default”</strong>。</p><p>在向具名插槽提供内容的时候，我们可以在一个 &lt; template&gt; 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Content</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Content.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">Content</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Content</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- v-slot 只能添加在 &lt;template&gt; 上  --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我不是具名插槽.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>header按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:main</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;main文本框&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:bottom</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是bottom插槽<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Content</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vue-Components-lifecycle/vue11.png"></p><blockquote><p>注意，v-slot 只能添加在 &lt; template&gt; 上</p></blockquote><h3 id="5）作用域插槽"><a href="#5）作用域插槽" class="headerlink" title="5）作用域插槽"></a>5）作用域插槽</h3><p>有时让插槽内容能够访问子组件中才有的数据是很有用的。当一个组件被用来渲染一个项目数组时，这是一个常见的情况，我们希望能够自定义每个项目的渲染方式。</p><blockquote><p>简而言之，可能每个页面插槽渲染的数据可能会不同，所以我们通过访问子组件中的数据来渲染，来实现相同的效果</p></blockquote><p>App.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Content</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Content.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">Content</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 无序列表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Content</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in slotProps.item&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Content</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 有序列表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Content</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in slotProps.item&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Content</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>content.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">arr</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>]</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是Content组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">:item</span>=<span class="hljs-string">&quot;arr&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vue-Components-lifecycle/vue12.png"><br><img src="/img/vue-Components-lifecycle/vue13.png"></p><h2 id="6、跨级通信Provide-x2F-Inject"><a href="#6、跨级通信Provide-x2F-Inject" class="headerlink" title="6、跨级通信Provide &#x2F; Inject"></a>6、跨级通信Provide &#x2F; Inject</h2><p><strong>通常，当我们需要从父组件向子组件传递数据时，我们使用 props。</strong>想象一下这样的结构：有一些深度嵌套的组件，而深层的子组件只需要父组件的部分内容。在这种情况下，如果仍然将 prop 沿着组件链逐级传递下去，可能会很麻烦。</p><p>对于这种情况，我们可以使用一对 provide 和 inject。无论组件层次结构有多深，父组件都可以作为其所有子组件的依赖提供者。这个特性有两个部分：父组件有一个 <strong>provide</strong> 选项来提供数据，子组件有一个 <strong>inject</strong> 选项来开始使用这些数据。<br><img src="/img/vue-Components-lifecycle/vue14.png"><br>例如，我们有这样的层次结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">Root<br>└─ TodoList<br>   ├─ TodoItem<br>   └─ TodoListFooter<br>      ├─ ClearTodosButton<br>      └─ TodoListStatistics<br></code></pre></td></tr></table></figure><p>如果要将 todo-items 的长度直接传递给 TodoListStatistics，我们要将 prop 逐级传递下去：TodoList -&gt; TodoListFooter -&gt; TodoListStatistics。通过 provide&#x2F;inject 的方式，我们可以直接执行以下操作：</p><ol><li>祖先组件用provide值传递</li><li>子孙组件用inject接收值传递</li></ol><h3 id="1）值传递-x2F-引用传递"><a href="#1）值传递-x2F-引用传递" class="headerlink" title="1）值传递&#x2F;引用传递"></a>1）值传递&#x2F;引用传递</h3><p>App.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Content</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Content.vue&quot;</span></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello vue&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">obj</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello linzy&quot;</span>,</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">Content</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-comment">//provide/inject并不是响应式的</span></span><br><span class="language-javascript">  <span class="hljs-comment">// provide: &#123; message: this.message &#125;</span></span><br><span class="language-javascript">  <span class="hljs-comment">//如果想去访问组件实例的属性</span></span><br><span class="language-javascript">  <span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">//值传递</span></span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>,</span><br><span class="language-javascript">      <span class="hljs-comment">//引用传递 </span></span><br><span class="language-javascript">      <span class="hljs-comment">//1、响应式对象方式</span></span><br><span class="language-javascript">      <span class="hljs-attr">obj</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>HomeView----&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>HomeView----&#123;&#123; obj.message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>--------------------<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Content</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Content</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;message = &#x27;勇敢牛牛&#x27;&quot;</span>&gt;</span>改变message按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;obj.message = &#x27;哈哈哈&#x27;&quot;</span>&gt;</span>改变对象里的message按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><br></code></pre></td></tr></table></figure><p>content.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">//值传递</span></span><br><span class="language-javascript">    <span class="hljs-attr">inject</span>: [<span class="hljs-string">&#x27;message&#x27;</span>],</span><br><span class="language-javascript">    <span class="hljs-comment">//引用传递</span></span><br><span class="language-javascript">    <span class="hljs-attr">inject</span>: [<span class="hljs-string">&#x27;obj&#x27;</span>]</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>hello---&#123;&#123; obj.message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vue-Components-lifecycle/vue15.png"><br>注意：值传递就相当于，在子组件开辟了新的属性变量，跟父组件的属性变量没有关系了，引用传递，可以看做c<strong>语言里的指针的概念，传递了一个地址</strong>，都是属于一个内存空间的，所以子组件里对象的属性变量改变了，父组件的也会改变</p><blockquote><p>父组件不需要知道哪些子组件使用了它 provide 的 property<br>子组件不需要知道 inject 的 property 来自哪里</p></blockquote><h3 id="2）处理响应性"><a href="#2）处理响应性" class="headerlink" title="2）处理响应性"></a>2）处理响应性</h3><p><strong>这是因为默认情况下，provide&#x2F;inject 绑定并不是响应式的</strong>。<br>我们可以通过传递一个 ref property 或 reactive 对象给 provide 来改变这种行为。在我们的例子中，如果我们想对祖先组件中的更改做出响应。<br>App.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Content</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Content.vue&quot;</span></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello vue&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">obj</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello linzy&quot;</span>,</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">Content</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-comment">//provide/inject并不是响应式的</span></span><br><span class="language-javascript">  <span class="hljs-comment">// provide: &#123; message: this.message &#125;</span></span><br><span class="language-javascript">  <span class="hljs-comment">//如果想去访问组件实例的属性</span></span><br><span class="language-javascript">  <span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">//函数返回响应式数据</span></span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>HomeView----&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>--------------------<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Content</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Content</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;message = &#x27;勇敢牛牛&#x27;&quot;</span>&gt;</span>改变message按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>content.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">//值传递</span></span><br><span class="language-javascript">    <span class="hljs-attr">inject</span>: [<span class="hljs-string">&#x27;message&#x27;</span>],</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; message() &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vue-Components-lifecycle/vue16.png"></p><h1 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h1><p><img src="/img/vue-Components-lifecycle/vue17.png"></p><blockquote><ol><li>实例化一个Vue对象</li><li>初始化事件和生命周期</li><li>执行<strong>beforeCreate</strong>钩子函数(Vue实例还没创建，获取不到Dom节点，拿不到data&gt; 数据和methods方法)</li><li>初始化响应式、数据代理和数据监测</li><li>执行<strong>created</strong>钩子函数(Vue实例已经创建完毕，data数据和methods方法这些已经成功绑定到Vue实例中，但是Dom元素还没有生成，还不能调用)</li><li>有没有template选项<br> 1）Yes，把template编译成渲染函数<br> 2）No，我们将el挂载的html编译成template</li><li>执行<strong>beforeMount</strong>钩子函数(页面还没渲染前，el还挂载在虚拟Dom里)</li><li>将编译好的html去替换掉el属性里的Dom对象 ，把虚拟Dom变为真实Dom放入页面</li><li>执行<strong>mounted</strong>钩子函数(页面已经渲染出来，用来获取数据或者发送网络请求)</li><li>实时监听数据变化，随时更新Dom，当我们的数据发生变化时<br>1） 执行<strong>beforeUpdate</strong>钩子函数(在数据改变之前，虚拟Dom已经更新完了，做一些更新之前需要做的事情)<br>2）虚拟Dom重新渲染成真实Dom，对比虚拟Dom和真实Dom节点的不同，找需要更新的节点，从而更新<br>3）执行<strong>updated</strong>钩子函数(数据改变之后)<br>4）直到Vue实例对象被销毁</li><li>执行<strong>beforeUnmout</strong>钩子函数(Vue实例销毁之前，data数据和methods方法之类还没有被销毁，还能调用，可以解绑事件监听或者清除掉定时器之类事件)</li><li>执行<strong>unmouted</strong>钩子函数(Vue实例销毁之后)</li></ol></blockquote><h1 id="三、生命周期钩子"><a href="#三、生命周期钩子" class="headerlink" title="三、生命周期钩子"></a>三、生命周期钩子</h1><p>App.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> content <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Content.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello vue&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">isShow</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    content</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">content</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">content</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;isShow = !isShow&quot;</span>&gt;</span>销毁hello组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>content.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeCreate&#x27;</span>);</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;created&#x27;</span>);</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">beforeMount</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeMount&#x27;</span>);</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;mounted&#x27;</span>);</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-comment">//页面渲染之后</span></span><br><span class="language-javascript">    <span class="hljs-title function_">beforeUpdate</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeUpdate&#x27;</span>);</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">updated</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;updated&#x27;</span>);</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">beforeUnmount</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeUnmount&#x27;</span>);</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">unmounted</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;unmounted&#x27;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; counter &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;counter++&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vue-Components-lifecycle/vue18.png"></p>]]></content>
    
    
    <categories>
      
      <category>Vue学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>Vue</tag>
      
      <tag>前端</tag>
      
      <tag>js</tag>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue学习-基础入门篇</title>
    <link href="/2022/07/27/vueIntroductory/"/>
    <url>/2022/07/27/vueIntroductory/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Vue介绍"><a href="#一、Vue介绍" class="headerlink" title="一、Vue介绍"></a>一、Vue介绍</h1><h2 id="1、Vue是什么"><a href="#1、Vue是什么" class="headerlink" title="1、Vue是什么"></a>1、Vue是什么</h2><p>Vue是一套用于构建用户界面的 &#x3D;&#x3D;<strong>渐进式框架</strong>&#x3D;&#x3D; 。与其它大型框架不同的是，Vue 被设计为可以自底向上<strong>逐层应用</strong>。</p><h2 id="2、Vue的特点"><a href="#2、Vue的特点" class="headerlink" title="2、Vue的特点"></a>2、Vue的特点</h2><p>(1)  Vue 的核心库只关注视图层。<br>(2) 不仅易于上手，还便于与第三方库或既有项目整合。<br>(3) 遵循 &#x3D;&#x3D;<strong>MVVM模式</strong>&#x3D;&#x3D; ，能够实现视图与模型的 &#x3D;&#x3D;<strong>双向绑定</strong>&#x3D;&#x3D;。</p><ul><li>MVVM模式：就是数据变化的时候, 页面会自动刷新, 页面变化的时候，数据也会自动变化.</li></ul><p>(4) 编码简洁，体积小，运行效率高，适合移动&#x2F;PC端开发。</p><h1 id="二、Vue-js的安装"><a href="#二、Vue-js的安装" class="headerlink" title="二、Vue.js的安装"></a>二、Vue.js的安装</h1><ul><li><a href="https://v3.cn.vuejs.org/guide/installation.html#%E5%8F%91%E5%B8%83%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">中文文档手册安装方法</a></li><li><a href="https://blog.csdn.net/m0_37479246/article/details/78836686">参考大佬详细完整的安装方法</a></li></ul><h2 id="1、使用Vite创建"><a href="#1、使用Vite创建" class="headerlink" title="1、使用Vite创建"></a>1、使用Vite创建</h2><p>Vite 是一个 web 开发构建工具，由于其原生 ES 模块导入方式，可以实现闪电般的 &#x3D;&#x3D;<strong>冷服务器启动</strong>&#x3D;&#x3D;。</p><p>它做到了 <strong>本地快速开发启动</strong>, 在生产环境下基于 Rollup 打包。</p><ol><li>快速的冷启动，不需要等待打包操作；</li><li>即时的热模块更新，替换性能和模块数量的解耦让更新飞起；</li><li>真正的按需编译，不再等待整个应用编译完成，这是一个巨大的改变。</li></ol><p>通过在终端中运行以下命令，可以使用 Vite 快速构建 Vue 项目。</p><p>使用 npm：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"># npm <span class="hljs-number">6.</span>x<br>$ npm init vite@latest &lt;project-name&gt; --template vue<br><br># npm <span class="hljs-number">7</span>+，需要加上额外的双短横线<br>$ npm init vite@latest &lt;project-name&gt; -- --template vue<br><br>$ cd &lt;project-name&gt;<br>$ npm install<br>$ npm run dev<br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue1.png"><br>完成！</p><h1 id="三、Vue声明式渲染"><a href="#三、Vue声明式渲染" class="headerlink" title="三、Vue声明式渲染"></a>三、Vue声明式渲染</h1><p>Vue.js 的核心是一个允许采用简洁的模板语法来<strong>声明式</strong>地将数据渲染进 DOM 的系统</p><p><strong>main.js</strong>入口文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./style.css&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-comment">//创建Vue应用,将配置对象传入,用mount进行挂载</span><br><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>App.vue</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-comment">//局部变量，变量都是定义在data里</span></span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;Hello vue&quot;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 自动读取到data中的所有属性 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue2.png"></p><p>我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是<strong>响应式</strong>的</p><p>示例：其中 每点击一次按钮，counter就会加一，你将看到渲染的 DOM 是如何变化的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-comment">//局部变量，变量都是定义在data里</span></span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;Hello vue&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 自动读取到data中的所有属性 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; counter &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;counter++&quot;</span>&gt;</span>改变counter<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue3.png"></p><blockquote><p> 注意：</p><ol><li>想让Vue工作，就必须创建一个 <strong>Vue实例</strong>，且要传入一个 <strong>配置对象</strong></li><li>root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法</li><li>root容器里的代码被称为 <strong>Vue模板</strong></li><li>Vue实例与容器是一一对应的</li><li>真实开发中只有一个Vue实例，并且会配合着组件一起使用</li><li><strong></strong> 中的xxx要写js表达式，且<strong>xxx</strong>可以自动读取到data中的所有属性</li><li><strong>响应式</strong> 就是一旦data中的数据发生变化，那么模板中用到该数据的地方也会自动更新</li></ol></blockquote><h1 id="四、Data-Property-和方法"><a href="#四、Data-Property-和方法" class="headerlink" title="四、Data Property 和方法"></a>四、Data Property 和方法</h1><h2 id="1、Data-Property"><a href="#1、Data-Property" class="headerlink" title="1、Data Property"></a>1、Data Property</h2><p>组件的 &#x3D;&#x3D;data&#x3D;&#x3D; 选项是一个函数。Vue 会在创建新组件实例的过程中调用此函数。它应该返回一个对象，然后 Vue 会通过响应性系统将其包裹起来，并以 &#x3D;&#x3D;$data&#x3D;&#x3D; 的形式存储在组件实例中。为方便起见，该对象的任何顶级 property 也会直接通过组件实例暴露出来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">4</span> &#125;<br>  &#125;<br>&#125;)<br><br><span class="hljs-keyword">const</span> vm = app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-property">$data</span>.<span class="hljs-property">count</span>) <span class="hljs-comment">// =&gt; 4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-property">count</span>)       <span class="hljs-comment">// =&gt; 4</span><br><br><span class="hljs-comment">// 修改 vm.count 的值也会更新 $data.count</span><br>vm.<span class="hljs-property">count</span> = <span class="hljs-number">5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-property">$data</span>.<span class="hljs-property">count</span>) <span class="hljs-comment">// =&gt; 5</span><br><br><span class="hljs-comment">// 反之亦然</span><br>vm.<span class="hljs-property">$data</span>.<span class="hljs-property">count</span> = <span class="hljs-number">6</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-property">count</span>) <span class="hljs-comment">// =&gt; 6</span><br></code></pre></td></tr></table></figure><p>这些实例 property 仅在实例首次创建时被添加，所以你需要确保它们都在 &#x3D;&#x3D;data&#x3D;&#x3D; 函数返回的对象中。必要时，要对尚未提供所需值的 property 使用 &#x3D;&#x3D;null&#x3D;&#x3D;、&#x3D;&#x3D;undefined&#x3D;&#x3D; 或其他占位的值。</p><p>直接将不包含在 &#x3D;&#x3D;data&#x3D;&#x3D; 中的新 property 添加到组件实例是可行的。但由于该 property 不在背后的响应式 &#x3D;&#x3D;$data&#x3D;&#x3D;对象内，所以 <strong>Vue 的响应性系统</strong>不会自动跟踪它。</p><p>Vue 使用 $ 前缀通过组件实例暴露自己的内置 API。它还为内部 property 保留 _ 前缀。你应该避免使用这两个字符开头的顶级 data property 名称。</p><h2 id="2、方法"><a href="#2、方法" class="headerlink" title="2、方法"></a>2、方法</h2><p>我们用 methods 选项向组件实例添加方法，它应该是一个包含所需方法的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">4</span> &#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// `this` 指向该组件实例</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++<br>    &#125;<br>  &#125;<br>&#125;)<br><br><span class="hljs-keyword">const</span> vm = app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-property">count</span>) <span class="hljs-comment">// =&gt; 4</span><br><br>vm.<span class="hljs-title function_">increment</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-property">count</span>) <span class="hljs-comment">// =&gt; 5</span><br></code></pre></td></tr></table></figure><p>Vue 自动为 &#x3D;&#x3D;methods&#x3D;&#x3D; 绑定 &#x3D;&#x3D;this&#x3D;&#x3D;，以便于它始终指向组件实例。这将确保方法在用作事件监听或回调时保持正确的 &#x3D;&#x3D;this&#x3D;&#x3D;指向。在定义 &#x3D;&#x3D;methods&#x3D;&#x3D;时应避免使用箭头函数，因为这会阻止 Vue 绑定恰当的 &#x3D;&#x3D;this&#x3D;&#x3D;指向。</p><p>这些 &#x3D;&#x3D;methods&#x3D;&#x3D;和组件实例的其它所有 property 一样可以在组件的模板中被访问。在模板中，它们通常被当做事件监听使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>Up vote<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，点击 &lt; button&gt; 时，会调用 increment 方法。</p><p>也可以直接从模板中调用方法。通常换做计算属性会更好。但是，在计算属性不可行的情况下，使用方法可能会很有用。你可以在模板支持 JavaScript 表达式的任何地方调用方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;toTitleDate(date)&quot;</span>&gt;</span><br>  &#123;&#123; formatDate(date) &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果 &#x3D;&#x3D;toTitleDate&#x3D;&#x3D; 或 &#x3D;&#x3D;formatDate&#x3D;&#x3D; 访问了任何响应式数据，则将其作为渲染依赖项进行跟踪，就像直接在模板中使用过一样。</p><p>从模板调用的方法不应该有任何副作用，比如更改数据或触发异步进程。如果你想这么做，应该使用<strong>生命周期钩子</strong>来替换。</p><h1 id="五、Vue模板语法"><a href="#五、Vue模板语法" class="headerlink" title="五、Vue模板语法"></a>五、Vue模板语法</h1><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层组件实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p><p>在底层的实现上，Vue 将模板编译成 &#x3D;&#x3D;<strong>虚拟 DOM 渲染函数</strong>&#x3D;&#x3D;。结合响应性系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。</p><p>如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，直接写渲染 (render) 函数，使用可选的 JSX 语法。</p><h2 id="1、插值"><a href="#1、插值" class="headerlink" title="1、插值"></a>1、插值</h2><p><strong>概述</strong>：在插值表达式中用户可以把vue中所定义的数据显示在页面上。 插值表达式允许用户输入”JS表达式”<br><strong>语法</strong>：&#x3D;&#x3D;NaN&#x3D;&#x3D;</p><h3 id="1）文本"><a href="#1）文本" class="headerlink" title="1）文本"></a>1）文本</h3><p><strong>数据绑定</strong>最常见的形式就是使用 (双大括号) 语法的文本插值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; num &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Mustache 标签将会被替代为对应组件实例中 property 的值。无论何时，绑定的组件实例上 property 发生了改变，插值处的内容都会更新。</p><p>通过使用 &#x3D;&#x3D;v-once&#x3D;&#x3D; 指令，你也能执行<strong>一次性</strong>地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">num</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;linzy&quot;</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-comment">//vue方法的集合</span></span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">//给vue定义方法</span></span><br><span class="language-javascript">    <span class="hljs-attr">changeName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">//this指向vue实例</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;勇敢牛牛&quot;</span></span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>1、插值表达式 文本<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; num &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- v-once 当属性数据改变时，插值处的内容不会更新 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>2、v-once 当属性数据改变时，插值处的内容不会更新<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-once</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeName&quot;</span>&gt;</span>改变名字<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue4.png"></p><h3 id="2）原始-HTML"><a href="#2）原始-HTML" class="headerlink" title="2）原始 HTML"></a>2）原始 HTML</h3><p>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用v-html 指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;&lt;h2&gt;标题&lt;/h2&gt;&quot;</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- v-html 让内容以html形式显示 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue5.png"><br>这个 p 标签的内容将会被替换成为 msg property 的值，直接作为 HTML——会忽略解析 property 值中的数据绑定。注意，你不能使用 v-html 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。反之，对于用户界面 (UI)，组件更适合作为可重用和可组合的基本单位。</p><blockquote><p>TIP<br>在你的站点上动态渲染任意的 HTML 是非常危险的，因为它很容易导致 &#x3D;&#x3D;XSS 攻击&#x3D;&#x3D;。请只对可信内容使用 HTML 插值，绝不要将用户提供的内容作为插值。</p></blockquote><h3 id="3）Attribute属性"><a href="#3）Attribute属性" class="headerlink" title="3）Attribute属性"></a>3）Attribute属性</h3><p>Mustache 语法不能在 HTML attribute 中使用，然而，可以使用 <strong>v-bind</strong> 指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;dynamicId&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果绑定的值是 null 或 undefined，那么该 attribute 将不会被包含在渲染的元素上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;d1&quot;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">changeColor</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = <span class="hljs-string">&quot;d2&quot;</span></span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- v-bind 动态的绑定属性的内容 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span>v-bind绑定属性<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- click点击事件--&gt;</span><br>    <span class="hljs-comment">&lt;!-- 自定义函数 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeColor&quot;</span>&gt;</span>改变颜色<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- js表达式 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;id = &#x27;d3&#x27;&quot;</span>&gt;</span>改变颜色<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#d1</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#d2</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">color</span>: green;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#d3</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">color</span>: pink;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue6.png"></p><h3 id="4）使用-JavaScript-表达式"><a href="#4）使用-JavaScript-表达式" class="headerlink" title="4）使用 JavaScript 表达式"></a>4）使用 JavaScript 表达式</h3><p>迄今为止，在我们的模板中，我们一直都只绑定简单的 property 键值。但实际上，对于所有的数据绑定，Vue.js 都提供了完全的 <strong>JavaScript 表达式</strong>支持。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;d1&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">num</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;linzy&quot;</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用JavaScript表达式 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; num + 1 &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 字符串翻转 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span>&#123;&#123; name.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;id = id + 1&quot;</span>&gt;</span>改变颜色<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#d1</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue7.png"></p><blockquote><p>这些表达式会在当前活动实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含<strong>单个表达式</strong>，所以下面的例子都不会生效。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--  这是语句，不是表达式：--&gt;</span><br>&#123;&#123; var a = 1 &#125;&#125;<br><br><span class="hljs-comment">&lt;!-- 流程控制也不会生效，请使用三元表达式 --&gt;</span><br>&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;<br></code></pre></td></tr></table></figure><h2 id="2、指令"><a href="#2、指令" class="headerlink" title="2、指令"></a>2、指令</h2><p><strong>概述</strong>：指令 (Directives) 是带有 v- 前缀的特殊 attribute，指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM，指令用于解析标签（包括：标签属性、标签体内容、绑定事件等）<br><strong>语法</strong>：v-xxx</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;seen&quot;</span>&gt;</span>现在你看到我了<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里，v-if 指令将根据表达式 seen 的值的 true&#x2F;false 来插入&#x2F;移除 <p> 元素。</p><h3 id="1）参数"><a href="#1）参数" class="headerlink" title="1）参数"></a>1）参数</h3><p>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。<br>例如，<strong>v-bind 指令</strong>可以用于响应式地更新 HTML attribute，<strong>v-on 指令</strong>，它用于监听 DOM 事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;d1&quot;</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">changeColor</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = <span class="hljs-string">&quot;d2&quot;</span>;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- v-bind 可以用于响应式地更新 HTML attribute --&gt;</span><br>    <span class="hljs-comment">&lt;!-- v-bind 语法糖 : --&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;p v-bind:id=&quot;id&quot;&gt;v-bind绑定&lt;/p&gt; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span>v-bind绑定<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- v-on用于监听DOM事件 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- v-on 语法糖 @ --&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;button v-on:click=&quot;changeColor&quot;&gt;改变颜色&lt;/button&gt; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeColor&quot;</span>&gt;</span>改变颜色<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#d1</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#d2</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">color</span>: pink;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue8.png"></p><h3 id="2）动态参数"><a href="#2）动态参数" class="headerlink" title="2）动态参数"></a>2）动态参数</h3><p>可以在指令参数中使用 JavaScript 表达式，方法是用方括号括起来：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;linzy&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;d1&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">attribute</span>: <span class="hljs-string">&quot;id&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">mouseEvent</span>: <span class="hljs-string">&quot;click&quot;</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">changeFontSize</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">attribute</span> = <span class="hljs-string">&quot;class&quot;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 动态参数 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 动态属性 :[attribute]=&quot;id&quot;等价于v-bind:id=&quot;id&quot;--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:</span>[<span class="hljs-attr">attribute</span>]=<span class="hljs-string">&quot;id&quot;</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeFontSize&quot;</span>&gt;</span>改变属性<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 动态事件 @[mouseEvent]=&quot;changeFontSize&quot;等价于 v-on:click=&quot;changeFontSize&quot;--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @[<span class="hljs-attr">mouseEvent</span>]=<span class="hljs-string">&quot;changeFontSize&quot;</span>&gt;</span>改变字体大小<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;mouseEvent = &#x27;mouseover&#x27;&quot;</span>&gt;</span>改变事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#d1</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#d2</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">color</span>: pink;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.d1</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">61px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue9.png"></p><blockquote><p>这里的 attribute 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的组件实例 data property 有一个 attribute，其值为 “id”，那么这个绑定将等价于 v-bind:id。<br>同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：<br>在这个示例中，当 mouseEvent 的值为 “click” 时，v-on:[mouseEvent] 将等价于 v-on:click</p></blockquote><h1 id="六、v-on事件处理"><a href="#六、v-on事件处理" class="headerlink" title="六、v-on事件处理"></a>六、v-on事件处理</h1><h2 id="1、监听事件"><a href="#1、监听事件" class="headerlink" title="1、监听事件"></a>1、监听事件</h2><p>我们可以使用 v-on 指令 (通常缩写为 @ 符号) 来监听 DOM 事件，并在触发事件时执行一些 JavaScript。用法为 <strong>v-on:click&#x3D;”methodName”</strong> 或使用简写方式 <strong>@click&#x3D;”methodName”</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">counter</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 绑定事件 直接通过js代码处理 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;counter++&quot;</span>&gt;</span>&#123;&#123; counter &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue10.png"></p><blockquote><p>注意：​ Vue支持html中所有已知事件. 如: @click, @submit等</p></blockquote><h2 id="2、事件处理方法"><a href="#2、事件处理方法" class="headerlink" title="2、事件处理方法"></a>2、事件处理方法</h2><p><strong>然而许多事件处理逻辑会更为复杂</strong>，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">counter</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">addCounter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span>++</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 绑定事件 没有传递参数 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addCounter&quot;</span>&gt;</span>&#123;&#123; counter &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue11.png"></p><h2 id="3、内联处理器中的方法"><a href="#3、内联处理器中的方法" class="headerlink" title="3、内联处理器中的方法"></a>3、内联处理器中的方法</h2><p>有时也需要在内联语句处理器中访问<strong>原始的 DOM 事件</strong>。可以用特殊变量 $event 把它传入方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">counter</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">addCounter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span>++</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">addC</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value, e</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span> += value</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 传递参数 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>1、传递参数<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addC(5)&quot;</span>&gt;</span>&#123;&#123; counter &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 绑定事件 传递参数和事件对象 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>2、绑定事件 传递参数和事件对象<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addC(5, $event)&quot;</span>&gt;</span>&#123;&#123; counter &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 一个事件，绑定多个处理函数 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>3、一个事件，绑定多个处理函数<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addC(10, $event), addCounter()&quot;</span>&gt;</span>&#123;&#123; counter &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue12.png"></p><blockquote><p>注意：事件处理程序中可以有多个方法，这些方法由逗号运算符分隔，并且方法都要加上()</p></blockquote><h2 id="4、事件修饰符"><a href="#4、事件修饰符" class="headerlink" title="4、事件修饰符"></a>4、事件修饰符</h2><p>在事件处理程序中调用 <strong>event.preventDefault()</strong> 或 <strong>event.stopPropagation()</strong> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：<strong>方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节</strong>。</p><p>为了解决这个问题，Vue.js 为 v-on 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p><ul><li>.stop 阻止单击事件继续冒泡</li><li>.prevent 阻止默认行为 提交事件不再重载页面</li><li>.capture 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理</li><li>.self 即事件不是从内部元素触发的</li><li>.once 触发一次回调</li><li>.passive 滚动事件的默认行为 (即滚动行为) 将会立即触发</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">divClick</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;父属性&quot;</span>);</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">btnClick</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;子属性&quot;</span>);</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">submitClick</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;prevent事件&quot;</span>);</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">onceClick</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;once事件&quot;</span>);</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 事件修饰符 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- .stop阻止单击事件继续冒泡, 就是我只会触犯当前的单击事件，外面嵌套的事件不会再一起触发 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;divClick&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- .prevent 阻止默认行为 input 取消提交summit行为，改为处理我的click事件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">&quot;submitClick&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- .once 只触发一次回调 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.once</span>=<span class="hljs-string">&quot;onceClick&quot;</span>&gt;</span>once按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue13.png"><br><strong>官方文档的样例：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 阻止单击事件继续冒泡 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;doThis&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>=<span class="hljs-string">&quot;onSubmit&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click.stop.prevent</span>=<span class="hljs-string">&quot;doThat&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 只有修饰符 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span><br><span class="hljs-comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click.capture</span>=<span class="hljs-string">&quot;doThis&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span><br><span class="hljs-comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click.self</span>=<span class="hljs-string">&quot;doThat&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click.once</span>=<span class="hljs-string">&quot;doThis&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 @click.prevent.self 会阻止元素本身及其子元素的点击的默认行为，而 @click.self.prevent 只会阻止对元素自身的点击的默认行为。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发，   --&gt;</span><br><span class="hljs-comment">&lt;!-- 而不会等待 `onScroll` 完成，                    --&gt;</span><br><span class="hljs-comment">&lt;!-- 以防止其中包含 `event.preventDefault()` 的情况  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">scroll.passive</span>=<span class="hljs-string">&quot;onScroll&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个 .passive 修饰符尤其能够提升移动端的性能。</p><blockquote><p><strong>注意</strong>：不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。</p></blockquote><h2 id="5、按键修饰符"><a href="#5、按键修饰符" class="headerlink" title="5、按键修饰符"></a>5、按键修饰符</h2><p>在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许为 <strong>v-on</strong> 或者 <strong>@</strong> 在监听键盘事件时添加按键修饰符：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">keyUp</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;keyUp事件&quot;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- .&#123;keyCode (键盘编码)&#125; | keyAlias(键盘简写) 监听键盘某个键的动作 .enter回车才会触发事件函数--&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&quot;keyUp&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue14.png"></p><h3 id="1）按键别名"><a href="#1）按键别名" class="headerlink" title="1）按键别名"></a>1）按键别名</h3><p>Vue 为最常用的键提供了别名：</p><ul><li>.enter</li><li>.tab</li><li>.delete (捕获“删除”和“退格”键)</li><li>.esc</li><li>.space</li><li>.up</li><li>.down</li><li>.left</li><li>.right</li></ul><h1 id="七、计算属性和侦听器watch"><a href="#七、计算属性和侦听器watch" class="headerlink" title="七、计算属性和侦听器watch"></a>七、计算属性和侦听器watch</h1><h2 id="1、计算属性"><a href="#1、计算属性" class="headerlink" title="1、计算属性"></a>1、计算属性</h2><p><strong>概述</strong>：计算属性可以看做一个提前定义好的方法, 该方法可以看作是一个<strong>特殊的值</strong>, 可以在插值表达式中使用。<br><strong>例子</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello vue&quot;</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">computed</span>: &#123;<span class="hljs-comment">//计算属性 依赖值发生改变，才会重新计算，计算完会缓存</span></span><br><span class="language-javascript">    <span class="hljs-attr">reverseMsg</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;计算属性&quot;</span>);</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">reverseMessage</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;methods&quot;</span>);</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- js表达式 总共计算两次 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>1、js表达式 总共计算两次<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-once</span>&gt;</span>v-once:&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 计算属性 计算一次 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>2、计算属性 计算一次<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; reverseMsg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-once</span>&gt;</span>v-once:&#123;&#123; reverseMsg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- methods方法 计算两次 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>3、methods方法 计算两次<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; reverseMessage() &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-once</span>&gt;</span>v-once:&#123;&#123; reverseMessage() &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;message = &#x27;勇敢牛牛&#x27;&quot;</span>&gt;</span>改变message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue15.png"></p><blockquote><p>这里声明了一个<strong>计算属性</strong> reverseMsg。<br><strong>尝试更改应用程序 data 中 message 数组的值，你将看到 reverseMsg如何相应地更改。</strong><br>你可以像普通属性一样将数据绑定到模板中的计算属性。Vue 知道 reverseMsg 依赖于 message ，因此当message  发生改变时，所有依赖 reverseMsg  的绑定也会更新。而且最妙的是我们以声明的方式创建了这个依赖关系：计算属性的 <strong>getter 函数</strong>没有副作用，它更易于测试和理解。</p></blockquote><h3 id="1）计算属性缓存-vs-方法"><a href="#1）计算属性缓存-vs-方法" class="headerlink" title="1）计算属性缓存 vs 方法"></a>1）计算属性缓存 vs 方法</h3><p>我们发现方法和计算属性都能达到同样的效果，不同的是<strong>计算属性</strong>将基于它们的响应依赖关系缓存。计算属性只会在相关响应式依赖发生改变时重新求值。这就意味着只要 message  还没有发生改变，多次访问 reverseMsg 时计算属性会立即返回<strong>之前的计算结果，而不必再次执行函数</strong>。</p><blockquote><p>简而言之，就是<strong>方法</strong>每次调用，都要运行一遍方法里的语句，而计算属性，只有在相关响应式依赖值发生改变，才会重新计算，计算完会重新缓存，不改变时，则直接返回之前的计算结果，大大节省了渲染时间。</p></blockquote><ul><li><p><strong>我们为什么需要缓存</strong>？</p></li><li><p>假设我们有一个性能开销比较大的计算属性 list，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 list。如果没有缓存，我们将不可避免的多次执行 list 的 getter！如果你不希望有缓存，请用 <strong>method</strong> 来替代。</p></li></ul><h3 id="2）计算属性的-Setter"><a href="#2）计算属性的-Setter" class="headerlink" title="2）计算属性的 Setter"></a>2）计算属性的 Setter</h3><p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello vue&quot;</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">computed</span>: &#123;<span class="hljs-comment">//计算属性 依赖值发生改变，才会重新计算，计算完会缓存</span></span><br><span class="language-javascript">    <span class="hljs-comment">//每个计算属性中都有一个getter和setter方法</span></span><br><span class="language-javascript">    <span class="hljs-comment">//完整的写法</span></span><br><span class="language-javascript">    <span class="hljs-attr">reverseMsg</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">      <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">newValue</span>) &#123;<span class="hljs-comment">//设置和更改计算属性的时候调用</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newValue);</span><br><span class="language-javascript">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = newValue</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">reverseMessage</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;methods&quot;</span>);</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- js表达式 总共计算两次 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>1、js表达式 总共计算两次<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-once</span>&gt;</span>v-once:&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 计算属性 计算一次 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>2、计算属性 计算一次<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; reverseMsg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-once</span>&gt;</span>v-once:&#123;&#123; reverseMsg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- methods方法 计算两次 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>3、methods方法 计算两次<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; reverseMessage() &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-once</span>&gt;</span>v-once:&#123;&#123; reverseMessage() &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;message = &#x27;勇敢牛牛&#x27;&quot;</span>&gt;</span>改变message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;reverseMsg = &#x27;勇敢牛牛&#x27;&quot;</span>&gt;</span>改变message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue16.png"></p><p>现在再运行下面的按钮 reverseMsg &#x3D; ‘勇敢牛牛’ 时，setter 会被调用，message 也会相应地被更新。</p><h2 id="2、侦听器"><a href="#2、侦听器" class="headerlink" title="2、侦听器"></a>2、侦听器</h2><p><strong>概述</strong>：侦听器可以监听简单属性值及其对象中属性值的变化。</p><blockquote><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p></blockquote><p>侦听器watch：</p><ol><li>当被监视的数据变化时，回调函数自动调用，进行相关操作</li><li><strong>监视的数据</strong>必须存在，才能进行监视</li></ol><p><strong>基本例子</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;你好&quot;</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">watch</span>: &#123; <span class="hljs-comment">//监听数据的变化</span></span><br><span class="language-javascript">    <span class="hljs-comment">//message发生改变，就会调用这个函数</span></span><br><span class="language-javascript">    <span class="hljs-attr">message</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">newValue, oldValue</span>) &#123;<span class="hljs-comment">//一个数据影响多个数据</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newValue);</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oldValue);</span><br><span class="language-javascript">      <span class="hljs-comment">//执行异步操作，或者复杂逻辑代码</span></span><br><span class="language-javascript">      <span class="hljs-keyword">if</span> (newValue.<span class="hljs-property">length</span> &lt; <span class="hljs-number">5</span> || newValue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">10</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;输入框中的内容长度必须在5-10位&quot;</span>);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- v-model 数据双向绑定 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue17.png"><br>在这个示例中，使用 watch 选项允许我们执行异步操作 (访问一个 API)，并设置一个执行该操作的条件。这些都是计算属性无法做到的。</p><p>除了 watch 选项之外，你还可以使用命令式的 vm.$watch API。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.$watch(<span class="hljs-string">&#x27;isHot&#x27;</span>,&#123;<br><span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<br><span class="hljs-title function_">handler</span>(<span class="hljs-params">newValue,oldValue</span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;isHot被修改了&#x27;</span>,newValue,oldValue)<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="1）计算属性-vs-侦听器"><a href="#1）计算属性-vs-侦听器" class="headerlink" title="1）计算属性 vs 侦听器"></a>1）计算属性 vs 侦听器</h3><p>Vue 提供了一种更通用的方式来观察和响应当前活动的实例上的数据变动：&#x3D;&#x3D;<strong>侦听属性</strong>&#x3D;&#x3D;。当你有一些数据需要随着其它数据变动而变动时，watch 很容易被滥用——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。</p><h3 id="2）深度监听"><a href="#2）深度监听" class="headerlink" title="2）深度监听"></a>2）深度监听</h3><p>深度监听：</p><ol><li>Vue中的watch默认不监听<strong>对象内部值</strong>的改变。</li><li>在watch中配置<strong>deep:true</strong>可以<strong>逐层监听</strong>对象内部值的改变。</li></ol><blockquote><p>注意：</p><ol><li>Vue自身可以监听对象内部值的改变，但Vue提供的watch默认不可以。</li><li>使用watch时根据监听数据的具体结构，决定是否采用深度监听deep。</li><li>如果使用deep逐层监听是会监听对象内部所有属性，如果单独监听需要<br>“监听对象.监听属性”: function (newName) {<br>  执行语句<br>}</li></ol></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;你好&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">user</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;linzy&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">age</span>: <span class="hljs-number">23</span>,</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">watch</span>: &#123; <span class="hljs-comment">//监听数据的变化</span></span><br><span class="language-javascript">    <span class="hljs-comment">//监听不到对象属性user.name的变化，需要深度监听deep</span></span><br><span class="language-javascript">    <span class="hljs-attr">user</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">handler</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">newName</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我是深度监听，监听所有对象user里的所有属性&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newName);</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">      <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span><span class="hljs-comment">//表示是否深度监听，侦听器会一层层向下遍历，给每个对象每个属性都加上侦听器</span></span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-comment">//单独监听user.name</span></span><br><span class="language-javascript">    <span class="hljs-string">&quot;user.name&quot;</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">newName</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我是单独监听user.name&quot;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; user.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; user.age &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;user.name = &#x27;hello vue&#x27;&quot;</span>&gt;</span>改变名字<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;user.age = 18&quot;</span>&gt;</span>改变年龄<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue18.png"></p><h1 id="八、Class-与-Style-绑定"><a href="#八、Class-与-Style-绑定" class="headerlink" title="八、Class 与 Style 绑定"></a>八、Class 与 Style 绑定</h1><p>操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 <strong>v-bind</strong> 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 <strong>v-bind</strong> 用于 <strong>class</strong> 和 <strong>style</strong> 时，Vue.js 做了专门的增强。表达式结果的类型除了<strong>字符串</strong>之外，还可以是<strong>对象或数组</strong>。</p><h2 id="1、绑定-HTML-Class"><a href="#1、绑定-HTML-Class" class="headerlink" title="1、绑定 HTML Class"></a>1、绑定 HTML Class</h2><h3 id="1）对象语法"><a href="#1）对象语法" class="headerlink" title="1）对象语法"></a>1）对象语法</h3><p>我们可以传给 :class (v-bind:class 的简写) 一个对象，以动态地切换 class：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;active&quot;</span>&gt;</span>hello vue<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的语法表示 active 这个 class 存在与否将取决于 data property 里的 active 是true还是false。</p><p>你可以在对象中传入更多字段来动态切换多个 class。此外，:class 指令也可以与普通的 class attribute 共存。当有如下模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123; active: isActive, hellovue: !isActive &#125;&quot;</span>&gt;</span>hello vue<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h3><p>我们可以把一个数组传给 :class，以应用一个 class 列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">classObj</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">active</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">hellovue</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 数组语法 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;classObj&quot;</span>&gt;</span>hello vue<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 与普通类同时存在不会冲突 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123; active: isActive &#125;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hellovue&quot;</span>&gt;</span>hello vue<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.active</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">61px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.hellovue</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">color</span>: greenyellow;</span><br><span class="language-css">  <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue19.png"></p><h3 id="3）基本例子"><a href="#3）基本例子" class="headerlink" title="3）基本例子"></a>3）基本例子</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hellovue&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">isActive</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">classObj</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">active</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">hellovue</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">      <span class="hljs-attr">activeClass</span>: <span class="hljs-string">&quot;active&quot;</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">computed</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">classObjCom</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">active</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">isActive</span> &amp;&amp; !<span class="hljs-variable language_">this</span>.<span class="hljs-property">error</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">hellovue</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">error</span></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 放置字符串 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>1、放置字符串<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;active&quot;</span>&gt;</span>hello vue<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 放置对象 常用 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>2、放置对象 常用<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;p :class=&quot;&#123; 类名: boolean &#125;&quot;&gt;hello vue&lt;/p&gt; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;</span>hello vue<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123; active: isActive, hellovue: isActive &#125;&quot;</span>&gt;</span>hello vue<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;isActive = !isActive&quot;</span>&gt;</span>改变class<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 数组语法 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>3、数组语法<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;classObj&quot;</span>&gt;</span>hello vue<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 与普通类同时存在不会冲突 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>4、与普通类同时存在不会冲突<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123; active: isActive &#125;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hellovue&quot;</span>&gt;</span>hello vue<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用计算属性 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>5、使用计算属性<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;classObjCom&quot;</span>&gt;</span>hello computed<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 数组表示 不常用 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>6、数组表示 不常用<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[message, activeClass]&quot;</span>&gt;</span>hello slice<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 数组和对象结合使用 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>7、数组和对象结合使用<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[message, &#123; active: isActive &#125;]&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.active</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">61px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.hellovue</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">color</span>: greenyellow;</span><br><span class="language-css">  <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue20.png"><br><img src="/img/vueIntroductory/vue21.png"></p><h2 id="2、绑定内联样式"><a href="#2、绑定内联样式" class="headerlink" title="2、绑定内联样式"></a>2、绑定内联样式</h2><h3 id="1）对象语法-1"><a href="#1）对象语法-1" class="headerlink" title="1）对象语法"></a>1）对象语法</h3><p>style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用<strong>驼峰式</strong> (camelCase) 或<strong>短横线分隔</strong> (kebab-case，记得用<strong>引号括起来</strong>) 来命名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span>hello vue<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2）数组语法"><a href="#2）数组语法" class="headerlink" title="2）数组语法"></a>2）数组语法</h3><p>:style 的数组语法可以将多个样式对象应用到同一个元素上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">styleObj</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;red&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&quot;51px&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-string">&#x27;background-color&#x27;</span>: <span class="hljs-string">&quot;yellow&quot;</span>,</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;[styleObj, &#123; border: &#x27;blue 10px solid&#x27; &#125;]&quot;</span>&gt;</span>hello vue<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue22.png"></p><h3 id="3）基本例子-1"><a href="#3）基本例子-1" class="headerlink" title="3）基本例子"></a>3）基本例子</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">activeColor</span>: <span class="hljs-string">&quot;greenyellow&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&quot;61px&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&quot;pink&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">styleObj</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;red&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&quot;51px&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-string">&#x27;background-color&#x27;</span>: <span class="hljs-string">&quot;yellow&quot;</span>,</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>1、对象语法<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span>hello vue<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>2、对象语法 与数据双向绑定 实现对style样式的控制<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; color: activeColor, fontSize: fontSize, &#x27;background-color&#x27;: backgroundColor &#125;&quot;</span>&gt;</span>hello vue<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>3、对象语法 用对象来绑定样式<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;styleObj&quot;</span>&gt;</span>hello vue<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>4、数组语法<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;[styleObj, &#123; border: &#x27;blue 10px solid&#x27; &#125;]&quot;</span>&gt;</span>hello vue<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue23.png"></p><h1 id="九、v-if条件渲染"><a href="#九、v-if条件渲染" class="headerlink" title="九、v-if条件渲染"></a>九、v-if条件渲染</h1><h2 id="1、v-if"><a href="#1、v-if" class="headerlink" title="1、v-if"></a>1、v-if</h2><p><strong>v-if</strong> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 <strong>truthy</strong> 值的时候被渲染。</p><blockquote><p>简而言之，v-if 条件为false时，对应的元素以及子元素都不会被渲染，控制dom元素的创建和销毁，运行时条件很少改变，一次性</p></blockquote><p> <strong>写法</strong>：</p><ol><li>v-if&#x3D;”表达式”</li><li>v-else-if&#x3D;”表达式”</li><li>v-else</li></ol><p><strong>适用于</strong>：切换频率较低的场景</p><p> <strong>特点</strong>：不展示的DOM元素直接被移除</p><blockquote><p>注意：v-if可以和v-else-if、v-else一起使用，但要求结构不能被打断</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- v-if --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;age &gt; 18&quot;</span>&gt;</span>我是成年人<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;age == 18&quot;</span>&gt;</span>我正好18岁<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else</span>&gt;</span>我是小孩子<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue24.png"></p><h2 id="2、v-show"><a href="#2、v-show" class="headerlink" title="2、v-show"></a>2、v-show</h2><p> v-show 指令与v-if 指令用法大致一样：</p><blockquote><p>带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 display CSS property 频繁切换状态</p></blockquote><p><strong>写法</strong>：v-show&#x3D;”表达式”</p><p><strong>适用于</strong>：切换频率较高的场景</p><p><strong>特点</strong>：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;man&#x27;</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- v-show --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;sex == &#x27;man&#x27;&quot;</span>&gt;</span>男生<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;sex == &#x27;woman&#x27;&quot;</span>&gt;</span>女生<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue25.png"></p><h2 id="3、v-if-vs-v-show"><a href="#3、v-if-vs-v-show" class="headerlink" title="3、v-if vs v-show"></a>3、v-if vs v-show</h2><p><strong>v-if</strong> 是“真正”的<strong>条件渲染</strong>，因为它会确保在切换过程中，条件块内的事件监听器和子组件适当地被销毁和重建。</p><p><strong>v-if</strong> 也是<strong>惰性</strong>的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，<strong>v-show</strong> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，<strong>v-if</strong> 有更高的切换开销，而 <strong>v-show</strong> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <strong>v-show</strong> 较好；如果在运行时条件很少改变，则使用 <strong>v-if</strong> 较好。</p><h1 id="十、v-for列表渲染"><a href="#十、v-for列表渲染" class="headerlink" title="十、v-for列表渲染"></a>十、v-for列表渲染</h1><p><strong>v-for指令</strong>：</p><ol><li>用于展示列表数据</li><li>语法：&lt; li v-for&#x3D;”(item, index) in xxx” :key&#x3D;”yyy”&gt;，其中key可以是index下标索引，也可以是<strong>遍历对象的唯一标识</strong></li><li>可遍历：数组、对象、字符串（用的少）、指定次数（用的少）</li></ol><h2 id="1、遍历数组"><a href="#1、遍历数组" class="headerlink" title="1、遍历数组"></a>1、遍历数组</h2><p>我们可以用 <strong>v-for</strong> 指令基于一个数组来渲染一个列表。<strong>v-for</strong> 指令需要使用 <strong>item in items</strong> 形式的特殊语法，其中 <strong>items</strong> 是源数据数组，而 <strong>item</strong> 则是被迭代的数组元素的别名。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">person</span>: [<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>],</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- v-for遍历数组 item表示数组中的每个元素 index表示数组下标 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in person&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in person&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125; -- &gt; &#123;&#123; index &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue26.png"></p><h2 id="2、遍历对象"><a href="#2、遍历对象" class="headerlink" title="2、遍历对象"></a>2、遍历对象</h2><p>可以用 v-for 来遍历一个对象的 property。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">personObj</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;linzy&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;男&quot;</span></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- v-for遍历对象 name表示键名, value是键值 index是下标--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in personObj&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, name, index)  of personObj&quot;</span>&gt;</span>&#123;&#123; name &#125;&#125; -- &gt; &#123;&#123; value &#125;&#125; -- &gt; &#123;&#123; index &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue27.png"></p><blockquote><p>在遍历对象时，会按 Object.keys() 的结果遍历，但是不能保证它在不同 JavaScript 引擎下的结果都一致。</p></blockquote><h2 id="3、维护状态"><a href="#3、维护状态" class="headerlink" title="3、维护状态"></a>3、维护状态</h2><p>当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“<strong>就地更新</strong>”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。</p><p>这个默认的模式是高效的，但是只<strong>适用于不依赖子组件状态或临时 DOM 状态</strong> (例如：表单输入值) 的列表渲染输出。</p><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一的 key attribute：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">person</span>: [<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>],</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">addPerson</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">&quot;linzy&quot;</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一的 key attribute --&gt;</span><br>    <span class="hljs-comment">&lt;!-- key是唯一标识，不加key不会报错，但是如果多选框选中时数组增加，那勾选的位置不会发生改变，勾选值会出错 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 快速找到结点，减少渲染次数，提高渲染性能 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in person&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addPerson&quot;</span>&gt;</span>添加数组<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue28.png"><br><strong>建议尽可能在使用 v-for 时提供 key attribute</strong>，除非遍历输出的 DOM 内容非常简单，或者是<strong>刻意依赖默认行为</strong>以获取性能上的提升。</p><p>因为它是 Vue 识别节点的一个通用机制，key 并不仅与 v-for 特别关联。后面我们将在指南中看到，它还具有其它用途。</p><blockquote><p>提示：不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。</p></blockquote><h2 id="4、数组更新检测"><a href="#4、数组更新检测" class="headerlink" title="4、数组更新检测"></a>4、数组更新检测</h2><h3 id="1）变更方法"><a href="#1）变更方法" class="headerlink" title="1）变更方法"></a>1）变更方法</h3><p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p><ul><li>push() 数组末尾增加单个或多个元素</li><li>pop()  删除数组末尾元素</li><li>shift() 删除数组首位元素</li><li>unshift() 数组首部增加单个或多个元素</li><li>splice() 可以插入元素，删除元素，替换元素</li><li>sort() 从小到大排序</li><li>reverse() 数组翻转</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">list</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>]</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">changeList</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">//下标索引值改变数组</span></span><br><span class="language-javascript">      <span class="hljs-comment">// this.list[6] = 99</span></span><br><span class="language-javascript">      <span class="hljs-comment">// push() 数组末尾增加单个或多个元素</span></span><br><span class="language-javascript">      <span class="hljs-comment">// this.list.push(99, 98, 97)</span></span><br><span class="language-javascript">      <span class="hljs-comment">// pop() 删除数组末尾元素</span></span><br><span class="language-javascript">      <span class="hljs-comment">// this.list.pop()</span></span><br><span class="language-javascript">      <span class="hljs-comment">// shift() 删除数组首位元素</span></span><br><span class="language-javascript">      <span class="hljs-comment">// this.list.shift()</span></span><br><span class="language-javascript">      <span class="hljs-comment">// unshift() 数组首部增加单个或多个元素</span></span><br><span class="language-javascript">      <span class="hljs-comment">// this.list.unshift(5, 6, 7)</span></span><br><span class="language-javascript">      <span class="hljs-comment">// splice() 可以插入元素，删除元素，替换元素</span></span><br><span class="language-javascript">      <span class="hljs-comment">//第一个参数是插入、删除或者替换元素的下标位置</span></span><br><span class="language-javascript">      <span class="hljs-comment">//删除元素 只需要两个参数 1.下标位置 2.删除元素数量</span></span><br><span class="language-javascript">      <span class="hljs-comment">//第二个参数是删除元素数量</span></span><br><span class="language-javascript">      <span class="hljs-comment">// this.list.splice(1, 3)</span></span><br><span class="language-javascript">      <span class="hljs-comment">//插入元素 1.下标位置2.第二个参数为0，3.插入单个或多个元素</span></span><br><span class="language-javascript">      <span class="hljs-comment">// this.list.splice(1, 0, 99, 98, 97)</span></span><br><span class="language-javascript">      <span class="hljs-comment">//替换元素 1.下标位置2.第二个参数为替换元素的数量，3.替换的元素</span></span><br><span class="language-javascript">      <span class="hljs-comment">// this.list.splice(1, 3, 99, 98, 97)</span></span><br><span class="language-javascript">      <span class="hljs-comment">// sort() 从小到大排序</span></span><br><span class="language-javascript">      <span class="hljs-comment">// this.list.sort()</span></span><br><span class="language-javascript">      <span class="hljs-comment">// reverse() 数组翻转</span></span><br><span class="language-javascript">      <span class="hljs-comment">// this.list.reverse()</span></span><br><span class="language-javascript">      <span class="hljs-comment">//从大到小排序</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">sort</span>().<span class="hljs-title function_">reverse</span>()</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span>&gt;</span> &#123;&#123; item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeList&quot;</span>&gt;</span>改变数组<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>&lt;/template &gt;<br><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue29.png"></p><h1 id="十一、v-model数据绑定"><a href="#十一、v-model数据绑定" class="headerlink" title="十一、v-model数据绑定"></a>十一、v-model数据绑定</h1><h2 id="1、基本用法"><a href="#1、基本用法" class="headerlink" title="1、基本用法"></a>1、基本用法</h2><p>你可以用 v-model 指令在表单 &lt; input &gt;、&lt; textarea &gt; 及 &lt; select &gt; 元素上创建<strong>双向数据绑定</strong>。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是<strong>语法糖</strong>。它负责监听用户的输入事件来更新数据，并在某种极端场景下进行一些特殊处理。</p><blockquote><p>提示：<br>v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值。它将始终将当前活动实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。</p></blockquote><p><strong>v-model</strong> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 <strong>value</strong> property 和 <strong>input</strong> 事件；</li><li>checkbox 和 radio 使用 <strong>checked</strong> property 和 <strong>change</strong> 事件；</li><li>select 字段将 <strong>value</strong> 作为 prop 并将 <strong>change</strong> 作为事件。</li></ul><p><strong>例子</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello vue&quot;</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">changeValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- v-model 双向绑定 文本框 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">      v-model本质操作：</span><br><span class="hljs-comment">      1.v-bind绑定一个value属性</span><br><span class="hljs-comment">      2.v-on给当前元素添加一个input属性</span><br><span class="hljs-comment">     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;message&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;changeValue&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue30.png"></p><h3 id="1）文本-Text"><a href="#1）文本-Text" class="headerlink" title="1）文本 (Text)"></a>1）文本 (Text)</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- v-model 双向绑定 文本框 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2）多行文本-Textarea"><a href="#2）多行文本-Textarea" class="headerlink" title="2）多行文本 (Textarea)"></a>2）多行文本 (Textarea)</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Multiline message is:<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;white-space: pre-line;&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;add multiple lines&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：插值在 textarea 中不起作用，请使用 v-model 来代替。</p></blockquote><h3 id="3）复选框-Checkbox"><a href="#3）复选框-Checkbox" class="headerlink" title="3）复选框 (Checkbox)"></a>3）复选框 (Checkbox)</h3><p><strong>单个复选框，绑定到布尔值</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 复选框 --&gt;</span><br>   <span class="hljs-comment">&lt;!-- 单个勾选框, v-model为布尔值 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checked&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>多个复选框，绑定到同一个数组</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 多个勾选框 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;fruits&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;苹果&quot;</span>&gt;</span>苹果<br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;fruits&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;梨&quot;</span>&gt;</span>梨<br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;fruits&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;西瓜&quot;</span>&gt;</span>西瓜<br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;fruits&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;香蕉&quot;</span>&gt;</span>香蕉<br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;fruits&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;哈密瓜&quot;</span>&gt;</span>哈密瓜<br>   <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>喜欢的水果&#123;&#123; fruits &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4）单选框-Radio"><a href="#4）单选框-Radio" class="headerlink" title="4）单选框 (Radio)"></a>4）单选框 (Radio)</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 单选框 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span>&gt;</span> 男<br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span>&gt;</span> 女<br>   <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; sex &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5）选择框-Select"><a href="#5）选择框-Select" class="headerlink" title="5）选择框 (Select)"></a>5）选择框 (Select)</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 多选 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;city&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;杭州&quot;</span>&gt;</span>杭州<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;嘉兴&quot;</span>&gt;</span>嘉兴<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;宁波&quot;</span>&gt;</span>宁波<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;台州&quot;</span>&gt;</span>台州<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;湖州&quot;</span>&gt;</span>湖州<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; city &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6）基本例子"><a href="#6）基本例子" class="headerlink" title="6）基本例子"></a>6）基本例子</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello vue&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">checked</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">fruits</span>: [],</span><br><span class="language-javascript">      <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;台州&#x27;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">counter</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">changeValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- v-model 双向绑定 文本框 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>1、v-model 双向绑定 文本框<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">      v-model本质操作：</span><br><span class="hljs-comment">      1.v-bind绑定一个value属性</span><br><span class="hljs-comment">      2.v-on给当前元素添加一个input属性</span><br><span class="hljs-comment">     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>2、v-model本质操作<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;message&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;changeValue&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 复选框 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 单个勾选框, v-model为布尔值 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>3、 单个勾选框, v-model为布尔值<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checked&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 多个勾选框 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>4、多个勾选框 v-model绑定的是数组<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;fruits&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;苹果&quot;</span>&gt;</span>苹果<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;fruits&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;梨&quot;</span>&gt;</span>梨<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;fruits&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;西瓜&quot;</span>&gt;</span>西瓜<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;fruits&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;香蕉&quot;</span>&gt;</span>香蕉<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;fruits&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;哈密瓜&quot;</span>&gt;</span>哈密瓜<br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>喜欢的水果&#123;&#123; fruits &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 单选框 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>5、单选框<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span>&gt;</span> 男<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span>&gt;</span> 女<br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; sex &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 多选 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>6、多选select<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;city&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;杭州&quot;</span>&gt;</span>杭州<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;嘉兴&quot;</span>&gt;</span>嘉兴<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;宁波&quot;</span>&gt;</span>宁波<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;台州&quot;</span>&gt;</span>台州<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;湖州&quot;</span>&gt;</span>湖州<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; city &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue31.png"></p><h2 id="2、修饰符"><a href="#2、修饰符" class="headerlink" title="2、修饰符"></a>2、修饰符</h2><p>修饰符：</p><ul><li>.lazy</li><li>.number</li><li>.trim</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//声明式渲染，可以提高开发效率</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello vue&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">counter</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">changeValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 修饰符的使用 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- .lazy 当输入框失去焦点，再去同步输入框中的数据 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>.lazy 当输入框失去焦点，再去同步输入框中的数据<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- .number将输入框的内容自动转为数字类型 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>.number将输入框的内容自动转为数字类型<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;counter&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; typeof counter &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- .trim 自动过滤用户输入的首尾空白字符 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>.trim 自动过滤用户输入的首尾空白字符<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.trim</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/vueIntroductory/vue32.png"></p>]]></content>
    
    
    <categories>
      
      <category>Vue学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>Vue</tag>
      
      <tag>前端</tag>
      
      <tag>js</tag>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gin框架入门-Gin框架和Gorm框架搭建一个简单的API微服务</title>
    <link href="/2022/07/19/gin-gorm-API/"/>
    <url>/2022/07/19/gin-gorm-API/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章会用到的技术，不太熟悉的可以去看看我以前的文章</p><ol><li>快速安装gin框架：<a href="https://linzyblog.netlify.app/2022/07/18/gin/">https://linzyblog.netlify.app/2022/07/18/gin/</a></li><li>HTTP请求：<a href="https://linzyblog.netlify.app/2022/07/18/gin-http/">https://linzyblog.netlify.app/2022/07/18/gin-http/</a></li><li>Gorm入门指南：<a href="https://linzyblog.netlify.app/2022/07/19/gin-gorm1/">https://linzyblog.netlify.app/2022/07/19/gin-gorm1/</a></li><li>GORM框架进阶之CRUD接口(数据库增删改查操作)：<a href="https://linzyblog.netlify.app/2022/07/19/gin-gorm2/">https://linzyblog.netlify.app/2022/07/19/gin-gorm2/</a></li></ol><h1 id="一、设计思路"><a href="#一、设计思路" class="headerlink" title="一、设计思路"></a>一、设计思路</h1><p>这章动手把前面学过的Gin框架内容和Gorm框架结合做一个简单的API 微服务</p><p><img src="/img/gin_gorm_API/gga1.png"></p><p>我们需要通过前端来完成对数据库数据的增删改查即可，需要如下这样的 API ：</p><blockquote><ol><li>POST todos&#x2F; <strong>添加数据</strong></li><li>GET todos&#x2F;<strong>获取数据库所有数据</strong></li><li>GET todos&#x2F;{id}<strong>获取指定 id 的数据</strong></li><li>PUT todos&#x2F;{id}<strong>修改指定 id 的数据</strong></li><li>DELETE todos&#x2F;{id}<strong>删除指定 id 的数据</strong></li></ol></blockquote><h1 id="二、编写后端请求"><a href="#二、编写后端请求" class="headerlink" title="二、编写后端请求"></a>二、编写后端请求</h1><p>创建一个 <strong>todos</strong> 文件夹，用VSCode打开当前文件夹</p><h2 id="1、在Terminal终端输入-go-mod"><a href="#1、在Terminal终端输入-go-mod" class="headerlink" title="1、在Terminal终端输入 go mod"></a>1、在Terminal终端输入 go mod</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> mod init todo<br></code></pre></td></tr></table></figure><blockquote><p>创建包管理工具，此命令会在当前目录中初始化和创建一个新的go.mod文件，手动创建go.mod文件再包含一些module声明也等同该命令，而go mod init命令便是帮我们简便操作，可以帮助我们自动创建。</p></blockquote><h2 id="2、下载并安装所需要的包"><a href="#2、下载并安装所需要的包" class="headerlink" title="2、下载并安装所需要的包"></a>2、下载并安装所需要的包</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get -u github.com/gin-gonic/gin<br><span class="hljs-keyword">go</span> get -u gorm.io/driver/mysql<br><span class="hljs-keyword">go</span> get -u gorm.io/gorm<br></code></pre></td></tr></table></figure><h2 id="3、创建路由"><a href="#3、创建路由" class="headerlink" title="3、创建路由"></a>3、创建路由</h2><p>在 todo 文件夹下创建一个名为 main.go 的文件，在 main 文件中创建一个类似下面的路由，将同一个功能模块放到同一个<strong>路由分组</strong>中，代码更美观易懂</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>router := gin.Default()<br>v1 := router.Group(<span class="hljs-string">&quot;/api/v1/todos&quot;</span>)<br>&#123;<br>v1.POST(<span class="hljs-string">&quot;/&quot;</span>, createTodo)<br>v1.GET(<span class="hljs-string">&quot;/&quot;</span>, fetchAllTodo)<br>v1.GET(<span class="hljs-string">&quot;/:id&quot;</span>, fetchSingleTodo)<br>v1.PUT(<span class="hljs-string">&quot;/:id&quot;</span>, updateTodo)<br>v1.DELETE(<span class="hljs-string">&quot;/:id&quot;</span>, deleteTodo)<br>&#125;<br>router.Run()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、数据库连接"><a href="#4、数据库连接" class="headerlink" title="4、数据库连接"></a>4、数据库连接</h2><p>现在我们要实现数据库连接就要用到<strong>GORM框架</strong>，GORM框架是go的一个<strong>数据库连接及交互框架</strong>，主要是把<strong>struct类型</strong>和<strong>数据库记录</strong>进行映射，数据库语句复杂的情况下可以直接手写语句，一般用于连接<strong>关系型数据库</strong>，这里我主要使用MySQL数据库。</p><h3 id="1）设计数据表"><a href="#1）设计数据表" class="headerlink" title="1）设计数据表"></a>1）设计数据表</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//数据库字段</span><br><span class="hljs-keyword">type</span> todoModel <span class="hljs-keyword">struct</span> &#123;<br>gorm.Model<br>Title     <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;title&quot;`</span><br>Completed <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;completed&quot;`</span><br>&#125;<br><br><span class="hljs-comment">//处理返回字段</span><br><span class="hljs-keyword">type</span> transformedTodo <span class="hljs-keyword">struct</span> &#123;<br>ID        <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;id&quot;`</span><br>Title     <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;title&quot;`</span><br>Completed <span class="hljs-type">bool</span>   <span class="hljs-string">`json:&quot;completed&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）数据库连接"><a href="#2）数据库连接" class="headerlink" title="2）数据库连接"></a>2）数据库连接</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;gorm.io/driver/mysql&quot;</span><br><span class="hljs-string">&quot;gorm.io/gorm&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> db *gorm.DB<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>dsn := <span class="hljs-string">&quot;root:123456@tcp(127.0.0.1:3306)/go_test?charset=utf8&amp;parseTime=True&quot;</span><br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>db, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err.Error())<br>&#125;<br><span class="hljs-comment">//自动创建数据表</span><br>db.AutoMigrate(&amp;todoModel&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、实现路由方法"><a href="#三、实现路由方法" class="headerlink" title="三、实现路由方法"></a>三、实现路由方法</h1><h2 id="1、创建一条记录"><a href="#1、创建一条记录" class="headerlink" title="1、创建一条记录"></a>1、创建一条记录</h2><p>使用到了 Gin 框架中的 Context 上下文来接收 POST 方式传过来的参数，用 Gorm框架 连接数据库使用Save方法或者Create方法都可以来保存相关的数据到数据库，之后会给前端用户返回一个 JSON信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//创建一条todo记录</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createTodo</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>completed, err := strconv.Atoi(c.PostForm(<span class="hljs-string">&quot;completed&quot;</span>))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err.Error())<br>&#125;<br>todo := todoModel&#123;<br>Title:     c.PostForm(<span class="hljs-string">&quot;title&quot;</span>),<br>Completed: completed,<br>&#125;<br>db.Save(&amp;todo)<br>c.JSON(http.StatusCreated, gin.H&#123;<br><span class="hljs-string">&quot;status&quot;</span>:     http.StatusCreated,<br><span class="hljs-string">&quot;message&quot;</span>:    <span class="hljs-string">&quot;Todo item created successfully&quot;</span>,<br><span class="hljs-string">&quot;resourceId&quot;</span>: todo.ID,<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>POST请求</li></ul><p><img src="/img/gin_gorm_API/gga2.png"></p><ul><li>数据库</li></ul><p><img src="/img/gin_gorm_API/gga3.png"></p><h2 id="2、查询所有记录"><a href="#2、查询所有记录" class="headerlink" title="2、查询所有记录"></a>2、查询所有记录</h2><p>使用到了 Gin 框架中的 GET 请求，没有参数，用 Gorm 框架连接数据库使用Find方法查询所有记录，封装在JSON里返回给前端用户</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//获取数据库所有todo</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selectAllTodo</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> todos []todoModel<br><span class="hljs-keyword">var</span> rq_todos []transformedTodo<br>db.Find(&amp;todos)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(todos) &lt;= <span class="hljs-number">0</span> &#123;<br>c.JSON(http.StatusNotFound, gin.H&#123;<br><span class="hljs-string">&quot;status&quot;</span>:  http.StatusNotFound,<br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;No todo found!&quot;</span>,<br>&#125;)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> todos &#123;<br>completed := <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> item.Completed == <span class="hljs-number">1</span> &#123;<br>completed = <span class="hljs-literal">true</span><br>&#125;<br>rq_todos = <span class="hljs-built_in">append</span>(rq_todos, transformedTodo&#123;<br>ID:        <span class="hljs-type">int</span>(item.ID),<br>Title:     item.Title,<br>Completed: completed,<br>&#125;)<br>&#125;<br>c.JSON(http.StatusOK, gin.H&#123;<br><span class="hljs-string">&quot;status&quot;</span>: http.StatusOK,<br><span class="hljs-string">&quot;data&quot;</span>:   rq_todos,<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>GET请求</li></ul><p><img src="/img/gin_gorm_API/gga4.png"></p><ul><li>数据库</li></ul><p><img src="/img/gin_gorm_API/gga5.png"></p><h2 id="3、查找指定id的记录"><a href="#3、查找指定id的记录" class="headerlink" title="3、查找指定id的记录"></a>3、查找指定id的记录</h2><p>使用到了 Gin 框架中的 Context 上下文来接收 GET 方式存放在URI里传过来的参数，用 Gorm 框架连接数据库使用Find方法或者First方法查询指定记录，封装在JSON里返回给前端用户</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//查找指定todo</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selectSingleTodo</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> todo todoModel<br>todoID := c.Param(<span class="hljs-string">&quot;id&quot;</span>)<br>db.First(&amp;todo, todoID)<br><span class="hljs-keyword">if</span> todo.ID == <span class="hljs-number">0</span> &#123;<br>c.JSON(http.StatusNotFound, gin.H&#123;<br><span class="hljs-string">&quot;status&quot;</span>:  http.StatusNotFound,<br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;No todo found!&quot;</span>,<br>&#125;)<br><span class="hljs-keyword">return</span><br>&#125;<br>completed := <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> todo.Completed == <span class="hljs-number">1</span> &#123;<br>completed = <span class="hljs-literal">true</span><br>&#125;<br>rp_todo := transformedTodo&#123;<br>ID:        <span class="hljs-type">int</span>(todo.ID),<br>Title:     todo.Title,<br>Completed: completed,<br>&#125;<br>c.JSON(http.StatusOK, gin.H&#123;<br><span class="hljs-string">&quot;status&quot;</span>: http.StatusOK,<br><span class="hljs-string">&quot;data&quot;</span>:   rp_todo,<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>GET请求</li></ul><p><img src="/img/gin_gorm_API/gga6.png"></p><h2 id="4、修改指定id记录"><a href="#4、修改指定id记录" class="headerlink" title="4、修改指定id记录"></a>4、修改指定id记录</h2><p>使用到了 Gin 框架中的 Context 上下文来接收 PUT 方式传过来的参数，用 Gorm 框架连接数据库使用Find方法或者First方法查询指定记录，然后通过Update方法修改记录，返回给前端用户<strong>修改成功</strong>信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//修改指定id todo</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">updateTodo</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> todo todoModel<br>todoID := c.Param(<span class="hljs-string">&quot;id&quot;</span>)<br>db.First(&amp;todo, todoID)<br><span class="hljs-keyword">if</span> todo.ID == <span class="hljs-number">0</span> &#123;<br>c.JSON(http.StatusNotFound, gin.H&#123;<br><span class="hljs-string">&quot;status&quot;</span>:  http.StatusNotFound,<br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;No todo found!&quot;</span>,<br>&#125;)<br><span class="hljs-keyword">return</span><br>&#125;<br>completed, _ := strconv.Atoi(c.PostForm(<span class="hljs-string">&quot;completed&quot;</span>))<br>db.Model(&amp;todo).Updates(&amp;todoModel&#123;<br>Title:     c.PostForm(<span class="hljs-string">&quot;title&quot;</span>),<br>Completed: completed,<br>&#125;)<br>c.JSON(http.StatusOK, gin.H&#123;<br><span class="hljs-string">&quot;status&quot;</span>:  http.StatusOK,<br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Todo updated successfully&quot;</span>,<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>PUT请求</li></ul><p><img src="/img/gin_gorm_API/gga7.png"></p><ul><li>数据库</li></ul><p><img src="/img/gin_gorm_API/gga8.png"></p><h2 id="5、删除指定id记录"><a href="#5、删除指定id记录" class="headerlink" title="5、删除指定id记录"></a>5、删除指定id记录</h2><p>使用到了 Gin 框架中的 Context 上下文来接收 DELETE 方式存放在URI里传过来的参数，用 Gorm 框架连接数据库使用First方法或者Find查询指定id记录，用Delete删除指定id记录，返回给前端用户<strong>删除成功</strong>信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//删除指定id todo</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteTodo</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> todo todoModel<br>todoID := c.Param(<span class="hljs-string">&quot;id&quot;</span>)<br>db.First(&amp;todo, todoID)<br><span class="hljs-keyword">if</span> todo.ID == <span class="hljs-number">0</span> &#123;<br>c.JSON(http.StatusNotFound, gin.H&#123;<br><span class="hljs-string">&quot;status&quot;</span>:  http.StatusNotFound,<br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;No todo found!&quot;</span>,<br>&#125;)<br><span class="hljs-keyword">return</span><br>&#125;<br>db.Delete(&amp;todo)<br>c.JSON(http.StatusOK, gin.H&#123;<br><span class="hljs-string">&quot;status&quot;</span>:  http.StatusOK,<br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;todo Deleted successfully&quot;</span>,<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>DELETE请求</li></ul><p><img src="/img/gin_gorm_API/gga9.png"></p><ul><li>数据库</li></ul><p><img src="/img/gin_gorm_API/gga10.png"></p><h1 id="四、结论"><a href="#四、结论" class="headerlink" title="四、结论"></a>四、结论</h1><p>这章只是把前面的基础的知识Gin框架和Gorm框架结合一起实现，日志、JWT认证和Casbin框架我还没用到，后面我将会学习gva框架把之前所学全部展现并结合出来</p>]]></content>
    
    
    <categories>
      
      <category>Gin框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>云原生</tag>
      
      <tag>gin，http</tag>
      
      <tag>postman</tag>
      
      <tag>网络协议</tag>
      
      <tag>微服务</tag>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gin框架入门-Casbin进阶之策略管理API使用方法</title>
    <link href="/2022/07/19/gin-Casbin2/"/>
    <url>/2022/07/19/gin-Casbin2/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Casbin-安装"><a href="#一、Casbin-安装" class="headerlink" title="一、Casbin 安装"></a>一、Casbin 安装</h1><h2 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get github.com/casbin/casbin/v2<br></code></pre></td></tr></table></figure><h2 id="2、在线编辑"><a href="#2、在线编辑" class="headerlink" title="2、在线编辑"></a>2、在线编辑</h2><p>您还可以使用在线编辑器 ( <a href="https://casbin.org/editor/">https://casbin.org/editor/</a> ) 在 Web 浏览器中编写您的 Casbin 模型和策略。 </p><h1 id="二、创建Casbin-enforcer"><a href="#二、创建Casbin-enforcer" class="headerlink" title="二、创建Casbin enforcer"></a>二、创建Casbin enforcer</h1><p>Casbin使用<strong>配置文件</strong>来设置访问控制模式。</p><p>它有两个配置文件，model.conf和policy.csv。 其中，model.conf存储了<strong>访问模型</strong>，policy.csv存储了<strong>特定的用户权限配置</strong>。 Casbin的使用非常精炼。 基本上，我们只需要一个主要结构：enforcer。 当构建这个结构时，model.conf和policy.csv将被加载。</p><p>换句话说，要新建一个Casbin enforcer，你必须提供一个Model和一个Adapter。</p><h2 id="1、Model-conf"><a href="#1、Model-conf" class="headerlink" title="1、Model.conf"></a>1、Model.conf</h2><p>Model规定了权限由 <strong>sub、obj、act</strong>三要素组成，只有在策略Policy列表中存在于请求Request完全相同的策略时，该请求才能通过。匹配器的结构通过 <strong>p.eft</strong> 获取， <strong>some(where (p.eft &#x3D;&#x3D; allow))</strong> 表示有任意一条 policy rule 满足, 则最终结果为 allow</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"># 请求<br># sub ——&gt; 想要访问资源的用户角色(Subject)——请求实体<br># obj ——&gt; 访问的资源(Object)<br># act ——&gt; 访问的方法(Action: get、post...)<br>[request_definition]<br>r = sub,obj,act<br><br><br># 策略(.csv文件p的格式，定义的每一行为policy rule;p为policy rule的名字。)<br>[policy_definition]<br>p = sub,obj,act<br><br><br># 策略效果<br>[policy_effect]<br>e = some(where (p.eft == allow))<br># 上面表示有任意一条 policy rule 满足, 则最终结果为 allow；p.eft它可以是allow或deny，它是可选的，默认是allow<br><br># 匹配器<br>[matchers]<br>m = r.sub == p.sub &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act<br></code></pre></td></tr></table></figure><h2 id="2、Policy-csv"><a href="#2、Policy-csv" class="headerlink" title="2、Policy.csv"></a>2、Policy.csv</h2><p>Policy表示谁能对什么资源进行什么操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">p, linzy, data1, read<br>p, hhh, data2, write<br></code></pre></td></tr></table></figure><p>linzy 对 资源 data1 有 read 权限<br>hhh 对 资源 data2 有 write 权限</p><h2 id="3、创建enforcer"><a href="#3、创建enforcer" class="headerlink" title="3、创建enforcer"></a>3、创建enforcer</h2><h3 id="1）创建"><a href="#1）创建" class="headerlink" title="1）创建"></a>1）创建</h3><p>NewEnforcer通过文件或DB创建一个enforcer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//使用Model文件和默认 FileAdapter</span><br>e := casbin.NewEnforcer(<span class="hljs-string">&quot;./test/model.conf&quot;</span>, <span class="hljs-string">&quot;./test/policy.csv&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="2）检查权限"><a href="#2）检查权限" class="headerlink" title="2）检查权限"></a>2）检查权限</h3><p>Enforce决定一个“subject”是否可以通过操作“action”访问一个“object”，输入参数通常是:(sub, obj, act)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">sub := <span class="hljs-string">&quot;linzy&quot;</span> <span class="hljs-comment">// 需要访问资源的用户。</span><br>obj := <span class="hljs-string">&quot;data1&quot;</span> <span class="hljs-comment">// 将要被访问的资源。</span><br>act := <span class="hljs-string">&quot;read&quot;</span>  <span class="hljs-comment">// 用户对资源的权限。</span><br><span class="hljs-comment">//Enforce决定一个“subject”是否可以通过操作“action”访问一个“object”，输入参数通常是:(sub, obj, act)</span><br>b := e.Enforce(sub, obj, act)<br><span class="hljs-keyword">if</span> b &#123;<br><span class="hljs-comment">// 允许 linzy 读取 data 1</span><br>fmt.Println(<span class="hljs-string">&quot;通过&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 拒绝请求，显示错误</span><br>fmt.Println(<span class="hljs-string">&quot;未通过&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/gin_Casbin2/csb1.png"></p><h1 id="三、策略管理操作"><a href="#三、策略管理操作" class="headerlink" title="三、策略管理操作"></a>三、策略管理操作</h1><h2 id="1、查询所有授权规则"><a href="#1、查询所有授权规则" class="headerlink" title="1、查询所有授权规则"></a>1、查询所有授权规则</h2><p>GetPolicy 获取策略中的所有授权规则。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//GetPolicy获取策略中的所有授权规则。</span><br>policy := e.GetPolicy()<br>fmt.Println(policy)<br></code></pre></td></tr></table></figure><p><img src="/img/gin_Casbin2/csb2.png"></p><h2 id="2、查询是否存在授权规则"><a href="#2、查询是否存在授权规则" class="headerlink" title="2、查询是否存在授权规则"></a>2、查询是否存在授权规则</h2><p>HasPolicy 确定是否存在授权规则。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//HasPolicy 确定是否存在授权规则。</span><br>hasPolicy := e.HasPolicy(<span class="hljs-string">&quot;linzy&quot;</span>, <span class="hljs-string">&quot;data1&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>)<br>fmt.Println(hasPolicy)<br>hasPolicy = e.HasPolicy(<span class="hljs-string">&quot;hhh&quot;</span>, <span class="hljs-string">&quot;data1&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>)<br>fmt.Println(hasPolicy)<br></code></pre></td></tr></table></figure><p><img src="/img/gin_Casbin2/csb3.png"></p><h2 id="3、添加授权规则"><a href="#3、添加授权规则" class="headerlink" title="3、添加授权规则"></a>3、添加授权规则</h2><p>AddPolicy 向当前策略添加授权规则。 如果规则已经存在，函数返回false，并且不会添加规则。 否则，函数通过添加新规则并返回true。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">policy := e.GetPolicy()<br>fmt.Println(policy)<br><span class="hljs-comment">//AddPolicy为当前策略添加一条授权规则。</span><br><span class="hljs-comment">//如果规则已经存在，函数返回false，规则不会被添加。</span><br><span class="hljs-comment">//否则函数通过添加新规则返回true。</span><br>added := e.AddPolicy(<span class="hljs-string">&quot;alice&quot;</span>, <span class="hljs-string">&quot;data3&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>)<br>fmt.Println(added)<br>policy = e.GetPolicy()<br>fmt.Println(policy)<br></code></pre></td></tr></table></figure><p><img src="/img/gin_Casbin2/csb4.png"></p><h2 id="4、删除授权规则"><a href="#4、删除授权规则" class="headerlink" title="4、删除授权规则"></a>4、删除授权规则</h2><p>RemovePolicy 从当前策略中删除授权规则。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">policy = e.GetPolicy()<br>fmt.Println(policy)<br><span class="hljs-comment">//RemovePolicy 从当前策略中删除授权规则。</span><br>removed := e.RemovePolicy(<span class="hljs-string">&quot;alice&quot;</span>, <span class="hljs-string">&quot;data1&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>)<br>fmt.Println(removed)<br>policy = e.GetPolicy()<br>fmt.Println(policy)<br></code></pre></td></tr></table></figure><p><img src="/img/gin_Casbin2/csb5.png"></p><h2 id="5、修改授权规则"><a href="#5、修改授权规则" class="headerlink" title="5、修改授权规则"></a>5、修改授权规则</h2><p>UpdatePolicy 把旧的政策更新到新的政策</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//UpdatePolicy 把旧的政策更新到新的政策</span><br>updated, err := e.UpdatePolicy([]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;eve&quot;</span>, <span class="hljs-string">&quot;data3&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>&#125;, []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;eve&quot;</span>, <span class="hljs-string">&quot;data3&quot;</span>, <span class="hljs-string">&quot;write&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><h1 id="四、MySQL数据库搭配Model文件"><a href="#四、MySQL数据库搭配Model文件" class="headerlink" title="四、MySQL数据库搭配Model文件"></a>四、MySQL数据库搭配Model文件</h1><h2 id="1、创建SQLAdapter"><a href="#1、创建SQLAdapter" class="headerlink" title="1、创建SQLAdapter"></a>1、创建SQLAdapter</h2><p>我这里使用的是MySQL</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-comment">//一定要选择casbin的v2版本 不然会报错</span><br><span class="hljs-string">&quot;github.com/casbin/casbin/v2&quot;</span><br>xormadapter <span class="hljs-string">&quot;github.com/casbin/xorm-adapter/v2&quot;</span><br>_ <span class="hljs-string">&quot;github.com/go-sql-driver/mysql&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// NewAdapter是Adapter的构造函数</span><br><span class="hljs-comment">// dbSpecified为可选bool参数。默认值为false。</span><br><span class="hljs-comment">//这取决于您是否在dataSourceName中指定了一个现有的DB。</span><br><span class="hljs-comment">//如果dbSpecified == true，您需要确保dataSourceName中的DB存在。</span><br><span class="hljs-comment">//如果dbSpecified == false，适配器将自动创建名为&quot;casbin&quot;的数据库。</span><br>a, err := xormadapter.NewAdapter(<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;root:123456@tcp(127.0.0.1:3306)/go_test&quot;</span>, <span class="hljs-literal">true</span>)<br>fmt.Println(a, err)<br><span class="hljs-comment">//NewEnforcer通过DB创建一个enforcer</span><br>e, err := casbin.NewEnforcer(<span class="hljs-string">&quot;./test/model.conf&quot;</span>, a)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;error: enforcer: %s&quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当前自动创建了”casbin_rule”的数据表，且数据表为空<br><img src="/img/gin_Casbin2/csb6.png"></p><h2 id="2、添加单条授权规则"><a href="#2、添加单条授权规则" class="headerlink" title="2、添加单条授权规则"></a>2、添加单条授权规则</h2><p>AddPolicy 向当前策略添加授权规则。 如果规则已经存在，函数返回false，并且不会添加规则。 否则，函数通过添加新规则并返回true。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">added, _ := e.AddPolicy(<span class="hljs-string">&quot;linzy&quot;</span>, <span class="hljs-string">&quot;data1&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>)<br>fmt.Println(added)<br></code></pre></td></tr></table></figure><p><img src="/img/gin_Casbin2/csb7.png"></p><h2 id="3、添加多条授权规则"><a href="#3、添加多条授权规则" class="headerlink" title="3、添加多条授权规则"></a>3、添加多条授权规则</h2><p>AddPolicy 向当前策略添加授权规则。 该操作本质上是原子的 因此，如果授权规则由不符合现行政策的规则组成， 函数返回false，当前政策中没有添加任何政策规则。 如果所有授权规则都符合政策规则，则函数返回true，每项政策规则都被添加到目前的政策中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">rules := [][]<span class="hljs-type">string</span>&#123;<br>&#123;<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-string">&quot;data4&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;katy&quot;</span>, <span class="hljs-string">&quot;data4&quot;</span>, <span class="hljs-string">&quot;write&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;leyo&quot;</span>, <span class="hljs-string">&quot;data4&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;ham&quot;</span>, <span class="hljs-string">&quot;data4&quot;</span>, <span class="hljs-string">&quot;write&quot;</span>&#125;,<br>&#125;<br><br>areRulesAdded, _ := e.AddPolicies(rules)<br>fmt.Println(areRulesAdded)<br></code></pre></td></tr></table></figure><p><img src="/img/gin_Casbin2/csb8.png"></p><h2 id="4、删除授权规则-1"><a href="#4、删除授权规则-1" class="headerlink" title="4、删除授权规则"></a>4、删除授权规则</h2><p>RemovePolicy 从当前策略中删除授权规则。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">removed, _ := e.RemovePolicy(<span class="hljs-string">&quot;leyo&quot;</span>, <span class="hljs-string">&quot;data4&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>)<br>fmt.Println(removed)<br></code></pre></td></tr></table></figure><p><img src="/img/gin_Casbin2/csb9.png"></p><h2 id="5、修改授权规则-1"><a href="#5、修改授权规则-1" class="headerlink" title="5、修改授权规则"></a>5、修改授权规则</h2><p>UpdatePolicy 把旧的政策更新到新的政策</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">updated, _ := e.UpdatePolicy([]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-string">&quot;data4&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>&#125;, []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;linzy&quot;</span>, <span class="hljs-string">&quot;data3&quot;</span>, <span class="hljs-string">&quot;write&quot;</span>&#125;)<br>fmt.Println(updated)<br></code></pre></td></tr></table></figure><p><img src="/img/gin_Casbin2/csb10.png"></p><h2 id="6、查询所有授权规则"><a href="#6、查询所有授权规则" class="headerlink" title="6、查询所有授权规则"></a>6、查询所有授权规则</h2><p>GetPolicy 获取策略中的所有授权规则。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s := e.GetPolicy()<br>fmt.Println(s)<br></code></pre></td></tr></table></figure><p><img src="/img/gin_Casbin2/csb11.png"></p>]]></content>
    
    
    <categories>
      
      <category>Gin框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>gin</tag>
      
      <tag>casbin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gin框架入门-Casbin入门指南(ACL、RBAC、域内RBAC模型)</title>
    <link href="/2022/07/19/gin-Casbin1/"/>
    <url>/2022/07/19/gin-Casbin1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Casbin概述"><a href="#一、Casbin概述" class="headerlink" title="一、Casbin概述"></a>一、Casbin概述</h1><p>Casbin 是一个强大的、高效的开源访问控制框架，其权限管理机制支持多种访问控制模型。<br>Casbin参考文档链接：<a href="https://casbin.org/">https://casbin.org/</a><br>github项目链接：<a href="https://github.com/casbin/casbin">https://github.com/casbin/casbin</a></p><p><strong>Casbin 可以</strong>：</p><ol><li>支持自定义请求的格式，默认的请求格式为 **{subject, object, action}**。</li><li>具有访问控制<strong>模型model</strong>和<strong>策略policy</strong>两个核心概念。</li><li>支持RBAC中的<strong>多层角色继承</strong>，不止主体可以有角色，资源也可以具有角色。</li><li>支持内置的<strong>超级用户</strong> 例如：root 或 administrator。超级用户可以执行任何操作而无需显式的权限声明。</li><li>支持多种内置的<strong>操作符</strong>，如 keyMatch，方便对路径式的资源进行管理，如 &#x2F;foo&#x2F;bar 可以映射到 &#x2F;foo*</li></ol><p><strong>Casbin 不能</strong>：</p><ol><li><strong>身份认证</strong> authentication（即验证用户的用户名和密码），Casbin 只负责访问控制。应该有其他专门的组件负责身份认证，然后由 Casbin 进行访问控制，二者是相互配合的关系。</li><li><strong>管理用户列表或角色列表</strong>。 Casbin 认为由项目自身来管理用户、角色列表更为合适， 用户通常有他们的密码，但是 Casbin 的设计思想并不是把它作为一个存储密码的容器。 而是存储RBAC方案中用户和角色之间的映射关系。</li></ol><h1 id="二、Casbin工作原理"><a href="#二、Casbin工作原理" class="headerlink" title="二、Casbin工作原理"></a>二、Casbin工作原理</h1><p>在 Casbin 中, 访问控制模型被抽象为基于 <strong>PERM (Policy, Effect, Request, Matcher)</strong> 的一个文件。 因此，切换或升级项目的授权机制与修改配置一样简单。 您可以通过组合可用的模型来定制您自己的访问控制模型。 例如，您可以在一个model中结合RBAC角色和ABAC属性，并共享一组policy规则。</p><p>PERM模式由四个基础 <strong>(Policy, Effect, Request, Matcher)</strong> 组成，描述了资源与用户之间的关系。</p><h1 id="三、Model语法"><a href="#三、Model语法" class="headerlink" title="三、Model语法"></a>三、Model语法</h1><ul><li><p>Model CONF 至少应包含四个部分: **[request_definition], [policy_definition], [policy_effect], [matchers]**。</p></li><li><p>如果 model 使用 RBAC, 还需要添加 <strong>[role_definition]</strong> 部分。</p></li><li><p>Model CONF 文件可以包含注释。注释以 <strong>#</strong> 开头， <strong>#</strong> 会注释该行剩余部分。</p></li></ul><h2 id="1、Request定义"><a href="#1、Request定义" class="headerlink" title="1、Request定义"></a>1、Request定义</h2><p><strong>Request</strong> 定义请求参数。基本请求是一个元组对象，至少需要<strong>主题</strong>(访问实体)、<strong>对象</strong>(访问资源) 和<strong>动作</strong>(访问方式)</p><blockquote><p>例如，一个请求可能长这样： <strong>r&#x3D;{sub,obj,act}</strong><br>它实际上定义了我们应该提供访问控制匹配功能的参数名称和顺序。</p></blockquote><p><strong>[request_definition]</strong> 部分用于request的定义，它明确了 e.Enforce(…) 函数中参数的含义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">[request_definition]<br>r = sub, obj, act<br></code></pre></td></tr></table></figure><p><strong>sub, obj, act</strong> 表示经典三元组: 访问实体 (Subject)，访问资源 (Object) 和访问方法 (Action)。 但是, 你可以自定义你自己的请求表单, 如果不需要指定特定资源，则可以这样定义 <strong>sub、act</strong> ，或者如果有两个访问实体, 则为 <strong>sub、sub2、obj、act</strong>。</p><h2 id="2、Policy定义"><a href="#2、Policy定义" class="headerlink" title="2、Policy定义"></a>2、Policy定义</h2><p><strong>Policy</strong> 定义访问策略模式。事实上，它是在<strong>Policy</strong>规则文件中定义字段的名称和顺序。</p><blockquote><p>例如： p&#x3D;{sub, obj, act} 或 p&#x3D;{sub, obj, act, eft}<br>注：如果未定义eft (policy result)，则策略文件中的结果字段将不会被读取， 和匹配的策略结果将<strong>默认被允许</strong> allow。</p></blockquote><p><strong>[policy_definition]</strong> 部分是对policy的定义，以下文的 model 配置为例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">[policy_definition]<br>p = sub, obj, act<br>p2 = sub, act<br></code></pre></td></tr></table></figure><ul><li>这些是我们对policy规则的具体描述<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">p, alice, data1, read<br>p2, bob, write-all-objects<br></code></pre></td></tr></table></figure></li></ul><p>policy部分的每一行称之为一个策略规则， 每条策略规则通常以形如<strong>p, p2</strong>的<strong>policy type</strong>开头。 如果存在多个policy定义，那么我们会根据前文提到的<strong>policy type</strong>与具体的某条定义匹配。 上面的policy的绑定关系将会在matcher中使用， 罗列如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">(alice, data1, read) -&gt; (p.sub, p.obj, p.act)<br>(bob, write-all-objects) -&gt; (p2.sub, p2.act)<br></code></pre></td></tr></table></figure><h2 id="3、Matcher定义"><a href="#3、Matcher定义" class="headerlink" title="3、Matcher定义"></a>3、Matcher定义</h2><p><strong>Matcher</strong> 匹配请求 <strong>Request</strong> 和策略 <strong>Policy</strong> 的规则。</p><blockquote><p>例如： m &#x3D; r.sub &#x3D;&#x3D; p.sub &amp;&amp; r.act &#x3D;&#x3D; p.act &amp;&amp; r.obj &#x3D;&#x3D; p.obj<br>这个匹配规则意味着如果请求Request的参数(访问实体，访问资源和访问方式)匹配， 可以在策略 Policy 中找到资源和方法，那么策略 Policy 结果（p.eft）便会返回。 策略的结果将保存在 p.eft 中。</p></blockquote><p><strong>[matchers]</strong> 是策略匹配程序的定义。匹配程序是表达式。它定义了如何根据请求评估策略规则。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">[matchers]<br>m = r.sub == p.sub &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act<br></code></pre></td></tr></table></figure><p>上述匹配器是最简单的，这意味着请求中的主题、对象和行动应该与策略规则中的匹配。</p><p>您可以在匹配器中使用诸如  +, -, *, &#x2F;  和逻辑操作员，例如 <strong>&amp;&amp;, ||, !</strong></p><h2 id="4、Policy-effect定义"><a href="#4、Policy-effect定义" class="headerlink" title="4、Policy effect定义"></a>4、Policy effect定义</h2><p><strong>effect</strong> 可以被理解为一种模型，在这种模型中，对匹配结果再次作出逻辑组合判断。</p><blockquote><p>例如： e &#x3D; some (where (p.eft &#x3D;&#x3D; allow))<br>这句话意味着，如果匹配的策略结果存在，并且 p.eft 是 <strong>allow</strong> 允许的，那么最终结果为 true。</p></blockquote><p><strong>[policy_effect]</strong> 是策略效果的定义。 它确定如果多项政策规则与请求相符，是否应批准访问请求。 例如，一项规则允许，另一项规则则加以拒绝。</p><h3 id="1）some-where-p-eft-x3D-x3D-allow"><a href="#1）some-where-p-eft-x3D-x3D-allow" class="headerlink" title="1）some(where (p.eft &#x3D;&#x3D; allow))"></a>1）some(where (p.eft &#x3D;&#x3D; allow))</h3><p>策略效果表示如果有任何匹配的策略规则 <strong>allow</strong>, 最终效果是 <strong>allow</strong> (aka allow-override). p.eft 是策略的效果，它可以 <strong>allow</strong> 或 <strong>deny</strong>。 它是可选的，默认值是 <strong>allow</strong>。 因为我们没有在上面指定它，所以它使用默认值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">[policy_effect]<br>e = some(where (p.eft == allow))<br></code></pre></td></tr></table></figure><h3 id="2）some-where-p-eft-x3D-x3D-deny"><a href="#2）some-where-p-eft-x3D-x3D-deny" class="headerlink" title="2）some(where (p.eft &#x3D;&#x3D; deny))"></a>2）some(where (p.eft &#x3D;&#x3D; deny))</h3><p>这意味着如果没有匹配的策略规则<strong>deny</strong>，最终效果是<strong>allow</strong>（又名拒绝覆盖）。<strong>some</strong>表示：如果存在一个匹配的策略规则。<strong>any</strong>表示：所有匹配的策略规则（此处未使用）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">[policy_effect]<br>e = !some(where (p.eft == deny))<br></code></pre></td></tr></table></figure><h3 id="3）some-where-p-eft-x3D-x3D-allow-amp-amp-some-where-p-eft-x3D-x3D-deny"><a href="#3）some-where-p-eft-x3D-x3D-allow-amp-amp-some-where-p-eft-x3D-x3D-deny" class="headerlink" title="3）some(where (p.eft &#x3D;&#x3D; allow)) &amp;&amp; !some(where (p.eft &#x3D;&#x3D; deny))"></a>3）some(where (p.eft &#x3D;&#x3D; allow)) &amp;&amp; !some(where (p.eft &#x3D;&#x3D; deny))</h3><p>表示至少有一个匹配的策略规则 <strong>allow</strong>，并且没有匹配的策略规则<strong>deny</strong>。因此，通过这种方式，允许和拒绝授权都受支持，并且拒绝覆盖。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">[policy_effect]<br>e = some(where (p.eft == allow)) &amp;&amp; !some(where (p.eft == deny))<br></code></pre></td></tr></table></figure><h2 id="5、Role-定义"><a href="#5、Role-定义" class="headerlink" title="5、Role 定义"></a>5、Role 定义</h2><p><strong>[role_definition]</strong> 是RBAC角色继承关系的定义。 Casbin 支持 RBAC 系统的多个实例, 例如, <strong>用户可以具有角色及其继承关系</strong>, <strong>资源也可以具有角色及其继承关系</strong>。 这两个 RBAC 系统不会互相干扰。</p><p>此部分是可选的。 如果在模型中不使用 RBAC 角色, 则省略此部分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">[role_definition]<br>g = _, _<br>g2 = _, _<br></code></pre></td></tr></table></figure><p>g 是一个 <strong>RBAC系统</strong>, g2 是另一个 <strong>RBAC 系统</strong>。 _, _表示角色继承关系的前项和后项，即<strong>前项继承后项角色的权限</strong>。 一般来讲，如果您需要进行角色和用户的绑定，直接使用g 即可。 当您需要表示角色（或者组）与用户和资源的绑定关系时，可以使用g 和 g2 这样的表现形式。</p><p>在Casbin里，我们以policy表示中实际的用户角色映射关系 (或是资源-角色映射关系)，例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">p, data2_admin, data2, read<br>g, alice, data2_admin<br></code></pre></td></tr></table></figure><p>这意味着 <strong>alice</strong> 是角色 <strong>data2_admin</strong>的一个成员。 <strong>alice</strong> 在这里可以是用户、资源或角色。 Cabin 只是将其识别为一个字符串。</p><p>接下来在matcher中，应该像下面的例子一样检查角色信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">[matchers]<br>m = g(r.sub, p.sub) &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act<br></code></pre></td></tr></table></figure><p>这意味着在请求 Request 中应该在policy中包含sub角色。<br>例如 r &#x3D; {sub, dom, obj, act}</p><blockquote><p><strong>NOTE</strong></p><ol><li>Casbin 只存储用户角色的映射关系。</li><li>Cabin 没有验证用户是否是有效的用户，或者角色是一个有效的角色。 这应该通过认证来解决。</li><li>RBAC 系统中的用户名称和角色名称不应相同。因为Casbin将用户名和角色识别为字符串， 所以当前语境下Casbin无法得出这个字面量到底指代用户 <strong>alice</strong> 还是角色 <strong>alice</strong>。 这时，使用明确的 <strong>role_alice</strong> ，问题便可迎刃而解。</li><li>假设<strong>A</strong>具有角色 <strong>B</strong>，<strong>B</strong> 具有角色 <strong>C</strong>，并且 <strong>A</strong> 有角色 <strong>C</strong>。 这种传递性在当前版本会造成死循环。</li></ol></blockquote><h1 id="四、ASL模型"><a href="#四、ASL模型" class="headerlink" title="四、ASL模型"></a>四、ASL模型</h1><p><strong>在线编辑</strong><br>您还可以使用在线编辑器 ( <a href="https://casbin.org/editor/">https://casbin.org/editor/</a> ) 在 Web 浏览器中编写您的 Casbin 模型和策略。 </p><h2 id="1、Model"><a href="#1、Model" class="headerlink" title="1、Model"></a>1、Model</h2><p>Model规定了权限由 <strong>sub、obj、act</strong>三要素组成，只有在策略Policy列表中存在于请求Request完全相同的策略时，该请求才能通过。匹配器的结构通过 <strong>p.eft</strong> 获取， <strong>some(where (p.eft &#x3D;&#x3D; allow))</strong> 表示有任意一条 policy rule 满足, 则最终结果为 allow</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"># 请求<br># sub ——&gt; 想要访问资源的用户角色(Subject)——请求实体<br># obj ——&gt; 访问的资源(Object)<br># act ——&gt; 访问的方法(Action: get、post...)<br>[request_definition]<br>r = sub,obj,act<br><br><br># 策略(.csv文件p的格式，定义的每一行为policy rule;p为policy rule的名字。)<br>[policy_definition]<br>p = sub,obj,act<br><br><br># 策略效果<br>[policy_effect]<br>e = some(where (p.eft == allow))<br># 上面表示有任意一条 policy rule 满足, 则最终结果为 allow；p.eft它可以是allow或deny，它是可选的，默认是allow<br><br># 匹配器<br>[matchers]<br>m = r.sub == p.sub &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act<br></code></pre></td></tr></table></figure><h2 id="2、Policy"><a href="#2、Policy" class="headerlink" title="2、Policy"></a>2、Policy</h2><p>Policy表示谁能对什么资源进行什么操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">p, linzy, data1, read<br>p, hhh, data2, write<br></code></pre></td></tr></table></figure><p>linzy 对 资源 data1 有 read 权限<br>hhh 对 资源 data2 有 write 权限</p><h2 id="3、Request"><a href="#3、Request" class="headerlink" title="3、Request"></a>3、Request</h2><p>Request请求的策略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">linzy, data1, read<br>linzy, data2, read<br>hhh, data2, write<br>hhh, data2, read<br></code></pre></td></tr></table></figure><h2 id="4、Enforcement-Result"><a href="#4、Enforcement-Result" class="headerlink" title="4、Enforcement Result"></a>4、Enforcement Result</h2><p>Enforcement Result返回的结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><img src="/img/gin_Casbin1/csb1.png"></p><h1 id="五、RBAC模型"><a href="#五、RBAC模型" class="headerlink" title="五、RBAC模型"></a>五、RBAC模型</h1><p>将某些具有特定模式的<strong>主题</strong>、<strong>对象</strong>或<strong>域&#x2F;租户</strong>自动授予角色。RBAC 中的模式匹配函数可以帮助您做到这一点。</p><p><strong>[role_definition]</strong> 是RBAC角色继承关系的定义。 Casbin 支持 RBAC 系统的多个实例, 例如, <strong>用户可以具有角色及其继承关系</strong>, <strong>资源也可以具有角色及其继承关系</strong>，****。 </p><h2 id="1、Model-1"><a href="#1、Model-1" class="headerlink" title="1、Model"></a>1、Model</h2><p>Model规定了权限由 <strong>sub、obj、act</strong>三要素组成，只有在策略Policy列表中<strong>请求Request</strong> 或者 <strong>继承的角色</strong>里存在完全相同的策略时，该请求才能通过。匹配器的结构通过 <strong>p.eft</strong> 获取， <strong>some(where (p.eft &#x3D;&#x3D; allow))</strong> 表示有任意一条 policy rule 满足, 则最终结果为 allow</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">#请求入参 （实体, 资源, 方法）<br>[request_definition]<br>r = sub, obj, act<br><br>#策略 （实体, 资源, 方法）<br>[policy_definition]<br>p = sub, obj, act<br><br>#按照角色权限，g = 用户, 角色<br>#用户继承角色的资源和方法<br>[role_definition]<br>g = _, _<br><br>#策列效果 表示有任意一条 policy rule 满足, 则最终结果为 allow；p.eft它可以是allow或deny，它是可选的，默认是allow<br>[policy_effect]<br>e = some(where (p.eft == allow))<br><br>#在权限表 p 中是否能找到用户和继承的角色的资源和方法<br>[matchers]<br>m = g(r.sub, p.sub) &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act<br></code></pre></td></tr></table></figure><h2 id="2、Policy-1"><a href="#2、Policy-1" class="headerlink" title="2、Policy"></a>2、Policy</h2><p>Policy表示谁能对什么资源进行什么操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">p, linzy, data1, read<br>p, hhh, data2, write<br>p, data1_admin, data1, write<br>p, data2_admin, data2, read<br><br>g, linzy, data2_admin<br>g, hhh, data1_admin<br></code></pre></td></tr></table></figure><p>linzy 对 资源 data1 和 data2 有 read 权限<br>hhh 对 资源 data2 和 data 1有 write 权限<br>data1_admin 对 资源 data1 有 write 权限<br>data2_admin 对 资源 data2 有 read 权限</p><p>linzy 继承了 角色data2_admin 的所有权限<br>hhh 继承了 角色 data1_admin 的所有权限</p><h2 id="3、Request-1"><a href="#3、Request-1" class="headerlink" title="3、Request"></a>3、Request</h2><p>Request请求的策略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">linzy, data1, read<br>linzy, data2, write<br>hhh, data1, read<br>hhh, data2, write<br>data2_admin, data1, read<br></code></pre></td></tr></table></figure><h2 id="4、Enforcement-Result-1"><a href="#4、Enforcement-Result-1" class="headerlink" title="4、Enforcement Result"></a>4、Enforcement Result</h2><p>Enforcement Result返回的结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><img src="/img/gin_Casbin1/csb2.png"></p><h1 id="六、域内RBAC模型"><a href="#六、域内RBAC模型" class="headerlink" title="六、域内RBAC模型"></a>六、域内RBAC模型</h1><h2 id="1、域租户的角色定义"><a href="#1、域租户的角色定义" class="headerlink" title="1、域租户的角色定义"></a>1、域租户的角色定义</h2><p>在Casbin中的RBAC角色可以是全局或是基于特定于域的。 特定域的角色意味着当用户处于不同的域&#x2F;租户群体时，用户所表现的角色也不尽相同。 这对于像云服务这样的大型系统非常有用，因为用户通常分属于不同的租户群体。</p><p>域&#x2F;租户的角色定义应该类似于:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">[role_definition]<br>g = _, _, _<br></code></pre></td></tr></table></figure><p>第三个 <strong>_</strong> 表示域&#x2F;租户的名称, 此部分不应更改。</p><h2 id="2、Model"><a href="#2、Model" class="headerlink" title="2、Model"></a>2、Model</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go">#请求入参 (实体, 域/租户, 资源, 方法)<br>[request_definition]<br>r = sub, dom, obj, act<br><br>#权限模型 (实体, 域/租户, 资源, 方法)<br>[policy_definition]<br>p = sub, dom, obj, act<br><br># 域匹配规则 g = 用户, 角色, 域/租户<br>[role_definition]<br>g = _, _, _<br><br>#策略效果<br>[policy_effect]<br>e = some(where (p.eft == allow))<br><br>#在权限表 (p)中同一域/租户中的请求是否存在 相同的资源和方法<br>[matchers]<br>m = g(r.sub, p.sub, r.dom) &amp;&amp; r.dom == p.dom &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act<br></code></pre></td></tr></table></figure><h2 id="3、Policy"><a href="#3、Policy" class="headerlink" title="3、Policy"></a>3、Policy</h2><p>Policy表示谁能对什么资源进行什么操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">p, admin, domain1, data1, read<br>p, admin, domain1, data1, write<br>p, admin, domain2, data2, read<br>p, admin, domain2, data2, write<br><br>g, linzy, admin, domain1<br>g, hhh, admin, domain2<br></code></pre></td></tr></table></figure><p>admin 在 domain1 域中  对 资源data1 有 read 和 write 权限<br>admin 在 domain2 域中 对 资源data2 有 read 和 write 权限</p><p>用户 linzy 继承 admin 在 domain1 域中 的所有权限<br>用户 hhh 继承 admin 在 domain2 域中 的所有权限</p><h2 id="3、Request-2"><a href="#3、Request-2" class="headerlink" title="3、Request"></a>3、Request</h2><p>Request请求的策略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">linzy, domain1, data1, read<br>linzy, domain1, data2, read<br>hhh, domain2, data1, read<br>hhh, domain2, data2, read<br>admin, domain1, data1, read<br></code></pre></td></tr></table></figure><h2 id="4、Enforcement-Result-2"><a href="#4、Enforcement-Result-2" class="headerlink" title="4、Enforcement Result"></a>4、Enforcement Result</h2><p>Enforcement Result返回的结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><img src="/img/gin_Casbin1/csb3.png"></p>]]></content>
    
    
    <categories>
      
      <category>Gin框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>gin</tag>
      
      <tag>casbin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gin框架入门-JWT认证</title>
    <link href="/2022/07/19/gin-JWT/"/>
    <url>/2022/07/19/gin-JWT/</url>
    
    <content type="html"><![CDATA[<h1 id="一、JWT"><a href="#一、JWT" class="headerlink" title="一、JWT"></a>一、JWT</h1><h2 id="1、JSON-Web-Token"><a href="#1、JSON-Web-Token" class="headerlink" title="1、JSON Web Token"></a>1、JSON Web Token</h2><p>JSON Web Token 参考文档：<a href="https://jwt.io/introduction">https://jwt.io/introduction</a><br>JSON Web Token (JWT) 是一个开放标准 ( RFC 7519 )，它定义了一种紧凑且自包含的方式，用于在各方之间安全地传输信息作为 JSON 对象。此信息可以验证和信任，因为它是数字签名的。JWT 可以使用密钥（使用<strong>HMAC</strong>算法）或使用<strong>RSA</strong>或<strong>ECDSA</strong>的公钥&#x2F;私钥对进行签名。</p><p>简而言之，它是一个签名的 <strong>JSON</strong> 对象，可以做一些有用的事情（例如，身份验证）。它通常用于BearerOauth 2 中的令牌。令牌由三部分组成，由  ( .) 分隔。前两部分是 JSON 对象，已经过base64url编码。最后一部分是签名，以同样的方式编码。</p><p>第一部分称为<strong>标题</strong>。它包含验证最后一部分签名的必要信息。例如，使用哪种加密方法进行签名以及使用了什么密钥。</p><p>中间的部分是有趣的部分。它称为<strong>声明</strong>，包含您关心的实际内容。有关保留密钥和添加自己的正确方法的信息</p><h1 id="二、什么时候应该使用-JSON-Web-Tokens"><a href="#二、什么时候应该使用-JSON-Web-Tokens" class="headerlink" title="二、什么时候应该使用 JSON Web Tokens"></a>二、什么时候应该使用 JSON Web Tokens</h1><p>以下是 JSON Web Tokens有用的一些场景：</p><ul><li><p><strong>授权</strong>：这是使用 JWT 最常见的场景。用户登录后，每个后续请求都将包含 JWT，从而允许用户访问该令牌允许的路由、服务和资源。单点登录是当今广泛使用 JWT 的一项功能，因为它的开销很小并且能够在不同的域中轻松使用。</p></li><li><p><strong>信息交换</strong>：JSON Web 令牌是在各方之间安全传输信息的好方法。因为可以对 JWT 进行签名（例如，使用公钥&#x2F;私钥对），所以您可以确定发件人就是他们所说的那个人。此外，由于使用标头和有效负载计算签名，您还可以验证内容没有被篡改。</p></li></ul><h1 id="三、JSON-Web-Token-结构"><a href="#三、JSON-Web-Token-结构" class="headerlink" title="三、JSON Web Token 结构"></a>三、JSON Web Token 结构</h1><p>在其紧凑的形式中，<strong>JSON Web Tokens</strong> 由以点 ( .) 分隔的三部分组成，它们是：</p><ul><li>标题</li><li>有效载荷</li><li>签名</li></ul><p>因此，JWT 通常如下所示。</p><blockquote><p>xxxxx.yyyyy.zzzzz</p></blockquote><h2 id="1、标题"><a href="#1、标题" class="headerlink" title="1、标题"></a>1、标题</h2><p>标头通常由两部分组成：<strong>令牌的类型</strong>，即 JWT，以及正在使用的<strong>签名算法</strong>，例如 HMAC SHA256 或 RSA。<br>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">&#123;<br>  <span class="hljs-string">&quot;alg&quot;</span>: <span class="hljs-string">&quot;HS256&quot;</span>,<br>  <span class="hljs-string">&quot;typ&quot;</span>: <span class="hljs-string">&quot;JWT&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后，这个 JSON 被Base64Url编码以形成 JWT 的第一部分。</p><h2 id="2、有效载荷"><a href="#2、有效载荷" class="headerlink" title="2、有效载荷"></a>2、有效载荷</h2><p>令牌的第二部分是有效负载，其中包含声明。声明是关于实体（通常是用户）和附加数据的陈述。声明分为三种类型：<strong>注册声明</strong>、<strong>公开声明</strong>和<strong>私人声明</strong>。</p><ul><li><strong>注册声明</strong>：这些是一组预定义的声明，它们不是强制性的，但建议使用，以提供一组有用的、可互操作的声明。其中一些是： iss（发行人）、 exp（到期时间）、 sub（主题）、 aud（受众）等。</li><li><strong>公共声明</strong>：这些可以由使用 JWT 的人随意定义。但是为了避免冲突，它们应该在<a href="https://www.iana.org/assignments/jwt/jwt.xhtml">IANA JSON Web Token Registry</a>中定义，或者定义为包含抗冲突命名空间的 URI。</li><li><strong>私人声明</strong>：这些是为在同意使用它们的各方之间共享信息而创建的自定义声明，既不是注册声明也不是公共声明。</li></ul><p>一个示例有效载荷可能是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">&#123;<br>  <span class="hljs-string">&quot;sub&quot;</span>: <span class="hljs-string">&quot;1234567890&quot;</span>,<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;linzy&quot;</span>,<br>  <span class="hljs-string">&quot;admin&quot;</span>: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后对有效负载进行Base64Url编码以形成 JSON Web 令牌的第二部分。</p><blockquote><p><strong>注意</strong>：对于已签名的令牌，此信息虽然受到保护以防篡改，但任何人都可以读取。除非已加密，否则请勿将机密信息放入 JWT 的有效负载或标头元素中。</p></blockquote><h2 id="3、签名"><a href="#3、签名" class="headerlink" title="3、签名"></a>3、签名</h2><p>要创建签名部分，您必须获取编码的标头、编码的有效负载、秘密、标头中指定的算法，并对其进行签名。<br>例如，如果您想使用 HMAC SHA256 算法，签名将通过以下方式创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">HMACSHA256(<br>  base64UrlEncode(header) + <span class="hljs-string">&quot;.&quot;</span> +<br>  base64UrlEncode(payload),<br>  secret)<br></code></pre></td></tr></table></figure><p>签名用于验证消息在此过程中没有被更改，并且在使用私钥签名的令牌的情况下，它还可以验证 JWT 的发送者就是它所说的那个人。</p><p>如果您想玩 JWT 并将这些概念付诸实践，您可以使用 <a href="https://jwt.io/#debugger-io">jwt.io Debugger</a> 来解码、验证和生成 JWT。</p><h1 id="四、JSON-Web-令牌如何工作"><a href="#四、JSON-Web-令牌如何工作" class="headerlink" title="四、JSON Web 令牌如何工作"></a>四、JSON Web 令牌如何工作</h1><p>在身份验证中，当用户使用其凭据成功登录时，将返回一个 <strong>JSON Web Token</strong>。由于令牌是凭据，因此必须非常小心以防止出现安全问题。通常，您不应将令牌保留<strong>超过所需的时间</strong>。</p><p><a href="https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html#local-storage">由于缺乏安全性</a>，您也不应该在浏览器存储中存储敏感的会话数据。</p><p>每当用户想要访问受保护的路由或资源时，用户代理应该发送 JWT，通常在<strong>Authorization</strong>标头中使用<strong>Bearer</strong>模式。标头的内容应如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">Authorization: Bearer &lt;token&gt;<br></code></pre></td></tr></table></figure><p>在某些情况下，这可以是一种无状态授权机制。服务器的受保护路由将检查<strong>Authorization</strong>标头中是否存在有效的 JWT，如果存在，则允许用户访问受保护的资源。如果 JWT 包含必要的数据，则可能会减少查询数据库以进行某些操作的需要，尽管情况并非总是如此。</p><p>请注意，如果您通过 HTTP 标头发送 JWT 令牌，则应尽量防止它们变得太大。某些服务器不接受超过 8 KB 的标头。如果您试图在 JWT 令牌中嵌入太多信息，例如通过包含所有用户的权限，您可能需要替代解决方案，例如<a href="https://auth0.com/developers/lab/fine-grained-authorization">Auth0 Fine-Grained Authorization</a>。</p><p>如果令牌在<strong>Authorization</strong>标头中发送，则跨域资源共享 (CORS) 不会成为问题，因为它不使用 cookie。</p><p>下图显示了如何获取 JWT 并将其用于访问 API 或资源：<br><img src="/img/gin_JWT/jwt1.png"></p><ol><li>应用程序或客户端向授权服务器请求授权。这是通过不同的授权流程之一执行的。例如，一个典型的符合<a href="https://openid.net/connect/">OpenID Connect</a>的Web 应用程序将使用<a href="https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth">授权代码流</a> <strong>&#x2F;oauth&#x2F;authorize</strong> 通过端点。</li><li>当授权被授予时，授权服务器向应用程序返回一个访问令牌。</li><li>应用程序使用访问令牌访问受保护的资源（如 <strong>API</strong>）。</li></ol><h1 id="五、JWT-GO"><a href="#五、JWT-GO" class="headerlink" title="五、JWT-GO"></a>五、JWT-GO</h1><h2 id="1、安装指南"><a href="#1、安装指南" class="headerlink" title="1、安装指南"></a>1、安装指南</h2><ol><li>使用以下命令将jwt-go其作为依赖项添加到您的 Go 程序中。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get -u github.com/golang-jwt/jwt/v4<br></code></pre></td></tr></table></figure><ol start="2"><li>在您的代码中导入它：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/golang-jwt/jwt/v4&quot;</span><br></code></pre></td></tr></table></figure><h2 id="2、jwt-go简介"><a href="#2、jwt-go简介" class="headerlink" title="2、jwt-go简介"></a>2、jwt-go简介</h2><p>包 jwt 是 <strong>JSON Web Tokens</strong> 的 Go 实现<br>项目链接：<a href="https://github.com/golang-jwt/jwt">https://github.com/golang-jwt/jwt</a></p><h2 id="3、jwt-go例子"><a href="#3、jwt-go例子" class="headerlink" title="3、jwt-go例子"></a>3、jwt-go例子</h2><h3 id="1）创建JWT"><a href="#1）创建JWT" class="headerlink" title="1）创建JWT"></a>1）创建JWT</h3><p><strong>NewWithClaims</strong>使用指定的签名方法和声明<strong>创建一个新的令牌</strong>。</p><p>使用自定义声明类型创建令牌的示例。StandardClaim 嵌入在自定义类型中，以便于对标准声明进行编码、解析和验证。</p><p><strong>代码示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyClaims <span class="hljs-keyword">struct</span> &#123;<br>UserName <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;user_name&quot;`</span><br>jwt.StandardClaims<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//签名密钥</span><br>mySignedKeys := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;woshilinzy&quot;</span>)<br>c := MyClaims&#123;<br>UserName: <span class="hljs-string">&quot;linzy&quot;</span>,<br>StandardClaims: jwt.StandardClaims&#123;<br><span class="hljs-comment">//什么时间生效</span><br>NotBefore: time.Now().Unix() - <span class="hljs-number">60</span>,<br><span class="hljs-comment">//什么时间失效</span><br>ExpiresAt: time.Now().Unix() + <span class="hljs-number">5</span>,<br><span class="hljs-comment">//签发者</span><br>Issuer:    <span class="hljs-string">&quot;linzy&quot;</span>,<br>&#125;,<br>&#125;<br><span class="hljs-comment">//NewWithClaims使用指定的签名方法和声明创建一个新的令牌。</span><br>t := jwt.NewWithClaims(jwt.SigningMethodHS256, c)<br>fmt.Println(t)<br><span class="hljs-comment">// SignedString创建并返回一个完整的有符号的JWT。</span><br><span class="hljs-comment">//使用令牌中指定的SigningMethod对令牌进行签名。</span><br>s, err := t.SignedString(mySignedKeys)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>fmt.Println(s)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/gin_JWT/jwt2.png"></p><h3 id="2）解析JWT"><a href="#2）解析JWT" class="headerlink" title="2）解析JWT"></a>2）解析JWT</h3><p><strong>ParseWithClaims</strong> 使用自定义声明类型创建令牌的示例。StandardClaim 嵌入在自定义类型中，以便于对标准声明进行编码、解析和验证。<br>token, err :&#x3D; jwt.ParseWithClaims(token, claims, func)</p><ol><li>token：我们拿到的<strong>token</strong>字符串</li><li>claims：我们用那个<strong>claims</strong>结构体发送的，就传入那个<strong>claims</strong>结构体</li><li>func：特殊的回调函数，需要固定接收 <em>Token 类型指针，返回 interface{} 和 err，*<em>interface{}</em></em> 就是我们的密钥 <strong>mySignedKeys</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyClaims <span class="hljs-keyword">struct</span> &#123;<br>UserName <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;user_name&quot;`</span><br>jwt.StandardClaims<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>mySignedKeys := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;woshilinzy&quot;</span>)<br><br><span class="hljs-comment">//刚刚加密的JWT</span><br>tokenString := <span class="hljs-string">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJsaW56eSIsImV4cCI6MTY1NzYzNTY5MSwiaXNzIjoibGluenkiLCJuYmYiOjE2NTc2MzU2MjZ9.SJEAqz3BnJ_52kEQvwbIjWPa9KW6KU2yLINTQMk4FlA&quot;</span><br><span class="hljs-comment">//解析JWT</span><br>token, err := jwt.ParseWithClaims(tokenString, &amp;MyClaims&#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(token *jwt.Token)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> mySignedKeys, <span class="hljs-literal">nil</span><br>&#125;)<br><span class="hljs-comment">//使用断言获取MyClaims结构体</span><br>fmt.Println(token.Claims.(*MyClaims))<br>fmt.Println(err)<br>&#125;<br></code></pre></td></tr></table></figure><img src="/img/gin_JWT/jwt3.png"></li></ol><h1 id="六、浅谈使用JWT的优点"><a href="#六、浅谈使用JWT的优点" class="headerlink" title="六、浅谈使用JWT的优点"></a>六、浅谈使用JWT的优点</h1><p>让我们谈谈<strong>JSON Web Tokens</strong> (JWT)与<strong>Simple Web Tokens</strong> (SWT)和<strong>Security Assertion Markup Language Tokens</strong> (SAML)相比的优势。</p><p>由于 JSON 不像 XML 那样冗长，因此在对其进行编码时，它的大小也更小，这使得 JWT 比 SAML 更紧凑。这使得 JWT 成为在 HTML 和 HTTP 环境中传递的不错选择。</p><p>安全方面，SWT 只能通过使用 HMAC 算法的共享密钥进行对称签名。但是，JWT 和 SAML 令牌可以使用 X.509 证书形式的公钥&#x2F;私钥对进行签名。与签署 JSON 的简单性相比，使用 XML 数字签名签署 XML 而不引入隐蔽的安全漏洞是非常困难的。</p><p>JSON 解析器在大多数编程语言中都很常见，因为它们直接映射到对象。相反，XML 没有自然的文档到对象映射。这使得使用 JWT 比使用 SAML 断言更容易。</p><p>关于使用，JWT 用于 Internet 规模。这突出了 JSON Web 令牌在多个平台（尤其是移动平台）上客户端处理的便利性。</p>]]></content>
    
    
    <categories>
      
      <category>Gin框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>gin，json</tag>
      
      <tag>JWT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gin框架入门-路由分组和中间件</title>
    <link href="/2022/07/18/gin-Group-Middleware/"/>
    <url>/2022/07/18/gin-Group-Middleware/</url>
    
    <content type="html"><![CDATA[<h1 id="一、路由分组"><a href="#一、路由分组" class="headerlink" title="一、路由分组"></a>一、路由分组</h1><p>在我们实际的开发应用中我们希望能个各个功能模块的路由进行分组，同一个模块的不同路由带有同样的前缀。</p><ul><li>作用：首先是路由更加的清晰 并且我们在针对某一组路由进行中间件权限校验的时候也比较的方便。</li></ul><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">r := gin.Default()<br>v1 := r.Group(<span class="hljs-string">&quot;v1&quot;</span>)<br>v1.GET(<span class="hljs-string">&quot;/test1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;这里是test1&quot;</span>,<br>&#125;)<br>&#125;)<br>v1.GET(<span class="hljs-string">&quot;/test2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;这里是test2&quot;</span>,<br>&#125;)<br>&#125;)<br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br></code></pre></td></tr></table></figure><p>打开postman选择GET请求，访问<a href="http://localhost:8080/v1/test1">http://localhost:8080/v1/test1</a><br><img src="/img/gin_Group_Middleware/group.png"></p><h1 id="二、中间件"><a href="#二、中间件" class="headerlink" title="二、中间件"></a>二、中间件</h1><h2 id="1、中间件简介"><a href="#1、中间件简介" class="headerlink" title="1、中间件简介"></a>1、中间件简介</h2><p>Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。</p><p><img src="/img/gin_Group_Middleware/middleware1.png"><br>中间件就是作用于两个模块之间的功能软件，可以作为拦截器、记录日志等,比如在前后端开发中</p><blockquote><p>路由——–&gt; 中间件（过滤作用）——–&gt; 控制器</p></blockquote><p>在Gin中，中间件的效果可以简单的概括为：</p><ul><li>设置好中间件以后，中间件后面的路由都会使用这个中间件</li><li>设置在中间件之前的路由则不会生效</li></ul><h2 id="2、定义中间件"><a href="#2、定义中间件" class="headerlink" title="2、定义中间件"></a>2、定义中间件</h2><p>Gin中的中间件必须是一个<strong>gin.HandlerFunc类型</strong>，在自定义中间件函数时，有两种写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middleW</span><span class="hljs-params">()</span></span> gin.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>...<br>&#125;<br>&#125;<br>router.Use(middleW())<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middleW</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>...<br>&#125;<br>router.Use(middleW())<br></code></pre></td></tr></table></figure><h2 id="3、注册中间件"><a href="#3、注册中间件" class="headerlink" title="3、注册中间件"></a>3、注册中间件</h2><p>在Gin框架中，我们可以注册全局中间件，也可以给单独路由或者路由组注册中间件，可以为路由添加任意数量的中间件。</p><ul><li>当我们存在多个中间件的时候，中间件的处理顺序是参考洋葱模型：</li></ul><p><img src="/img/gin_Group_Middleware/middleware2.png"><br>简而言之，请求是队列处理，响应则是堆栈处理。</p><ul><li>定义中间件代码：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//声明一个中间件方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middleW</span><span class="hljs-params">()</span></span> gin.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;我在方法前&quot;</span>)<br>c.Next()<br>fmt.Println(<span class="hljs-string">&quot;我在方法后&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="1）注册全局中间件"><a href="#1）注册全局中间件" class="headerlink" title="1）注册全局中间件"></a>1）注册全局中间件</h3><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br><span class="hljs-comment">//注册一个全局中间件</span><br>r.Use(middleW())<br>r.GET(<span class="hljs-string">&quot;/test&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;我在方法内部&quot;</span>)<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;成功了&quot;</span>,<br>&#125;)<br>&#125;)<br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>打开postman选择GET请求，访问<a href="http://localhost:8080/test">http://localhost:8080/test</a><br><img src="/img/gin_Group_Middleware/middleware3.png"><br><img src="/img/gin_Group_Middleware/middleware4.png"></p><h3 id="2）单独注册某个路由中间件"><a href="#2）单独注册某个路由中间件" class="headerlink" title="2）单独注册某个路由中间件"></a>2）单独注册某个路由中间件</h3><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>r.GET(<span class="hljs-string">&quot;/test&quot;</span>, middleW(), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;我在方法内部&quot;</span>)<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;成功了&quot;</span>,<br>&#125;)<br>&#125;)<br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>打开postman选择GET请求，访问<a href="http://localhost:8080/test">http://localhost:8080/test</a><br><img src="/img/gin_Group_Middleware/middleware5.png"><br><img src="/img/gin_Group_Middleware/middleware6.png"></p><h3 id="3）注册路由组中间件"><a href="#3）注册路由组中间件" class="headerlink" title="3）注册路由组中间件"></a>3）注册路由组中间件</h3><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br><span class="hljs-comment">//定义一个路由组 并注册中间件</span><br>v1 := r.Group(<span class="hljs-string">&quot;v1&quot;</span>).Use(middleW())<br>v1.GET(<span class="hljs-string">&quot;/test1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;我在方法内部&quot;</span>)<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;这里是test1&quot;</span>,<br>&#125;)<br>&#125;)<br>v1.GET(<span class="hljs-string">&quot;/test2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;我在方法内部&quot;</span>)<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;这里是test2&quot;</span>,<br>&#125;)<br>&#125;)<br>r.Run()<br>&#125;<br></code></pre></td></tr></table></figure><p>打开postman选择GET请求，访问<a href="http://localhost:8080/v1/test1">http://localhost:8080/v1/test1</a><br><img src="/img/gin_Group_Middleware/middleware7.png"><br><img src="/img/gin_Group_Middleware/middleware8.png"></p><h2 id="4、中间件的嵌套"><a href="#4、中间件的嵌套" class="headerlink" title="4、中间件的嵌套"></a>4、中间件的嵌套</h2><p>中间件可以嵌套使用，这里有三个Gin框架相关的函数。</p><h3 id="1）Next"><a href="#1）Next" class="headerlink" title="1）Next()"></a>1）Next()</h3><p>表示跳过当前中间件剩余内容， 去执行下一个中间件。 当所有操作执行完之后，以出栈的执行顺序返回，执行中间件的剩余代码。<br>中间件定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//定义中间件1</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middlewOne</span><span class="hljs-params">()</span></span> gin.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;我在方法前,我是1&quot;</span>)<br>c.Next()<br>fmt.Println(<span class="hljs-string">&quot;我在方法后,我是1&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//定义中间件2</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middlewTwo</span><span class="hljs-params">()</span></span> gin.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;我在方法前,我是2&quot;</span>)<br>c.Next()<br>fmt.Println(<span class="hljs-string">&quot;我在方法后,我是2&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br><span class="hljs-comment">//使用多个中间件</span><br>r.GET(<span class="hljs-string">&quot;/test&quot;</span>, middlewOne(), middlewTwo(), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;我在方法内部&quot;</span>)<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;这里是test1&quot;</span>,<br>&#125;)<br>&#125;)<br>r.Run()<br>&#125;<br></code></pre></td></tr></table></figure><p>打开postman选择GET请求，访问<a href="http://localhost:8080/test">http://localhost:8080/test</a><br><img src="/img/gin_Group_Middleware/middleware9.png"><br><img src="/img/gin_Group_Middleware/middleware10.png"></p><h3 id="2）return"><a href="#2）return" class="headerlink" title="2）return"></a>2）return</h3><p>终止执行当前中间件剩余内容，执行下一个中间件。 当所有的函数执行结束后，以出栈的顺序执行返回，但不执行return后的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//定义中间件1</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middlewOne</span><span class="hljs-params">()</span></span> gin.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;我在方法前,我是1&quot;</span>)<br>c.Next()<br>fmt.Println(<span class="hljs-string">&quot;我在方法后,我是1&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//定义中间件2</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middlewTwo</span><span class="hljs-params">()</span></span> gin.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;我在方法前,我是2&quot;</span>)<br><span class="hljs-keyword">return</span><br>fmt.Println(<span class="hljs-string">&quot;我在方法后,我是2&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//定义中间件3</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middlewThree</span><span class="hljs-params">()</span></span> gin.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;我在方法前,我是3&quot;</span>)<br>c.Next()<br>fmt.Println(<span class="hljs-string">&quot;我在方法后,我是3&quot;</span>)<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br><span class="hljs-comment">//使用多个中间件</span><br>r.GET(<span class="hljs-string">&quot;/test&quot;</span>, middlewOne(), middlewTwo(), middlewThree(), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;我在方法内部&quot;</span>)<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;这里是test1&quot;</span>,<br>&#125;)<br>&#125;)<br>r.Run()<br>&#125;<br></code></pre></td></tr></table></figure><p>打开postman选择GET请求，访问<a href="http://localhost:8080/test">http://localhost:8080/test</a></p><p><img src="/img/gin_Group_Middleware/middleware11.png"><br><img src="/img/gin_Group_Middleware/middleware12.png"></p><h3 id="3）Abort"><a href="#3）Abort" class="headerlink" title="3）Abort()"></a>3）Abort()</h3><p>只执行当前中间件， 操作完成后，以出栈的顺序，依次返回上一级中间件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//定义中间件1</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middlewOne</span><span class="hljs-params">()</span></span> gin.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;我在方法前,我是1&quot;</span>)<br>c.Next()<br>fmt.Println(<span class="hljs-string">&quot;我在方法后,我是1&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//定义中间件2</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middlewTwo</span><span class="hljs-params">()</span></span> gin.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;我在方法前,我是2&quot;</span>)<br>c.Abort()<br>fmt.Println(<span class="hljs-string">&quot;我在方法后,我是2&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//定义中间件3</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middlewThree</span><span class="hljs-params">()</span></span> gin.HandlerFunc &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;我在方法前,我是3&quot;</span>)<br>c.Next()<br>fmt.Println(<span class="hljs-string">&quot;我在方法后,我是3&quot;</span>)<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br><span class="hljs-comment">//使用多个中间件</span><br>r.GET(<span class="hljs-string">&quot;/test&quot;</span>, middlewOne(), middlewTwo(), middlewThree(), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;我在方法内部&quot;</span>)<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;这里是test1&quot;</span>,<br>&#125;)<br>&#125;)<br>r.Run()<br>&#125;<br></code></pre></td></tr></table></figure><p>打开postman选择GET请求，访问<a href="http://localhost:8080/test">http://localhost:8080/test</a><br><img src="/img/gin_Group_Middleware/middleware13.png"><br><img src="/img/gin_Group_Middleware/middleware14.png"></p><h2 id="5、中间件注意事项"><a href="#5、中间件注意事项" class="headerlink" title="5、中间件注意事项"></a>5、中间件注意事项</h2><h3 id="1）gin默认中间件"><a href="#1）gin默认中间件" class="headerlink" title="1）gin默认中间件"></a>1）gin默认中间件</h3><p>gin.Default()默认使用了Logger和Recovery中间件，其中：</p><p>Logger中间件将日志写入gin.DefaultWriter，即使配置了GIN_MODE&#x3D;release。<br>Recovery中间件会recover任何panic。如果有panic的话，会写入500响应码。<br>如果不想使用上面两个默认的中间件，可以使用gin.New()新建一个没有任何默认中间件的路由。</p><h3 id="2）gin中间件中使用goroutine"><a href="#2）gin中间件中使用goroutine" class="headerlink" title="2）gin中间件中使用goroutine"></a>2）gin中间件中使用goroutine</h3><p>当在中间件或handler中启动新的goroutine时，不能使用原始的上下文（c *gin.Context），必须使用其只读副本（c.Copy())。</p><p>参考大佬资料：<a href="https://blog.csdn.net/qq_49723651/article/details/123694746">https://blog.csdn.net/qq_49723651&#x2F;article&#x2F;details&#x2F;123694746</a></p>]]></content>
    
    
    <categories>
      
      <category>Gin框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>gin，http</tag>
      
      <tag>postman</tag>
      
      <tag>网络协议</tag>
      
      <tag>json</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gin框架入门-模型绑定和验证</title>
    <link href="/2022/07/18/gin-ModelBind/"/>
    <url>/2022/07/18/gin-ModelBind/</url>
    
    <content type="html"><![CDATA[<h1 id="一、模式绑定"><a href="#一、模式绑定" class="headerlink" title="一、模式绑定"></a>一、模式绑定</h1><p>若要将请求主体绑定到结构体中，请使用模型绑定，目前支持JSON、XML、YAML和标准表单值(foo&#x3D;bar&amp;boo&#x3D;baz)的绑定。</p><ul><li>需要在绑定的字段上设置tag，比如，绑定格式为json，需要这样设置 json:”fieldname” 。</li></ul><p>Gin还提供了两套绑定方法：</p><h2 id="1、Must-bind"><a href="#1、Must-bind" class="headerlink" title="1、Must bind"></a>1、Must bind</h2><ul><li><strong>Methods</strong> - Bind, BindJSON, BindXML, BindQuery, BindYAML</li><li><strong>Behavior</strong> - 这些方法底层使用 MustBindWith，如果存在绑定错误，请求将被以下指令中止 c.AbortWithError(400, err).SetType(ErrorTypeBind)，响应状态代码会被设置为400，请求头Content-Type被设置为text&#x2F;plain; charset&#x3D;utf-8。注意，如果你试图在此之后设置响应代码，将会发出一个警告 [GIN-debug] [WARNING] Headers were already written. Wanted to override status code 400 with 422，如果你希望更好地控制行为，请使用ShouldBind相关的方法</li></ul><p>来看看MustBindWith方法实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//MustBindWith使用指定的绑定引擎绑定传递的结构指针。</span><br><span class="hljs-comment">//如果发生任何错误，它将中止HTTP 400的请求。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> MustBindWith(obj any, b binding.Binding) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> err := c.ShouldBindWith(obj, b); err != <span class="hljs-literal">nil</span> &#123;<br>c.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind) <span class="hljs-comment">// nolint: errcheck</span><br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到MustBindWith的方法调用的是ShouldBindWith方法，判断是否绑定错误，错误则返回404。</p><h2 id="2、Should-bind"><a href="#2、Should-bind" class="headerlink" title="2、Should bind"></a>2、Should bind</h2><ul><li><strong>Methods</strong> - ShouldBind, ShouldBindJSON, ShouldBindXML, ShouldBindQuery, ShouldBindYAML</li><li><strong>Behavior</strong> - 这些方法底层使用 ShouldBindWith，如果存在绑定错误，则返回错误，开发人员可以正确处理请求和错误。</li></ul><p>来看看ShouldBindWith方法实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//使用指定的绑定引擎绑定传递的struct指针。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> ShouldBindWith(obj any, b binding.Binding) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> b.Bind(c.Request, obj)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1）ShouldBindJSON方法"><a href="#1）ShouldBindJSON方法" class="headerlink" title="1）ShouldBindJSON方法"></a>1）ShouldBindJSON方法</h3><p>ShouldBindJSON是c.ShouldBindWith(obj, binding.JSON)的快捷方式。</p><p>JSON绑定结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PostParams <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Age  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot;`</span><br>Sex  <span class="hljs-type">bool</span>   <span class="hljs-string">`json:&quot;sex&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ShouldBindJSON代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>r.POST(<span class="hljs-string">&quot;/testBind/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">//声明一个PostParams结构体</span><br><span class="hljs-keyword">var</span> p PostParams<br><span class="hljs-comment">//通过ShouldBindJSON方法绑定结构体的对应属性</span><br>err := c.ShouldBindJSON(&amp;p)<br>fmt.Printf(<span class="hljs-string">&quot;p: %v\n&quot;</span>, p)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>c.JSON(<span class="hljs-number">404</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>:  <span class="hljs-string">&quot;报错了&quot;</span>,<br><span class="hljs-string">&quot;data&quot;</span>: gin.H&#123;&#125;,<br>&#125;)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>:  <span class="hljs-string">&quot;成功了&quot;</span>,<br><span class="hljs-string">&quot;data&quot;</span>: p,<br>&#125;)<br>&#125;<br>&#125;)<br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>打开postman选择POST请求，选择Body里的raw上传JSON格式的数据，访问<a href="http://localhost:8080/testBind">http://localhost:8080/testBind</a><br><img src="/img/gin_ModelBind/mb1.png"></p><ul><li>如果我们发送的JSON里少一项或者跟结构体的属性名不对应会如何？<br><img src="/img/gin_ModelBind/mb2.png"><br><img src="/img/gin_ModelBind/mb3.png"><br>答案是：没有被成功绑定的属性则为空。</li></ul><h3 id="2）ShouldBindUri方法"><a href="#2）ShouldBindUri方法" class="headerlink" title="2）ShouldBindUri方法"></a>2）ShouldBindUri方法</h3><p>ShouldBindUri使用指定的绑定引擎绑定传递的struct指针。</p><p>Uri绑定结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PostParams <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`uri:&quot;name&quot;`</span><br>Age  <span class="hljs-type">int</span>    <span class="hljs-string">`uri:&quot;age&quot;`</span><br>Sex  <span class="hljs-type">bool</span>   <span class="hljs-string">`uri:&quot;sex&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ShouldBindUri代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br><span class="hljs-comment">//路由路径变为uri形式获取参数</span><br>r.POST(<span class="hljs-string">&quot;/testBind/:name/:age/:sex&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">//声明一个PostParams结构体</span><br><span class="hljs-keyword">var</span> p PostParams<br><span class="hljs-comment">//通过ShouldBindUri方法绑定结构体的对应属性</span><br>err := c.ShouldBindUri(&amp;p)<br>fmt.Printf(<span class="hljs-string">&quot;p: %v\n&quot;</span>, p)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>c.JSON(<span class="hljs-number">404</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>:  <span class="hljs-string">&quot;报错了&quot;</span>,<br><span class="hljs-string">&quot;data&quot;</span>: gin.H&#123;&#125;,<br>&#125;)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>:  <span class="hljs-string">&quot;成功了&quot;</span>,<br><span class="hljs-string">&quot;data&quot;</span>: p,<br>&#125;)<br>&#125;<br>&#125;)<br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>打开postman选择POST请求，选择uri里面输入对应的数据，访问<a href="http://localhost:8080/testBind/linzy/23/true">http://localhost:8080/testBind/linzy/23/true</a></p><p><img src="/img/gin_ModelBind/mb4.png"></p><h3 id="3）ShouldBindQuery方法"><a href="#3）ShouldBindQuery方法" class="headerlink" title="3）ShouldBindQuery方法"></a>3）ShouldBindQuery方法</h3><p>ShouldBindQuery是c.ShouldBindWith(obj, binding.Query)的快捷方式</p><p>Query绑定结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PostParams <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`form:&quot;name&quot;`</span><br>Age  <span class="hljs-type">int</span>    <span class="hljs-string">`form:&quot;age&quot;`</span><br>Sex  <span class="hljs-type">bool</span>   <span class="hljs-string">`form:&quot;sex&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ShouldBindQuery代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>r.POST(<span class="hljs-string">&quot;/testBind&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">//声明一个PostParams结构体</span><br><span class="hljs-keyword">var</span> p PostParams<br><span class="hljs-comment">//通过ShouldBindQuery方法绑定结构体的对应属性</span><br>err := c.ShouldBindQuery(&amp;p)<br>fmt.Printf(<span class="hljs-string">&quot;p: %v\n&quot;</span>, p)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>c.JSON(<span class="hljs-number">404</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>:  <span class="hljs-string">&quot;报错了&quot;</span>,<br><span class="hljs-string">&quot;data&quot;</span>: gin.H&#123;&#125;,<br>&#125;)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>:  <span class="hljs-string">&quot;成功了&quot;</span>,<br><span class="hljs-string">&quot;data&quot;</span>: p,<br>&#125;)<br>&#125;<br>&#125;)<br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>打开postman选择POST请求，选择Params输入数据，访问<a href="http://localhost:8080/testBind?name=linzy&age=23&sex=true">http://localhost:8080/testBind?name=linzy&age=23&sex=true</a><br><img src="/img/gin_ModelBind/mb5.png"></p><ul><li>当我们使用绑定方法时，Gin会根据Content-Type推断出使用哪种绑定器，如果你确定你绑定的是什么，你可以使用MustBindWith或者BindingWith。</li><li></li></ul><h1 id="二、参数验证器"><a href="#二、参数验证器" class="headerlink" title="二、参数验证器"></a>二、参数验证器</h1><p>我们可以给字段指定特定规则的修饰符，如果一个字段用binding:”required”修饰，并且在绑定时该字段的值为空，那么将返回一个错误。</p><h2 id="1、结构体验证器"><a href="#1、结构体验证器" class="headerlink" title="1、结构体验证器"></a>1、结构体验证器</h2><p>用gin框架数据验证，可以不用解析数据，来if-else判断，整体使代码精简了很多。<br>binding:”required就是gin自带的数据验证，表示数据不为空，为空则返回错误。</p><p>定义结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PostParams <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br><span class="hljs-comment">//age不为空并且大于10</span><br>Age <span class="hljs-type">int</span>  <span class="hljs-string">`json:&quot;age&quot; binding:&quot;required,gt=10&quot;`</span><br>Sex <span class="hljs-type">bool</span> <span class="hljs-string">`json:&quot;sex&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码示例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>r.POST(<span class="hljs-string">&quot;/testBind&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> p PostParams<br>err := c.ShouldBindJSON(&amp;p)<br>fmt.Printf(<span class="hljs-string">&quot;p: %v\n&quot;</span>, p)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>c.JSON(<span class="hljs-number">404</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>:  <span class="hljs-string">&quot;报错了&quot;</span>,<br><span class="hljs-string">&quot;data&quot;</span>: gin.H&#123;&#125;,<br>&#125;)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>:  <span class="hljs-string">&quot;成功了&quot;</span>,<br><span class="hljs-string">&quot;data&quot;</span>: p,<br>&#125;)<br>&#125;<br>&#125;)<br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>打开postman选择POST请求，选择Body里的raw上传JSON格式的数据，访问<a href="http://localhost:8080/testBind">http://localhost:8080/testBind</a></p><ul><li>先输入正确的数据</li></ul><p><img src="/img/gin_ModelBind/mb6.png"><br> 我们成功通过数据验证，拿到了数据。</p><ul><li>再输入age小于10的数据</li></ul><p><img src="/img/gin_ModelBind/mb7.png"><br>出现错误，数据不正确。</p><h2 id="2、自定义数据验证"><a href="#2、自定义数据验证" class="headerlink" title="2、自定义数据验证"></a>2、自定义数据验证</h2><p>对绑定解析到结构体上的参数，自定义验证功能。比如我们想name不为空的同时，不能为admin的时候，就无法 binding 现成的方法。</p><p>JSON结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PostParams <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">//在参数binding上使用自定义的校验方法函数注册时候的名称</span><br><span class="hljs-comment">//name不为空且不能为admin</span><br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot; binding:&quot;required,notAdmin&quot;`</span><br>Age  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot;`</span><br>Sex  <span class="hljs-type">bool</span>   <span class="hljs-string">`json:&quot;sex&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>自定义的校验方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//自定义的校验方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">notAdmin</span><span class="hljs-params">(v validator.FieldLevel)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">//Field字段返回当前字段进行验证</span><br><span class="hljs-comment">//返回的字段需要转为接口用断言获取底层数据进行校验</span><br><span class="hljs-keyword">if</span> v.Field().Interface().(<span class="hljs-type">string</span>) == <span class="hljs-string">&quot;admin&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br><span class="hljs-comment">//将我们自定义的校验方法注册到 validator中</span><br><span class="hljs-keyword">if</span> v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;<br><span class="hljs-comment">//这里的 key 和 fn 可以不一样最终在 struct 使用的是 key</span><br>v.RegisterValidation(<span class="hljs-string">&quot;notAdmin&quot;</span>, notAdmin)<br>&#125;<br>r.POST(<span class="hljs-string">&quot;/testBind&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-keyword">var</span> p PostParams<br>err := c.ShouldBindJSON(&amp;p)<br>fmt.Printf(<span class="hljs-string">&quot;p: %v\n&quot;</span>, p)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>c.JSON(<span class="hljs-number">404</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>:  <span class="hljs-string">&quot;name 不能为admin&quot;</span>,<br><span class="hljs-string">&quot;data&quot;</span>: gin.H&#123;&#125;,<br>&#125;)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>:  <span class="hljs-string">&quot;成功了&quot;</span>,<br><span class="hljs-string">&quot;data&quot;</span>: p,<br>&#125;)<br>&#125;<br>&#125;)<br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>打开postman选择POST请求，选择Body里的raw上传JSON格式的数据，访问<a href="http://localhost:8080/testBind">http://localhost:8080/testBind</a></p><ul><li>输入name为admin的数据</li></ul><p><img src="/img/gin_ModelBind/mb8.png"><br>自定义数据验证检验出数据错误，并返回请求一个错误。</p><ul><li>输入正确的数据</li></ul><p><img src="/img/gin_ModelBind/mb9.png"><br>大功告成！通过了自定义数据验证，并成功返回了。</p>]]></content>
    
    
    <categories>
      
      <category>Gin框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>gin，http</tag>
      
      <tag>postman</tag>
      
      <tag>网络协议</tag>
      
      <tag>json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gin框架入门-文件上传</title>
    <link href="/2022/07/18/gin-uploadFile/"/>
    <url>/2022/07/18/gin-uploadFile/</url>
    
    <content type="html"><![CDATA[<h1 id="一、单文件上传"><a href="#一、单文件上传" class="headerlink" title="一、单文件上传"></a>一、单文件上传</h1><ul><li>multipart&#x2F;form-data格式用于文件上传，gin文件上传与原生的net&#x2F;http方法类似，不同在于gin把原生的request封装到c.Request中。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>r.POST(<span class="hljs-string">&quot;/FileTest&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">//FormFile返回所提供的表单键的第一个文件</span><br>f, _ := c.FormFile(<span class="hljs-string">&quot;file&quot;</span>)<br><span class="hljs-comment">//SaveUploadedFile上传表单文件到指定的路径</span><br>c.SaveUploadedFile(f, <span class="hljs-string">&quot;./&quot;</span>+f.Filename)<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;msg&quot;</span>: f,<br>&#125;)<br>&#125;)<br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>打开postman选择POST请求，选择Body里的form-data上传文件，访问<a href="http://localhost:8080/FileTest">http://localhost:8080/FileTest</a><br><img src="/img/gin_uploadFile/file1.png"></p><p>我们可以看到请求返回的文件包含了文件名和他的头映射。</p><p><img src="/img/gin_uploadFile/file2.png"></p><ul><li>我们来了解FormFile的方法实现</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> SaveUploadedFile(file *multipart.FileHeader, dst <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">//打开请求发送的文件</span><br>src, err := file.Open()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">defer</span> src.Close()<br><span class="hljs-comment">//在本地创建一个文件</span><br>out, err := os.Create(dst)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">defer</span> out.Close()<br><span class="hljs-comment">//把内容拷贝到本地文件</span><br>_, err = io.Copy(out, src)<br><span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果我们想给前端返回文件怎么办？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//添加头部映射内容</span><br>c.Writer.Header().Add(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, fmt.Sprintf(<span class="hljs-string">&quot;attachment; filename=%s&quot;</span>, f.Filename))<br><span class="hljs-comment">//File以有效的方式将指定文件写入主体流。</span><br>c.File(<span class="hljs-string">&quot;./&quot;</span> + f.Filename)<br></code></pre></td></tr></table></figure><p><img src="/img/gin_uploadFile/file3.png"></p><p><img src="/img/gin_uploadFile/file4.png"></p><p>大功告成，我们成功的将文件内容发送给前端。</p><h1 id="二、多文件上传"><a href="#二、多文件上传" class="headerlink" title="二、多文件上传"></a>二、多文件上传</h1><p>多文件上传就是一次可以上传多个文件，不需要一个文件一个文件上传，这也便于上传文件的人。<br>获取多文件的MultipartForm方法</p><ol><li><strong>MultipartForm</strong>：MultipartForm是经过解析的多部分表单（表单里面只有两个属性Value和File），包括文件上传。</li><li><strong>File</strong>: File部分存储在内存或磁盘上,可通过*FileHeader的Open方法访问。</li><li><strong>Value</strong>: Value部分存储为字符串。<br>两者都通过map的字段名进行键控。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//多文件上传</span><br>r := gin.Default()<br>r.POST(<span class="hljs-string">&quot;/multFile&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>form, err := c.MultipartForm()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-comment">//通过字段名映射</span><br>f := form.File[<span class="hljs-string">&quot;file&quot;</span>]<br><span class="hljs-comment">//for range遍历文件</span><br><span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> f &#123;<br>fmt.Println(file.Filename)<br>c.SaveUploadedFile(file, <span class="hljs-string">&quot;./&quot;</span>+file.Filename)<br>c.Writer.Header().Add(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, fmt.Sprintf(<span class="hljs-string">&quot;attachment; filename=%s&quot;</span>+file.Filename))<br>c.File(<span class="hljs-string">&quot;./&quot;</span> + file.Filename)<br>&#125;<br>&#125;)<br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>打开postman选择POST请求，选择Body里的form-data上传多个文件，访问<a href="http://localhost:8080/multFile">http://localhost:8080/multFile</a><br><img src="/img/gin_uploadFile/file5.png"></p><p><img src="/img/gin_uploadFile/file6.png"><br>我们成功将两个文件接收并保存下来，并返回给前端了第一个文件。</p>]]></content>
    
    
    <categories>
      
      <category>Gin框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>gin，http</tag>
      
      <tag>postman</tag>
      
      <tag>网络协议</tag>
      
      <tag>file</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gin框架入门-HTTP请求</title>
    <link href="/2022/07/18/gin-Http/"/>
    <url>/2022/07/18/gin-Http/</url>
    
    <content type="html"><![CDATA[<h1 id="一、HTTP请求类型"><a href="#一、HTTP请求类型" class="headerlink" title="一、HTTP请求类型"></a>一、HTTP请求类型</h1><p>http协议中一共定义了八种方法或者称之为类型来表明对请求网络资源（Request-URI）的不同的操作方式，分别是：OPTIONS、HEAD、GET、POST、PUT、DELETE、TRACE、CONNECT。</p><table><thead><tr><th>请求</th><th>内容</th></tr></thead><tbody><tr><td><strong>GET</strong></td><td>请求指定的页面信息，并返回实体主体。</td></tr><tr><td><strong>POST</strong></td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中。</td></tr><tr><td><strong>DELETE</strong></td><td>请求服务器删除指定的页面。</td></tr><tr><td><strong>PUT</strong></td><td>从客户端向服务器传送的数据取代指定的文档的内容。</td></tr></tbody></table><blockquote><p>HTTP 提供了丰富的状态码供我们使用，正确的使用状态码可以让响应数据更具可读性。</p><ul><li>200 OK - 对成功的 GET、PUT、PATCH 或 DELETE 操作进行响应。也可以被用在不创建新资源的 POST 操作上</li><li>201 Created - 对创建新资源的 POST 操作进行响应。应该带着指向新资源地址的 Location 头</li><li>202 Accepted - 服务器接受了请求，但是还未处理，响应中应该包含相应的指示信息，告诉客户端该去哪里查询关于本次请求的信息</li><li>204 No Content - 对不会返回响应体的成功请求进行响应（比如 DELETE 请求）</li><li>304 Not Modified - HTTP 缓存 header 生效的时候用</li><li>400 Bad Request - 请求异常，比如请求中的 body 无法解析</li><li>401 Unauthorized - 没有进行认证或者认证非法</li><li>403 Forbidden - 服务器已经理解请求，但是拒绝执行它</li><li>404 Not Found - 请求一个不存在的资源</li><li>405 Method Not Allowed - 所请求的 HTTP 方法不允许当前认证用户访问</li><li>410 Gone - 表示当前请求的资源不再可用。当调用老版本 API 的时候很有用</li><li>415 Unsupported Media Type - 如果请求中的内容类型是错误的</li><li>422 Unprocessable Entity - 用来表示校验错误</li><li>429 Too Many Requests - 由于请求频次达到上限而被拒绝访问</li></ul></blockquote><p>在开始动手操作之前，需要先下载postman<br>官网下载网址：<a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a></p><h1 id="二、GET请求"><a href="#二、GET请求" class="headerlink" title="二、GET请求"></a>二、GET请求</h1><p>GET请求可以看见网址中所携带的参数，参数挂载在URI和URL。</p><ul><li>URI和URL的区别:<a href="https://blog.csdn.net/weixin_55635621/article/details/123681394">https://blog.csdn.net/weixin_55635621&#x2F;article&#x2F;details&#x2F;123681394</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go">r := gin.Default() <span class="hljs-comment">//携带基础中间件启动</span><br>r.GET(<span class="hljs-string">&quot;/path/:id&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br><span class="hljs-comment">//返回URL参数的值</span><br>id := c.Param(<span class="hljs-string">&quot;id&quot;</span>)<br><span class="hljs-comment">//查询它存在,返回键url查询值，</span><br><span class="hljs-comment">//否则返回空字符串</span><br>user := c.Query(<span class="hljs-string">&quot;user&quot;</span>)<br>pwd := c.Query(<span class="hljs-string">&quot;pwd&quot;</span>)<br><span class="hljs-comment">//JSON将给定的结构序列化为JSON到响应体中。</span><br><span class="hljs-comment">//它还设置Content-Type为“application/json”。</span><br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-string">&quot;id&quot;</span>:      id,<br><span class="hljs-string">&quot;user&quot;</span>:    user,<br><span class="hljs-string">&quot;pwd&quot;</span>:     pwd,<br>&#125;)<br>&#125;)<br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// listen and serve on 0.0.0.0:8080</span><br></code></pre></td></tr></table></figure><p>这里利用<strong>Param</strong>将请求中的地址栏的id(这里是123提取出来)，和用Query将后面的参数user和pwd提取出来，然后将这三个参数返回，我们成功获取到网址上的参数了！</p><ul><li>这个时候就有个问题了，如果我们的请求里面恰好没有给user或pwd，会怎么样?</li></ul><p>我们发现缺少的这一项直接为空。</p><p>这个时候我们可以用DefaultQuery方法。</p><ul><li><strong>DefaultQuery</strong>：如果存在，DefaultQuery返回键控url查询值，否则返回指定的defaultValue字符串。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">user := c.DefaultQuery(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>) <span class="hljs-comment">// 此方法可以设置默认值</span><br></code></pre></td></tr></table></figure><p>postman访问:<a href="http://localhost:8080/path/123?pwd=123456">http://localhost:8080/path/123?pwd=123456</a><br><img src="/img/gin_HTTP/getpm1.png"></p><p><img src="/img/gin_HTTP/getvc.png"></p><ul><li>这个时候就有个问题了，如果我们的请求里面恰好没有给user或pwd，会怎么样?</li></ul><p><img src="/img/gin_HTTP/getpm2.png"></p><p>我们发现缺少的这一项直接为空。</p><p>这个时候我们可以用DefaultQuery方法。</p><ul><li><strong>DefaultQuery</strong>：如果存在，DefaultQuery返回键控url查询值，否则返回指定的defaultValue字符串。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">user := c.DefaultQuery(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>) <span class="hljs-comment">// 此方法可以设置默认值</span><br></code></pre></td></tr></table></figure><p>postman访问:<a href="http://localhost:8080/path/123?pwd=123456">http://localhost:8080/path/123?pwd=123456</a><br><img src="/img/gin_HTTP/getpmDefault.png"></p><h1 id="三、POST请求"><a href="#三、POST请求" class="headerlink" title="三、POST请求"></a>三、POST请求</h1><p>POST 请求的参数一般通过 body 传递给服务器. body 中的数据格式有很多种。</p><ul><li>表单参数可以通过PostForm()方法获取，该方法默认解析的是x-www-form-urlencoded或from-data格式的参数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">r := gin.Default() <span class="hljs-comment">//携带基础中间件启动</span><br>r.POST(<span class="hljs-string">&quot;/path&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>user := c.DefaultPostForm(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>)<br><span class="hljs-comment">//PostForm从POST url编码表单或多部分表单返回指定的键值</span><br>pwd := c.PostForm(<span class="hljs-string">&quot;pwd&quot;</span>)<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-string">&quot;user&quot;</span>:    user,<br><span class="hljs-string">&quot;pwd&quot;</span>:     pwd,<br>&#125;)<br>&#125;)<br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// listen and serve on 0.0.0.0:8080</span><br></code></pre></td></tr></table></figure><p>postman访问:<a href="http://localhost:8080/path">http://localhost:8080/path</a><br><img src="/img/gin_HTTP/post.png"></p><h1 id="四、DELETE请求"><a href="#四、DELETE请求" class="headerlink" title="四、DELETE请求"></a>四、DELETE请求</h1><p>DELETE请求参数挂载在URI,用法与GET请求一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">r := gin.Default() <span class="hljs-comment">//携带基础中间件启动</span><br>r.DELETE(<span class="hljs-string">&quot;/path/:id&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>id := c.Param(<span class="hljs-string">&quot;id&quot;</span>)<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;id&quot;</span>: id,<br>&#125;)<br>&#125;)<br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// listen and serve on 0.0.0.0:8080</span><br></code></pre></td></tr></table></figure><p>postman访问:<a href="http://localhost:8080/path/linzy">http://localhost:8080/path/linzy</a><br><img src="/img/gin_HTTP/delete.png"></p><h1 id="五、PUT请求"><a href="#五、PUT请求" class="headerlink" title="五、PUT请求"></a>五、PUT请求</h1><p>PUT请求与POST请求用法一样，参数一般通过 body 传递给服务器. body 中的数据格式有很多种。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">r := gin.Default() <span class="hljs-comment">//携带基础中间件启动</span><br>r.PUT(<span class="hljs-string">&quot;/path&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>user := c.DefaultPostForm(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;linzy&quot;</span>)<br>pwd := c.PostForm(<span class="hljs-string">&quot;pwd&quot;</span>)<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-string">&quot;user&quot;</span>:    user,<br><span class="hljs-string">&quot;pwd&quot;</span>:     pwd,<br>&#125;)<br>&#125;)<br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// listen and serve on 0.0.0.0:8080</span><br></code></pre></td></tr></table></figure><p>postman访问:<a href="http://localhost:8080/path/linzy">http://localhost:8080/path/linzy</a><br><img src="/img/gin_HTTP/put.png"></p>]]></content>
    
    
    <categories>
      
      <category>Gin框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>gin，http</tag>
      
      <tag>postman</tag>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gin框架入门-快速入门</title>
    <link href="/2022/07/18/gin/"/>
    <url>/2022/07/18/gin/</url>
    
    <content type="html"><![CDATA[<h1 id="一、gin的简单介绍"><a href="#一、gin的简单介绍" class="headerlink" title="一、gin的简单介绍"></a>一、gin的简单介绍</h1><p>Gin 是一个用 Go (Golang) 编写的 Web 框架，由于 httprouter，它具有 martini 的 API，性能提高了 40 倍。具有高性能的优点。<br>官方地址：<a href="https://github.com/gin-gonic/gin">https://github.com/gin-gonic/gin</a></p><h1 id="二、下载并安装"><a href="#二、下载并安装" class="headerlink" title="二、下载并安装"></a>二、下载并安装</h1><p>要安装Gin包，首先需要安装Go并设置Go工作区</p><h2 id="1、下载并安装"><a href="#1、下载并安装" class="headerlink" title="1、下载并安装"></a>1、下载并安装</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-keyword">go</span> get -u github.com/gin-gonic/gin<br></code></pre></td></tr></table></figure><h2 id="2、在代码中导入它"><a href="#2、在代码中导入它" class="headerlink" title="2、在代码中导入它"></a>2、在代码中导入它</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br></code></pre></td></tr></table></figure><h1 id="三、快速入门"><a href="#三、快速入门" class="headerlink" title="三、快速入门"></a>三、快速入门</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default() <span class="hljs-comment">//携带基础中间件启动</span><br>r.GET(<span class="hljs-string">&quot;/test&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;hello gin!&quot;</span>,<br>&#125;)<br>&#125;)<br>r.Run() <span class="hljs-comment">// listen and serve on 0.0.0.0:8080</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行这段代码并在浏览器中访问 <a href="http://localhost:8080，此时监听的是8080端口">http://localhost:8080，此时监听的是8080端口</a></p><p><img src="/img/gin/gin1.png"></p><p>此时显示404 page not found,这是正常的.<br>因为当前我们的GET路由选择在&#x2F;test上，所以我们要访问的是<a href="http://localhost:8080/test">http://localhost:8080/test</a></p><p><img src="/img/gin/gin2.png"></p><p>大功告成！</p>]]></content>
    
    
    <categories>
      
      <category>Gin框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>go</tag>
      
      <tag>gin</tag>
      
      <tag>postman</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/17/hello-world/"/>
    <url>/2022/07/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
